<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Makefile</title>
    <link href="/2023/05/03/Makefile/"/>
    <url>/2023/05/03/Makefile/</url>
    
    <content type="html"><![CDATA[<p><a href="https://gitee.com/yanmu_ym/cpp/blob/master/Make/make.md">https://gitee.com/yanmu_ym/cpp/blob/master/Make/make.md</a></p><h1 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h1><h3 id="Linux（以Ubuntu为例）"><a href="#Linux（以Ubuntu为例）" class="headerlink" title="Linux（以Ubuntu为例）"></a>Linux（以Ubuntu为例）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install gcc g++ make<br></code></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>学习与演示过程以Windows为主，Windows上装MinGW环境，MinGW官网： <a href="https://www.mingw-w64.org/">https://www.mingw-w64.org/</a><br>之前我们提过两个版本的环境，<strong>MingW-W64-builds</strong>和<strong>w64devkit</strong><br>推荐使用<strong>w64devkit</strong>套件，里面工具比较齐全，还提供模拟了许多Linux命令，用这个套件环境来学习可以保持在Linux与Windows上Makefile书写方式一致。<br>以下是w64devkit与其他包一些命令的区别</p><table><thead><tr><th align="center">w64devkit（模拟Linux）</th><th align="center">MingW-W64-builds或其他套件（Windows cmd命令）</th></tr></thead><tbody><tr><td align="center">make</td><td align="center">mingw32-make</td></tr><tr><td align="center">cc</td><td align="center">gcc</td></tr><tr><td align="center">rm</td><td align="center">del</td></tr><tr><td align="center">touch</td><td align="center"></td></tr><tr><td align="center">ls</td><td align="center">dir</td></tr><tr><td align="center">sh</td><td align="center"></td></tr><tr><td align="center">mv</td><td align="center"></td></tr><tr><td align="center">cp</td><td align="center">copy&#x2F;xcopy</td></tr><tr><td align="center">sed</td><td align="center"></td></tr></tbody></table><h3 id="学习材料"><a href="#学习材料" class="headerlink" title="学习材料"></a>学习材料</h3><p>make官方文档： <a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a></p><p>2048: <a href="https://github.com/plibither8/2048.cpp">https://github.com/plibither8/2048.cpp</a></p><p>sudoku:  <a href="https://github.com/mayerui/sudoku">https://github.com/mayerui/sudoku</a></p><h1 id="Makefile基础知识"><a href="#Makefile基础知识" class="headerlink" title="Makefile基础知识"></a>Makefile基础知识</h1><h2 id="make使用流程"><a href="#make使用流程" class="headerlink" title="make使用流程"></a>make使用流程</h2><ol><li>准备好需要编译的源代码</li><li>编写Makefile文件</li><li>在命令行执行make命令</li></ol><h2 id="最简单的Makefile"><a href="#最简单的Makefile" class="headerlink" title="最简单的Makefile"></a>最简单的Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello: hello.cpp</span><br>    g++ hello.cpp -o hello <span class="hljs-comment"># 开头必须为一个Tab，不能为空格</span><br></code></pre></td></tr></table></figure><p><strong>但通常需要将编译与链接分开写，分为如下两步</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello: hello.o</span><br>    g++ hello.o -o hello<br><span class="hljs-section">hello.o: hello.cpp</span><br>    g++ -c hello.cpp<br></code></pre></td></tr></table></figure><p><strong>规则</strong>(Rules)：一个Makefile文件由一条一条的规则构成，一条规则结构如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖)<br>        recipe(方法)<br>        …<br>        …<br></code></pre></td></tr></table></figure><p>第二种写法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖); recipe(方法) ;…<br></code></pre></td></tr></table></figure><p>Make主要用于处理C和C++的编译工作，但不只能处理C和C++，所有编译器&#x2F;解释器能在命令行终端运行的编程语言都可以处理(例如Java、Python、 Golang….)。Make也不只能用来处理编程语言，所有基于一些文件(依赖)的改变去更新另一些文件(目标)的工作都可以做。</p><p><strong>Make编译与打包Java程序示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile">snake.jar : C.class Main.class SnakeFrame.class SnakePanel.class<br>    jar -cvfe snake.jar Main *.class<br><br>C.class : C.java<br>    javac C.java<br><br>Main.class : Main.java<br>    javac Main.java<br><br>SnakeFrame.class : SnakeFrame.java<br>    javac SnakeFrame.java<br><br>SnakePanel.class : SnakePanel.java<br>    javac SnakePanel.java<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm *.class *.jar<br></code></pre></td></tr></table></figure><h2 id="Makefile文件的命名与指定"><a href="#Makefile文件的命名与指定" class="headerlink" title="Makefile文件的命名与指定"></a>Makefile文件的命名与指定</h2><p>Make会自动查找makefile文件，查找顺序为GNUmakefile -&gt; makefile -&gt; Makefile</p><p><strong>GNUmakefile</strong>：不建议使用，因为只有GNU make会识别，其他版本的make（如BSD make, Windows nmake等）不会识别，如果只给GNU make使用的情况</p><p><strong>makefile</strong>：可以使用，GNU make和其他版本make识别</p><p><strong>Makefile</strong>：最常用，强烈建议使用</p><p>如果运行make的时候没有找到以上名字的文件，则会报错，这时候可以手动指定文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -f mkfile  # make -f &lt;filename&gt;<br>make --file=mkfile # make --file=&lt;filename&gt;<br></code></pre></td></tr></table></figure><blockquote><p>手动指定之后，make就会使用指定的文件，即使有Makefile或者makefile不会再自动使用</p></blockquote><h2 id="Makefile文件内容组成"><a href="#Makefile文件内容组成" class="headerlink" title="Makefile文件内容组成"></a>Makefile文件内容组成</h2><p>一个Makefile文件通常由五种类型的内容组成：显式规则、隐式规则、变量定义、指令和注释</p><p><strong>显式规则</strong>(<em>explicit rules</em>)：显式指明何时以及如何生成或更新目标文件，显式规则包括目标、依赖和更新方法三个部分</p><p><strong>隐式规则</strong>(<em>implicit rules</em>)：根据文件自动推导如何从依赖生成或更新目标文件。</p><p><strong>变量定义</strong>(<em>variable definitions</em>)：定议变量并指定值，值都是字符串，类似C语言中的宏定义(#define)，在使用时将值展开到引用位置</p><p><strong>指令</strong>(<em>directives</em>)：在make读取Makefile的过程中做一些特别的操作，包括：</p><ol><li><p>读取(包含)另一个makefile文件(类似C语言中的#include)</p></li><li><p>确定是否使用或略过makefile文件中的一部分内容(类似C语言中的#if)</p></li><li><p>定义多行变量</p></li></ol><p><strong>注释</strong>(<em>comments</em>)：一行当中 # 后面的内容都是注释，不会被make执行。make当中只有单行注释。如果需要用到#而不是注释，用\#。</p><h2 id="一个稍微复杂的Makefile"><a href="#一个稍微复杂的Makefile" class="headerlink" title="一个稍微复杂的Makefile"></a>一个稍微复杂的Makefile</h2><p><img src="/2023/05/03/Makefile/1.png"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">sudoku: block.o command.o input.o main.o scene.o test.o</span><br>    g++ -o sudoku block.o command.o input.o main.o scene.o test.o<br><br><span class="hljs-section">block.o: block.cpp common.h block.h color.h</span><br>    g++ -c block.cpp<br><br><span class="hljs-section">command.o: command.cpp scene.h common.h block.h command.h</span><br>    g++ -c command.cpp<br><br><span class="hljs-section">input.o: input.cpp common.h utility.inl</span><br>    g++ -c input.cpp<br><br><span class="hljs-section">main.o: main.cpp scene.h common.h block.h command.h input.h</span><br>    g++ -c main.cpp<br><br><span class="hljs-section">scene.o: scene.cpp common.h scene.h block.h command.h utility.inl</span><br>    g++ -c scene.cpp<br><br><span class="hljs-section">test.o: test.cpp test.h scene.h common.h block.h command.h</span><br>    g++ -c test.cpp<br><br><span class="hljs-section">hello.o: hello.cpp</span><br>    g++ -c hello.cpp<br><br><br><span class="hljs-section">clean:</span><br>    rm block.o command.o input.o main.o scene.o test.o<br>    rm sudoku.exe<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖)<br>        recipe(方法)<br>        …<br>        …<br></code></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li><p>Makefile中会有很多目标，但最终目标只有一个，其他所有内容都是为这个最终目标服务的，写Makefile的时候<strong>先写出最终目标，再依次解决总目标的依赖</strong></p></li><li><p>一般情况第一条规则中的目标会被确立为最终目标，第一条规则默认会被make执行</p></li><li><p>通常来说目标是一个文件，一条规则的目的就是生成或更新目标文件。</p></li><li><p>make会根据目标文件和依赖文件最后修改时间判断是否需要执行更新目标文件的方法。如果目标文件不存在或者目标文件最后修改时间早于其中一个依赖文件最后修改时间，则重新执行更新目标文件的方法。否则不会执行。</p></li><li><p>除了最终目标对应的更新方法默认会执行外，如果Makefile中一个目标不是其他目标的依赖，那么这个目标对应的规则不会自动执行。需要手动指定，方法为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">make &lt;target&gt;  <span class="hljs-comment"># 如 make clean , make hello.o</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用.DEFAULT_GOAL来修改默认最终目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.DEFAULT_GOAL = main<br><br><span class="hljs-section">all: </span><br>    @echo all<br><br><span class="hljs-section">main:</span><br>    @echo main<br></code></pre></td></tr></table></figure></li></ol><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>如果一个标并不是一个文件，则这个目标就是伪目标。例如前面的clean目标。如果说在当前目录下有一个文件名称和这个目标名称冲突了，则这个目标就没法执行。这时候需要用到一个特殊的目标 .PHONY，将上面的clean目标改写如下 </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm block.o command.o input.o main.o scene.o test.o<br>    rm sudoku.exe<br></code></pre></td></tr></table></figure><p>这样即使当前目录下存在与目标同名的文件，该目标也能正常执行。</p><p><strong>伪目标的其他应用方式</strong></p><p>如果一条规则的依赖文件没有改动，则不会执行对应的更新方法。如果需要每次不论有没有改动都执行某一目标的更新方法，可以把对应的目标添加到.PHONY的依赖中，例如下面这种方式，则每次执行make都会更新test.o，不管其依赖文件有没有改动</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">test.o: test.cpp test.h</span><br>        g++ -c test.cpp<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean test.o</span><br></code></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="依赖类型"><a href="#依赖类型" class="headerlink" title="依赖类型"></a>依赖类型</h3><p><strong>普通依赖</strong></p><p>前面说过的这种形式都是普通依赖。直接列在目标后面。普通依赖有两个特点：</p><ol><li>如果这一依赖是由其他规则生成的文件，那么执行到这一目标前会先执行生成依赖的那一规则 </li><li>如果任何一个依赖文件修改时间比目标晚，那么就重新生成目标文件</li></ol><p><strong>order-only依赖</strong></p><p>依赖文件不存在时，会执行对应的方法生成，但依赖文件更新并不会导致目标文件的更新</p><p>如果目标文件已存在，order-only依赖中的文件即使修改时间比目标文件晚，目标文件也不会更新。</p><p>定义方法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets : normal-prerequisites | order-only-prerequisites<br></code></pre></td></tr></table></figure><p>normal-prerequisites部分可以为空</p><h3 id="指定依赖搜索路径"><a href="#指定依赖搜索路径" class="headerlink" title="指定依赖搜索路径"></a>指定依赖搜索路径</h3><p>make默认在Makefile文件所在的目录下查找依赖文件，如果找不到，就会报错。这时候就需要手动指定搜索路径，用VPATH变量或vpath指令。</p><p><strong>VPATH用法如下：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = &lt;dir1&gt;:&lt;dir2&gt;:&lt;dir3&gt;...<br><span class="hljs-comment"># 例如</span><br>VPATH = <span class="hljs-keyword">include</span>:src<br></code></pre></td></tr></table></figure><p>多个目录之间冒号隔开，这时make会在VPATH指定的这些目录里面查找依赖文件。</p><p><strong>vpath指令用法：</strong></p><p>vpath比VPATH使用更灵活，可以指定某个类型的文件在哪个目录搜索。</p><p>用法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;<br><br><span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span>  <span class="hljs-comment"># .h文件在include目录下查找</span><br><span class="hljs-keyword">vpath</span> %.h <span class="hljs-keyword">include</span>:headers  <span class="hljs-comment"># .h文件在include或headers文件下查找</span><br><br><span class="hljs-keyword">vpath</span> % src   <span class="hljs-comment"># 所有文件都在src下查找</span><br><br><span class="hljs-keyword">vpath</span> hello.cpp src  <span class="hljs-comment"># hello.cpp文件在src查找</span><br></code></pre></td></tr></table></figure><h2 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … (目标): prerequisites …(依赖)<br>        recipe(方法)<br>        …<br>        …<br></code></pre></td></tr></table></figure><h4 id="关于执行终端"><a href="#关于执行终端" class="headerlink" title="关于执行终端"></a>关于执行终端</h4><p>更新方法实际上是一些Shell指令，通常以Tab开头，或直接放在目标-依赖列表后面，用分号隔开。这些指令都需要交给Shell执行，所以需要符合Shell语法。默认使用的Shell是sh，在Windows上如果没有安装sh.exe的话会自动查找使用cmd.exe之类的终端。这时有的指令写法，例如循环语句，与Linux不同，需要注意。</p><p>可以通过SHELL变量手动指定Shell</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SHELL = C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe<br>SHELL = cmd.exe<br></code></pre></td></tr></table></figure><p>默认的执行方式为一条指令重新调用一个Shell进程来执行。有时为了提高性能或其他原因，想让这个目标的所有指令都在同一进程中执行，可以在Makefile中添加 .ONESHELL</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">.ONESHELL:</span><br></code></pre></td></tr></table></figure><p>这样所有指令都会在同一次Shell调用中执行</p><h4 id="Shell语句回显问题"><a href="#Shell语句回显问题" class="headerlink" title="Shell语句回显问题"></a>Shell语句回显问题</h4><p>通常make在执行一条Shell语句前都会先打印这条语句，如果不想打印可以在语句开头在@</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">@echo hello<br>@g++ -o hello hello.cpp<br></code></pre></td></tr></table></figure><p>也可以使用.SILENT来指定哪些目标的更新方法指令不用打印</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">.SILENT: main all</span><br></code></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果一条规则当中包含多条Shell指令，每条指令执行完之后make都会检查返回状态，如果返回状态是0，则执行成功，继续执行下一条指令，直到最后一条指令执行完成之后，一条规则也就结束了。</p><p>如果过程中发生了错误，即某一条指令的返回值不是0，那么make就会终止执行当前规则中剩下的Shell指令。</p><p>例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    rm main.o hello.o<br>    rm main.exe<br></code></pre></td></tr></table></figure><p>这时如果第一条rm main.o hello.o出错，第二条rm main.exe就不会执行。类似情况下，希望make忽视错误继续下一条指令。在指令开头<code>-</code>可以达到这种效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>    -rm main.o hello.o<br>    -rm main.exe<br></code></pre></td></tr></table></figure><h2 id="变量应用"><a href="#变量应用" class="headerlink" title="变量应用"></a>变量应用</h2><p>Makefile中的变量有点类似C语言中的宏定义，即用一个名称表示一串文本。但与C语言宏定义不同的是，Makefile的变量值是可以改变的。变量定义之后可以在目标、依赖、方法等Makefile文件的任意地方进行引用。</p><blockquote><p>Makefile中的变量值只有一种类型： 字符串</p></blockquote><p><strong>变量可以用来表示什么</strong></p><ul><li><p>文件名序列</p></li><li><p>编译选项</p></li><li><p>需要运行的程序</p></li><li><p>需要进行操作的路径</p></li><li><p>……</p></li></ul><h3 id="变量定义与引用方式"><a href="#变量定义与引用方式" class="headerlink" title="变量定义与引用方式"></a>变量定义与引用方式</h3><p><strong>定义方式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># &lt;变量名&gt; = &lt;变量值&gt;  &lt;变量名&gt; := &lt;变量值&gt;  &lt;变量名&gt; ::= &lt;变量值&gt;</span><br>files = main.cpp hello.cpp<br>objects := main.o hello.o<br>var3 ::= main.o<br></code></pre></td></tr></table></figure><blockquote><p>变量名区分大小写，可以是任意字符串，不能含有”:”, “#”, “&#x3D;”</p></blockquote><p><strong>使用方式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># $(&lt;变量名&gt;) 或者 $&#123;&lt;变量名&gt;&#125;</span><br>main.o : <span class="hljs-variable">$(files)</span> <span class="hljs-comment"># 或者 $&#123;files&#125;</span><br>    ...<br></code></pre></td></tr></table></figure><blockquote><p>如果变量名只有一个字符，使用时可以不用括号，如$a, $b， 但不建议这样用，不管是否只有一个字符都写成$(a), $(b)这种形式</p></blockquote><h3 id="Makefile读取过程"><a href="#Makefile读取过程" class="headerlink" title="Makefile读取过程"></a>Makefile读取过程</h3><p>GNU make分两个阶段来执行Makefile，第一阶段(读取阶段)：</p><ul><li><p>读取Makefile文件的所有内容</p></li><li><p>根据Makefile的内容在程序内建立起变量</p></li><li><p>在程序内构建起显式规则、隐式规则</p></li><li><p>建立目标和依赖之间的依赖图</p></li></ul><p>第二阶段(目标更新阶段)：</p><ul><li>用第一阶段构建起来的数据确定哪个目标需要更新然后执行对应的更新方法</li></ul><p>变量和函数的展开如果发生在第一阶段，就称作<strong>立即展开</strong>，否则称为<strong>延迟展开</strong>。立即展开的变量或函数在第一个阶段，也就是Makefile被读取解析的时候就进行展开。延迟展开的变量或函数将会到用到的时候才会进行展开，有以下两种情况：</p><ul><li><p>在一个立即展开的表达式中用到</p></li><li><p>在第二个阶段中用到</p></li></ul><p><strong>显式规则中，目标和依赖部分都是立即展开，在更新方法中延迟展开</strong></p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><h4 id="递归展开赋值（延迟展开）"><a href="#递归展开赋值（延迟展开）" class="headerlink" title="递归展开赋值（延迟展开）"></a>递归展开赋值（延迟展开）</h4><p>第一种方式就是直接使用<kbd>=</kbd>，这种方式如果赋值的时候右边是其他变量引用或者函数调用之类的，将不会做处理，直接保留原样，在使用到该变量的时候再来进行处理得到变量值（Makefile执行的第二个阶段再进行变量展开得到变量值）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 = ThisIsBar2No.1<br>foo = <span class="hljs-variable">$(bar)</span><br>foo2 = <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>  <span class="hljs-comment"># Huh?</span><br>    @echo <span class="hljs-variable">$(foo2)</span>  <span class="hljs-comment"># ThisIsBar2No.2</span><br>    @echo <span class="hljs-variable">$(ugh)</span>   <span class="hljs-comment"># Huh?</span><br><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br>bar2 = ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h4 id="简单赋值-立即展开"><a href="#简单赋值-立即展开" class="headerlink" title="简单赋值(立即展开)"></a>简单赋值(立即展开)</h4><p>简单赋值使用<kbd>:=</kbd>或<kbd>::=</kbd>，这种方式如果等号右边是其他变量或者引用的话，将会在赋值的时候就进行处理得到变量值。（Makefile执行第一阶段进行变量展开）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">bar2 := ThisIsBar2No.1<br>foo := <span class="hljs-variable">$(bar)</span><br>foo2 := <span class="hljs-variable">$(bar2)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span>    <span class="hljs-comment"># 空串，没有内容</span><br>    @echo <span class="hljs-variable">$(foo2)</span>    <span class="hljs-comment"># ThisIsBar2No.1</span><br>    @echo <span class="hljs-variable">$(ugh)</span>    <span class="hljs-comment"># </span><br><br>bar := <span class="hljs-variable">$(ugh)</span><br>ugh := Huh?<br>bar2 := ThisIsBar2No.2<br></code></pre></td></tr></table></figure><h4 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h4><p>条件赋值使用<kbd>?=</kbd>，如果变量已经定义过了（即已经有值了），那么就保持原来的值，如果变量还没赋值过，就把右边的值赋给变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = 100<br>var1 ?= 200<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span> <span class="hljs-comment"># 100 注释var1 = 100之后为200</span><br></code></pre></td></tr></table></figure><p><strong>练习</strong>：试求a的值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = hello<br>y = world<br>a := <span class="hljs-variable">$(x)</span><span class="hljs-variable">$(y)</span><br><br>x = y<br>y = z<br>a := $(<span class="hljs-variable">$(x)</span>)<br><br>x = y<br>y = z<br>z = u<br>a := $($(<span class="hljs-variable">$(x)</span>))<br><br>x = <span class="hljs-variable">$(y)</span><br>y = z<br>z = Hello<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><p>使用<kbd>+=</kbd>在变量已有的基础上追加内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = main.cpp<br>files += hello.cpp<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(files)</span><br></code></pre></td></tr></table></figure><h4 id="Shell运行赋值"><a href="#Shell运行赋值" class="headerlink" title="Shell运行赋值"></a>Shell运行赋值</h4><p>使用<kbd>!=</kbd>，运行一个Shell指令后将返回值赋给一个变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">gcc_version != gcc --version<br>files != ls .<br></code></pre></td></tr></table></figure><blockquote><p>如果使用Windows需要注意，这种赋值方式只适用于与Linux相同的Shell指令，Windows独有的指令不能这样使用。</p></blockquote><h3 id="定义多行变量"><a href="#定义多行变量" class="headerlink" title="定义多行变量"></a>定义多行变量</h3><p>前面定义的变量都是单行的。</p><p>变量值有多行，多用于定义shell指令</p><p><strong>语法</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> &lt;varable_name&gt;  <span class="hljs-comment"># 默认为 = </span><br><span class="hljs-comment"># 变量内容</span><br><span class="hljs-keyword">endef</span><br><br><span class="hljs-keyword">define</span> &lt;varable_name&gt; :=<br><span class="hljs-comment"># 变量内容</span><br><span class="hljs-keyword">endef</span><br><br><span class="hljs-keyword">define</span> &lt;varable_name&gt; +=<br><span class="hljs-comment"># 变量内容</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><p>&amp;nbsp;</p><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">echosomething = @echo This is the first line<br><br><span class="hljs-keyword">define</span> echosomething +=  <br><br>@echo hello<br>@echo world<br>@echo 3<br><span class="hljs-keyword">endef</span><br><br><br><span class="hljs-section">all:</span><br>    <span class="hljs-variable">$(echosomething)</span><br></code></pre></td></tr></table></figure><h3 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h3><p>如果想清除一个变量，用以下方法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">undefine</span> &lt;变量名&gt;   如 <span class="hljs-keyword">undefine</span> files,  <span class="hljs-keyword">undefine</span> objs<br></code></pre></td></tr></table></figure><h3 id="环境变量的使用"><a href="#环境变量的使用" class="headerlink" title="环境变量的使用"></a>环境变量的使用</h3><p>系统中的环境变量可以直接在Makefile中直接使用，使用方法跟普通变量一样</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(USERNAME)</span><br>    @echo <span class="hljs-variable">$(JAVA_HOME)</span><br>    @echo <span class="hljs-variable">$(SystemRoot)</span><br></code></pre></td></tr></table></figure><h3 id="变量替换引用"><a href="#变量替换引用" class="headerlink" title="变量替换引用"></a>变量替换引用</h3><p>语法：__$(var:a&#x3D;b)__，意思是将变量var的值当中每一项结尾的a替换为b，直接上例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = main.cpp hello.cpp<br>objs := $(files:.cpp=.o) <span class="hljs-comment"># main.o hello.o</span><br><span class="hljs-comment"># 另一种写法</span><br>objs := $(files:%.cpp=%.o)<br></code></pre></td></tr></table></figure><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>所有在Makefile中的变量，都可以在执行make时能过指定参数的方式进行覆盖。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>如果直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure><p>则上面的输出内容为<em>ThisIsInMakefile</em>，但可以在执行make时指定参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">make OverridDemo=ThisIsFromOutShell # 等号两边不能有空格<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果变量值中有空格，需要用引号</span><br>make OverridDemo=“This Is From Out Shell”<br></code></pre></td></tr></table></figure><p>则输出OverridDemo的值是ThisIsFromOutShell或This Is From Out Shell。</p><p>用这样的命令参数会覆盖Makefile中对应变量的值，如果不想被覆盖，可以在变量前加上override指令，override具有较高优先级，不会被命令参数覆盖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> OverridDemo := ThisIsInMakefile<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(OverridDemo)</span><br></code></pre></td></tr></table></figure><p>这样即使命令行指定参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make OverridDemo=ThisIsFromOutShell<br></code></pre></td></tr></table></figure><p>输出结果依然是ThisIsInMakefile</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>**$@**：①本条规则的目标名；②如果目标是归档文件的成员，则为归档文件名；③在多目标的模式规则中, 为导致本条规则方法执行的那个目标名；</p><p>**$&lt;**：本条规则的第一个依赖名称</p><p>**$?**：依赖中修改时间晚于目标文件修改时间的所有文件名，以空格隔开</p><p><strong>$^</strong>：所有依赖文件名，文件名不会重复，不包含order-only依赖</p><p>**$+**：类似上一个， 表示所有依赖文件名，包括重复的文件名，不包含order-only依赖</p><p>**$|**：所有order-only依赖文件名</p><p>__$*__：(简单理解)目标文件名的主干部分(即不包括后缀名)</p><p>**$%**：如果目标不是归档文件，则为空；如果目标是归档文件成员，则为对应的成员文件名</p><p>&amp;nbsp;</p><p>以下变量对应上述变量，D为对应变量所在的目录，结尾不带&#x2F;，F为对应变量除去目录部分的文件名</p><p><strong>$(@D)</strong></p><p><strong>$(@F)</strong></p><p><strong>$(*D)</strong></p><p><strong>$(*F)</strong></p><p><strong>$(%D)</strong></p><p><strong>$(%F)</strong></p><p><strong>$(&lt;D)</strong></p><p><strong>$(&lt;F)</strong></p><p><strong>$(^D)</strong></p><p><strong>$(^F)</strong></p><p><strong>$(+D)</strong></p><p><strong>$(+F)</strong></p><p><strong>$(?D)</strong></p><p><strong>$(?F)</strong></p><h3 id="绑定目标的变量"><a href="#绑定目标的变量" class="headerlink" title="绑定目标的变量"></a>绑定目标的变量</h3><p>Makefile中的变量一般是全局变量。也就是说定义之后在Makefile的任意位置都可以使用。但也可以将变量指定在某个目标的范围内，这样这个变量就只能在这个目标对应的规则里面保用</p><p>语法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target … : variable-assignment<br>target … : prerequisites<br>    recipes<br>    …<br></code></pre></td></tr></table></figure><p>例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = Global Var<br><br><span class="hljs-section">first: all t2</span><br><br><span class="hljs-section">all: var2 = Target All Var</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br><br><span class="hljs-section">t2:</span><br>    @echo <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$(var2)</span><br></code></pre></td></tr></table></figure><p>这种定义变量的方式，目标也可以使用模式匹配，这样所有能匹配上的目标范围内都可以使用这些变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">var1 = Global Var<br><br><span class="hljs-section">first: all.v t2.v t3</span><br><br><span class="hljs-section">%.v: var2 = Target %.v Var</span><br><span class="hljs-section">all.v:</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var2)</span><br><br><span class="hljs-section">t2.v:</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var2)</span><br><span class="hljs-section">t3:</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var1)</span><br>    @echo <span class="hljs-variable">$@</span> -- <span class="hljs-variable">$(var2)</span><br></code></pre></td></tr></table></figure><h3 id="二次展开"><a href="#二次展开" class="headerlink" title="二次展开"></a>二次展开</h3><p>前面说过依赖中的变量都是在Makefile读取阶段立即展开的。如果想让依赖的变量延迟展开，可以使用.SECONDEXPANSION:，添加之后，在依赖中使用变量时用<code>$$</code>，可以让变量在第二阶段进行二次展开，从而达到延迟展开的效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VAR1 = main.cpp<br><span class="hljs-section">.SECONDEXPANSION:</span><br><span class="hljs-section">all: $<span class="hljs-variable">$(VAR1)</span></span><br>    @echo <span class="hljs-variable">$^</span><br><br>VAR1 = hello.cpp<br></code></pre></td></tr></table></figure><h1 id="自动推导与隐式规则"><a href="#自动推导与隐式规则" class="headerlink" title="自动推导与隐式规则"></a>自动推导与隐式规则</h1><p>Makefile中有一些生成目标文件的规则使用频率非常高，比如由.c或.cpp文件编译成.o文件，这样的规则在make中可以自动推导，所以可以不用明确写出来，这样的规则称为隐式规则。</p><h2 id="一些make预定义的规则"><a href="#一些make预定义的规则" class="headerlink" title="一些make预定义的规则"></a>一些make预定义的规则</h2><h3 id="C语言编译"><a href="#C语言编译" class="headerlink" title="C语言编译"></a>C语言编译</h3><p>从.c到.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CPPFLAGS)</span> <span class="hljs-variable">$(CFLAGS)</span> -c<br></code></pre></td></tr></table></figure><h3 id="C-编译"><a href="#C-编译" class="headerlink" title="C++编译"></a>C++编译</h3><p>从.cc .cpp .C到.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(CPPFLAGS)</span> <span class="hljs-variable">$(CXXFLAGS)</span> -c<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>由.o文件链接到可执行文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(LDFLAGS)</span> *.o <span class="hljs-variable">$(LOADLIBES)</span> <span class="hljs-variable">$(LDLIBS)</span><br></code></pre></td></tr></table></figure><h2 id="隐式规则中常用一些变量"><a href="#隐式规则中常用一些变量" class="headerlink" title="隐式规则中常用一些变量"></a>隐式规则中常用一些变量</h2><p>这些变量都有默认值，也可以自行修改</p><h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>编译C语言的程序，默认为 <code>cc</code></p><h3 id="CXX"><a href="#CXX" class="headerlink" title="CXX"></a>CXX</h3><p>编译C++的程序，默认为 <code>g++</code></p><h3 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h3><p>归档程序，默认为 <code>ar</code></p><h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><p>C语言预处理程序，默认为 <code>$(CC) -E</code></p><h3 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h3><p>删除文件的程序，默认为<code>rm -f</code></p><h3 id="CFLAGS"><a href="#CFLAGS" class="headerlink" title="CFLAGS"></a>CFLAGS</h3><p>传递给C编译器的一些选项，如-O2 -Iinclude</p><h3 id="CXXFLAGS"><a href="#CXXFLAGS" class="headerlink" title="CXXFLAGS"></a>CXXFLAGS</h3><p>传递给C++编译器的一些选项，如-std&#x3D;c++ 11 -fexec-charset&#x3D;GBK   </p><h3 id="CPPFLAGS"><a href="#CPPFLAGS" class="headerlink" title="CPPFLAGS"></a>CPPFLAGS</h3><p>C语言预处理的一些选项</p><h3 id="LDFLAGS"><a href="#LDFLAGS" class="headerlink" title="LDFLAGS"></a>LDFLAGS</h3><p>链接选项，如-L.</p><h3 id="LDLIBS"><a href="#LDLIBS" class="headerlink" title="LDLIBS"></a>LDLIBS</h3><p>链接需要用到的库，如-lkernel32 -luser32 -lgdi32</p><h1 id="多目标与多规则"><a href="#多目标与多规则" class="headerlink" title="多目标与多规则"></a>多目标与多规则</h1><p>显式规则中一条规则可以有多个目标，多个目标可以是相互独立的目标，也可以是组合目标，用写法来区分</p><h2 id="独立多目标"><a href="#独立多目标" class="headerlink" title="独立多目标"></a>独立多目标</h2><p>相互独立的多个目标与依赖之间直接用<code>:</code>，常用这种方式的有以下两种情况</p><ol><li><p>只需要写目标和依赖，不需要写方法的时候</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o input.o scene.o : common.h<br></code></pre></td></tr></table></figure><p>这种写法等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : common.h<br>input.o : common.h<br>scene.o : common.h<br></code></pre></td></tr></table></figure></li><li><p>生成(更新)目标的方法写法一样的，只是依赖与目标不一样时。之前写的Makfile中，有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">block.o: block.cpp common.h block.h color.h</span><br>    g++ -c block.cpp<br><span class="hljs-section">command.o: command.cpp command.h scene.h</span><br>    g++ -c command.cpp<br><span class="hljs-section">input.o: input.cpp common.h utility.inl</span><br>    g++ -c input.cpp<br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br><span class="hljs-section">scene.o: scene.cpp common.h scene.h utility.inl</span><br>    g++ -c scene.cpp<br><span class="hljs-section">test.o: test.cpp test.h</span><br>    g++ -c test.cpp<br></code></pre></td></tr></table></figure><p>所有.o文件的生成都用的同一方法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">g++ -c &lt;文件名&gt;<br></code></pre></td></tr></table></figure><p>如果不考虑依赖源文件进行更新时，可以进行简写如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o command.o input.o main.o scene.o test.o : common.h block.h command.h ...<br>    g++ -c $(@:%.o=%.cpp)<br></code></pre></td></tr></table></figure><p>这种写法实际上等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>command.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>input.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>main.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>scene.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br>test.o : common.h block.h command.h ...<br>    g++ -c <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$@</span>)</span><br></code></pre></td></tr></table></figure><p>其中，$@表示的是目标名称。subst是一个字符串替换函数，$(subst .o,.cpp,$@)表示将目标名称中的.o替换为.cpp。</p><p>这样的简写可以减少内容的书写量，但是不利于将每个目标与依赖分别对应。</p></li></ol><p>独立多目标虽然写在一起，但是每个目标都是单独调用一次方法来更新的。和分开写效果一样。</p><h2 id="组合多目标"><a href="#组合多目标" class="headerlink" title="组合多目标"></a>组合多目标</h2><p>多目标与依赖之前用<code>&amp;:</code>，这样的多个目标称为组合目标。与独立多目标的区别在于，独立多目标每个目标的更新需要单独调用一次更新方法。而组合多目标调用一次方法将更新所有目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o input.o scene.o &amp;: block.cpp input.cpp scene.cpp common.h<br>    g++ -c block.cpp<br>    g++ -c input.cpp<br>    g++ -c scene.cpp<br></code></pre></td></tr></table></figure><p>所有目标的更新方法都写到其中，每次更新只会调用一次。</p><h2 id="同一目标多条规则"><a href="#同一目标多条规则" class="headerlink" title="同一目标多条规则"></a>同一目标多条规则</h2><p>同一目标可以对应多条规则。同一目标的所有规则中的依赖会被合并。但如果同一目标对应的多条规则都写了更新方法，则会使用最新的一条更新方法，并且会输出警告信息。</p><p>同一目标多规则通常用来给多个目标添加依赖而不用改动已写好的部分。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">input.o: input.cpp utility.inl</span><br>    g++ -c input.cpp<br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br><span class="hljs-section">scene.o: scene.cpp scene.h utility.inl</span><br>    g++ -c scene.cpp<br><br>input.o main.o scene.o : common.h<br></code></pre></td></tr></table></figure><p>同时给三个目标添加了一个依赖common.h，但是不用修改上面已写好的部分。</p><h1 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h1><p>独立多目标可以简化Makefile的书写，但是不利于将各个目标的依赖分开，让目标文件根据各自的依赖进行更新。静态模式可以在一定程度上改进依赖分开问题。</p><p>静态模式就是用<code>%</code>进行文件匹配来推导出对应的依赖。</p><p><strong>语法</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets …: target-pattern(目标模式): prereq-patterns(依赖模式) …<br>        recipe<br>        …<br></code></pre></td></tr></table></figure><p>先看一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : %.o : %.cpp %.h<br>    g++ -c <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p>block.o为目标，%.o为目标模式，%.cpp，%.h为依赖模式，对于这一条规则，%.o代表的是目标文件block.o，所以这里的%匹配的是block，因此，%.cpp表示block.cpp，%.h代表block.h，所以block.o : %.o : %.cpp %.h表示的意思同下面这种写法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o : block.cpp block.h<br></code></pre></td></tr></table></figure><p>自动推导出block.o依赖block.cpp和block.h。</p><p>另外，$&lt;表示目标的第一个依赖，在这条规则中，$&lt;表示block.cpp</p><p>对应的Makefile可以做如下改进</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">block.o command.o input.o scene.o test.o: %.o : %.cpp %.h<br>    g++ -c <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">main.o: main.cpp scene.h input.h test.h</span><br>    g++ -c main.cpp<br></code></pre></td></tr></table></figure><p>用这种方式可以在简写的同时一定程度上解决各个目标对应的依赖问题。</p><p>(不属于静态模式的内容，隐式规则的内容)利用模式匹配可以直接将所有.cpp到.o文件的编译简写为如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">%.o : %.cpp %.h<br>    g++ -c <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>使用条件指令可以让make执行或略过Makefile文件中的一些部分。</p><p><strong>ifdef</strong>  判断一个变量是已否定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OS = Linux<br><span class="hljs-keyword">ifdef</span> Win<br>    OS = Windows<br><span class="hljs-keyword">endif</span><br><br><br>OS = Linux<br><span class="hljs-keyword">ifdef</span> Win<br>    OS = Windows<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifdef</span> Mac<br>    OS= MacOS<br><span class="hljs-keyword">endif</span><br><br><br><span class="hljs-keyword">ifdef</span> Win<br>    OS = Windows<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifdef</span> Mac<br>    OS= MacOS<br><span class="hljs-keyword">else</span> <br>    OS = Linux<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p><strong>ifndef</strong> 判断一个变量是否没被定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifndef</span> FLAGS<br>    FLAGS = -finput-charset=utf-8<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p><strong>ifeq</strong> 判断两个值是否相等</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile">version = 3.0<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>,1.0)            <span class="hljs-comment"># ifeq后一定要一个空格</span><br>    msg := 版本太旧了，请更新版本<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(version)</span>, 3.0)<br>    msg := 版本太新了，也不行<br><span class="hljs-keyword">else</span><br>    msg := 版本可以用<br><span class="hljs-keyword">endif</span><br><br><br><span class="hljs-comment"># 另外的写法</span><br>msg = Other<br><span class="hljs-keyword">ifeq</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(OS)</span>&quot;</span> <span class="hljs-string">&quot;Windows_NT&quot;</span><br>    msg = This is a Windows Platform<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; &#x27;Windows_NT&#x27;<br><br><span class="hljs-keyword">ifeq</span> &#x27;<span class="hljs-variable">$(OS)</span>&#x27; <span class="hljs-string">&quot;Windows_NT&quot;</span><br></code></pre></td></tr></table></figure><p><strong>ifneq</strong> 判断两个值是否不等</p><p>用法及参数同ifeq，只是判断结果相反</p><p>&amp;nbsp;</p><p>&amp;nbsp;</p><p>&amp;nbsp;</p><p>&amp;nbsp;</p><p>&amp;nbsp;</p><h1 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h1><p>C语言中，函数调用方法是function(arguments)；但在Makefile中调用函数的写法不同</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(function arguments)</span> 或 $&#123;function arguments&#125;<br><span class="hljs-variable">$(function arg1,<span class="hljs-variable">$(arg2)</span>,arg3 ...)</span>  <span class="hljs-comment"># 参数之间不要有空格</span><br></code></pre></td></tr></table></figure><h2 id="字符替换与分析"><a href="#字符替换与分析" class="headerlink" title="字符替换与分析"></a>字符替换与分析</h2><h4 id="subst"><a href="#subst" class="headerlink" title="subst"></a><strong>subst</strong></h4><p>文本替换函数，返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> target,replacement,text)</span><br>        --- 用relacement替换text中的target<br>        --- target 需要替换的内容<br>        --- replacement 替换为的内容<br>        --- text 需要处理的内容，可以是任意字符串<br><br><br><br>objs = main.o hello.o<br>srcs = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .o,.cpp,<span class="hljs-variable">$(objs)</span>)</span><br>headers = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .cpp,.h,<span class="hljs-variable">$(srcs)</span>)</span><br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(srcs)</span><br>    @echo <span class="hljs-variable">$(headers)</span><br></code></pre></td></tr></table></figure><p><strong>patsubst</strong></p><p>模式替换， 返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> pattern,replacement,text)</span><br>        --- pattern 需要替换的模式<br>        --- replacement 需要替换为<br>        --- text 待处理内容，各项内容需要用空格隔开<br><br><br>objs = main.ohello.o<br>srcs = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> %.o,%.cpp,<span class="hljs-variable">$(objs)</span>)</span><br>headers = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> %.cpp,%.h,<span class="hljs-variable">$(srcs)</span>)</span>    <br></code></pre></td></tr></table></figure><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a><strong>strip</strong></h4><p>去除字符串头部和尾部的空格，中间如果连续有多个空格，则用一个空格替换，返回去除空格后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> string)</span><br>        --- string 需要去除空格的字符串<br><br><br>files = aa hello.cpp      main.cpp     test.cpp<br>files := <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> aa,        ,<span class="hljs-variable">$(files)</span>)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">strip</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><p>查找字符串，如果找到了，则返回对应的字符串，如果没找到，则反回空串</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> find,string)</span><br>        --- find 需要查找的字符串<br>        --- string 用来查找的内容<br><br>files = hello.cpp main.cpp test.cpp<br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> hel,<span class="hljs-variable">$(files)</span>)</span><br>find = <span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> HEL,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>从文本中筛选出符合模式的内容并返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> %.o %.h,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h4><p>与filter相反，过滤掉符合模式的，返回剩下的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out pattern…,text)</span><br>        --- pattern 模式，可以有多个，用空格隔开<br>        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out %.o %.cpp,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>将文本内的各项按字典顺序排列，并且移除重复项</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> list)</span><br>        --- list 需要排序内容<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><p>用于返回文本中第n个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">word</span> n,text)</span><br>        --- n 第n个单词，从1开始，如果n大于总单词数，则返回空串<br>        --- text 待处理文本<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">word</span> 3,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>用于返回文本指定范围内的单词列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> start,end,text)</span><br>        --- start 起始位置，如果大于单词总数，则返回空串<br>        --- end 结束位置，如果大于单词总数，则返回起始位置之后全部，如果start &gt; end，什么都不返回<br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> 3,6,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>返回文本中单词数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(words text)</span><br>        --- text 需要处理的文本<br><br><br>files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp<br>nums = <span class="hljs-variable">$(words <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><p>返回第一个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> text)</span><br></code></pre></td></tr></table></figure><h4 id="lastword"><a href="#lastword" class="headerlink" title="lastword"></a>lastword</h4><p>返回最后一个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">lastword</span> text)</span><br></code></pre></td></tr></table></figure><h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>返回文件目录</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> files)</span><br>        --- files 需要返回目录的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><p>返回除目录部分的文件名</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> files)</span><br>        --- files 需要返回文件列表，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h4><p>返回文件后缀名，如果没有后缀返回空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> files)</span><br>        --- files 需要返回后缀的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><p>返回文件名除后缀的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">basename</span> files)</span><br>        --- files 需要返回的文件名，可以有多个，用空格隔开<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><p>给文件名添加后缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> <span class="hljs-built_in">suffix</span>,files)</span><br>        --- suffix 需要添加的后缀<br>        --- files 需要添加后缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> .exe,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>给文件名添加前缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> prefix,files)</span><br>        --- prefix 需要添加的前缀<br>        --- files 需要添加前缀的文件名，可以有多个，用空格隔开<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> make/,<span class="hljs-variable">$(files)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>将两个列表中的内容一对一连接，如果两个列表内容数量不相等，则多出来的部分原样返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">join</span> list1,list2)</span><br>        --- list1 第一个列表<br>        --- list2 需要连接的第二个列表<br><br><br>f1 = hello main test<br>f2 = .cpp .hpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">join</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><p>返回符合通配符的文件列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> pattern)</span><br>        --- pattern 通配符<br><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cpp)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*.cpp)</span><br></code></pre></td></tr></table></figure><h4 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h4><p>返回文件的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> files)</span><br>        --- files 需要返回绝对路径的文件，可以有多个，用空格隔开<br><br>f3 = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*)</span><br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> <span class="hljs-variable">$(f3)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h4><p>返回绝对路径，用法同realpath，如果一个文件名不存在，realpath不会返回内容，abspath则会返回一个当前文件夹一下的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">abspath</span> files)</span><br></code></pre></td></tr></table></figure><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>条伯判断，如果条件展开不是空串，则反回真的部分，否则返回假的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> condition,then-part[,else-part])</span><br>        --- condition 条件部分<br>        --- then-part 条件为真时执行的部分<br>        --- else-part 条件为假时执行的部分，如果省略则为假时返回空串<br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(files)</span>,有文件,没有文件)</span><br></code></pre></td></tr></table></figure><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>返回条件中第一个不为空的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">or</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = <br>f2 = <br>f3 = hello.cpp<br>f4 = main.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">or</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>如果条件中有一个为空串，则返回空，如果全都不为空，则返回最后一个条件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">and</span> condition1[,condition2[,condition3…]])</span><br><br>f1 = 12<br>f2 = 34<br>f3 = hello.cpp<br>f4 = main.cpp<br>files2 = <span class="hljs-variable">$(<span class="hljs-built_in">and</span> <span class="hljs-variable">$(f1)</span>,<span class="hljs-variable">$(f2)</span>,<span class="hljs-variable">$(f3)</span>,<span class="hljs-variable">$(f4)</span>)</span><br></code></pre></td></tr></table></figure><h4 id="intcmp"><a href="#intcmp" class="headerlink" title="intcmp"></a>intcmp</h4><p>比较两个整数大小，并返回对应操作结果（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])</span> <br>        --- lhs 第一个数<br>        --- rhs 第二个数<br>        --- lt-part  lhs &lt; rhs时执行<br>        --- eq-part  lhs = rhs时执行<br>        --- gt-part  lhs &gt; rhs时执行<br>        --- 如果只提供前两个参数，则lhs == rhs时返回数值，否则返回空串<br>            参数为lhs,rhs,lt-part时，当lhs &lt; rhs时返回lt-part结果，否则返回空<br>            参数为lhs,rhs,lt-part,eq-part，lhs &lt; rhs返回lt-part结果，否则都返回eq-part结果<br>            参数全时，lhs &lt; rhs返回lt-part，lhs == rhs返回eq-part, lhs &gt; rhs返回gt-part<br><br><br><br>@echo <span class="hljs-variable">$(intcmp 2,2,-1,0,1)</span><br></code></pre></td></tr></table></figure><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>读写文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">file</span> op filename[,text])</span><br>        --- op 操作<br>                &gt; 覆盖<br>                &gt;&gt; 追加<br>                &lt; 读<br>        --- filename 需要操作的文件名<br>        --- text 写入的文本内容，读取是不需要这个参数<br><br><br>files = src/hello.cpp main.cpp hello.o hello.hpp hello<br>write = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &gt; makewrite.txt,<span class="hljs-variable">$(files)</span>)</span><br>read = <span class="hljs-variable">$(<span class="hljs-built_in">file</span> &lt; makewrite.txt)</span><br></code></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>对一列用空格隔开的字符序列中每一项进行处理，并返回处理后的列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,list,process)</span><br>        --- each list中的每一项<br>        --- list 需要处理的字符串序列，用空格隔开<br>        --- process 需要对每一项进行的处理<br><br>list = 1 2 3 4 5<br>result = <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> each,<span class="hljs-variable">$(list)</span>,$(<span class="hljs-built_in">addprefix</span> cpp,$(<span class="hljs-built_in">addsuffix</span> .cpp,<span class="hljs-variable">$(each)</span>)</span>))<br></code></pre></td></tr></table></figure><p>作用类似C&#x2F;C++中的循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> list[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> result[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> each;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    each = list[i];<br>    result[i] = <span class="hljs-built_in">process</span>(each);<br>&#125;<br><span class="hljs-comment">// 此时result即为返回结果</span><br></code></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>将一些复杂的表达式写成一个变量，用call可以像调用函数一样进行调用。类似于编程语言中的自定义函数。在函数中可以用$(n)来访问第n个参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> funcname,param1,param2,…)</span><br>        --- funcname 自定义函数（变量名）<br>        --- 参数至少一个，可以有多个，用逗号隔开<br><br>dirof =  <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(<span class="hljs-built_in">realpath</span> $(1)</span>)) <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> $(<span class="hljs-built_in">realpath</span> $(2)</span>))<br>result = <span class="hljs-variable">$(<span class="hljs-built_in">call</span> dirof,main.cpp,src/hello.cpp)</span><br></code></pre></td></tr></table></figure><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>对于不是立即展开的变量，可以查看变量的原始定义；对于立即展开的变量，直接返回变量值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">value</span> variable)</span><br><br>var = value function test<br>var2 = <span class="hljs-variable">$(var)</span><br>var3 := <span class="hljs-variable">$(var)</span><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var2)</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">value</span> var3)</span><br></code></pre></td></tr></table></figure><h2 id="origin"><a href="#origin" class="headerlink" title="origin"></a>origin</h2><p>查看一个变量定义来源</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">origin</span> variable)</span><br><br><br>var2 = origin function <br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> CC)</span>        <span class="hljs-comment"># default 默认变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> JAVA_HOME)</span> <span class="hljs-comment"># environment 环境变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> var2)</span>    <span class="hljs-comment"># file 在Makefile文件中定义的变量</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">origin</span> @)</span>        <span class="hljs-comment"># automatic 自动变量</span><br></code></pre></td></tr></table></figure><h2 id="flavor"><a href="#flavor" class="headerlink" title="flavor"></a>flavor</h2><p>查看一个变量的赋值方式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> variable)</span><br><br>var2 = flavor function<br>var3 := flavor funciton<br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var1)</span>    <span class="hljs-comment"># undefined 未定义</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var2)</span>    <span class="hljs-comment"># recursive 递归展开赋值</span><br>    @echo <span class="hljs-variable">$(<span class="hljs-built_in">flavor</span> var3)</span>    <span class="hljs-comment"># simple 简单赋值</span><br></code></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>可以将一段文本生成Makefile的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> text)</span><br><br><span class="hljs-keyword">define</span> eval_target = <br><span class="hljs-section">eval:</span><br>    @echo Target Eval Test<br><span class="hljs-keyword">endef</span><br><br><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> <span class="hljs-variable">$(eval_target)</span>)</span><br></code></pre></td></tr></table></figure><p>以上，运行make时将会执行eval目标</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>用于执行Shell命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">files = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> ls *.cpp)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo This is from <span class="hljs-built_in">shell</span> function)</span><br></code></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>将一个字符串序列中的项拆开放入多个变量中，并对各个变量进行操作（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(let var1 [var2 ...],[list],proc)</span><br>        --- var 变量，可以有多个，用空格隔开<br>        --- list 待处理字符串，各项之间空格隔开<br>        --- proc 对变量进行的操作，结果为let的返回值<br>            将list中的值依次一项一项放到var中，如果var的个数多于list项数，那多出来的var是空串。如果<br>            var的个数小于list项数，则先依次把前而的项放入var中，剩下的list所有项都放入最后一个var中<br><br><br>list = a b c d<br>letfirst = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(first)</span>)</span><br>letrest = <span class="hljs-variable">$(let first second rest,<span class="hljs-variable">$(list)</span>,<span class="hljs-variable">$(rest)</span>)</span><br><br><br><span class="hljs-comment"># 结合call可以对所有项进行递归处理</span><br>reverse = <span class="hljs-variable">$(let first rest,$(1)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(rest)</span>,$(<span class="hljs-built_in">call</span> reverse,<span class="hljs-variable">$(rest)</span>)</span> )<span class="hljs-variable">$(first)</span>)<br><span class="hljs-section">all: ; @echo $(call reverse,d c b a)</span><br></code></pre></td></tr></table></figure><h2 id="信息提示函数"><a href="#信息提示函数" class="headerlink" title="信息提示函数"></a>信息提示函数</h2><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>提示错误信息并终止make执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">error</span> text)</span><br>        --- text 提示信息<br><br>EXIT_STATUS = -1<br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> An <span class="hljs-built_in">error</span> occured! make stopped!)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h4><p>提示警告信息，make不会终止</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">warning</span> text)</span><br><br><span class="hljs-keyword">ifneq</span> (0, <span class="hljs-variable">$(EXIT_STATUS)</span>)<br>    <span class="hljs-variable">$(<span class="hljs-built_in">warning</span> This is a <span class="hljs-built_in">warning</span> message)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>输出一些信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(info text…)</span><br><br><span class="hljs-variable">$(info 编译开始.......)</span><br><span class="hljs-variable">$(info 编译结束)</span><br></code></pre></td></tr></table></figure><h1 id="同一项目中有多个Makefile文件"><a href="#同一项目中有多个Makefile文件" class="headerlink" title="同一项目中有多个Makefile文件"></a>同一项目中有多个Makefile文件</h1><h2 id="包含其他makefile文件"><a href="#包含其他makefile文件" class="headerlink" title="包含其他makefile文件"></a>包含其他makefile文件</h2><p>使用<code>include</code>指令可以读入其他makefile文件的内容，效果就如同在include的位置用对应的文件内容替换一样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> mkf1 mkf2 <span class="hljs-comment"># 可以引入多个文件，用空格隔开</span><br><span class="hljs-keyword">include</span> *.mk    <span class="hljs-comment"># 可以用通配符，表示引入所有以.mk结尾的文件</span><br></code></pre></td></tr></table></figure><p>如果找不到对应文件，则会报错，如果要忽略错误，可以在<code>include</code>前加<code>-</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">-include</span> mkf1 mkf2<br></code></pre></td></tr></table></figure><h4 id="应用实例：自动生成依赖"><a href="#应用实例：自动生成依赖" class="headerlink" title="应用实例：自动生成依赖"></a>应用实例：自动生成依赖</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = block.o command.o input.o main.o scene.o test.o<br><br><span class="hljs-section">sudoku: <span class="hljs-variable">$(objs)</span></span><br>    g++ <span class="hljs-variable">$(objs)</span> -o sudoku<br><br><span class="hljs-keyword">include</span> $(objs:%.o=%.d)<br><br><span class="hljs-section">%.d: %.cpp</span><br>    @-rm <span class="hljs-variable">$@</span><br>    <span class="hljs-variable">$(CXX)</span> -MM  <span class="hljs-variable">$&lt;</span> &gt; <span class="hljs-variable">$@</span>.temp<br>    @sed &#x27;s,\(<span class="hljs-variable">$*</span>\)\.o[ :]*,\1.o <span class="hljs-variable">$@</span> : ,g&#x27; &lt; <span class="hljs-variable">$@</span>.temp &gt; <span class="hljs-variable">$@</span><br>    @-rm <span class="hljs-variable">$@</span>.temp<br><br><br>%.o : %.cpp<br>    g++ -c <span class="hljs-variable">$&lt;</span><br>    @echo <span class="hljs-variable">$^</span><br></code></pre></td></tr></table></figure><h2 id="嵌套make"><a href="#嵌套make" class="headerlink" title="嵌套make"></a>嵌套make</h2><p>如果将一个大项目分为许多小项目，则可以使用嵌套（递归）使用make。具体做法为，写一个总的Makefile，然后在每个子项目中都写一个Makefile，在总Makefile中进行调用。</p><p>例如，可以把sudoku项目中除main.cpp，test.cpp外的其他cpp存为一个子项目，编译为一个库文件，main.cpp test.cpp为另一个子项目，编译为.o然后链接库文件成可执行文件：</p><p>库文件Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">vpath</span> %.h ../<span class="hljs-keyword">include</span><br><br>CXXFLAGS += -I../<span class="hljs-keyword">include</span> -fexec-charset=GBK -finput-charset=UTF-8<br><br>cpps := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cpp)</span><br>objs := $(cpps:%.cpp=%.o)<br><br><span class="hljs-section">libsudoku.a: <span class="hljs-variable">$(objs)</span></span><br>    ar rcs <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br><br><span class="hljs-variable">$(objs)</span>: %.o : %.cpp %.h<br></code></pre></td></tr></table></figure><p>main.cpp test.cpp的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CXXFLAGS += -I../<span class="hljs-keyword">include</span> -fexec-charset=GBK -finput-charset=UTF-8<br><span class="hljs-keyword">vpath</span> %.h ../<span class="hljs-keyword">include</span><br><span class="hljs-keyword">vpath</span> %.a ../lib<br><br><span class="hljs-section">../sudoku: main.o test.o -lsudoku</span><br>    <span class="hljs-variable">$(CXX)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span><br></code></pre></td></tr></table></figure><p>总的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all clean</span><br><br><span class="hljs-section">all: subsrc</span><br><br><span class="hljs-section">subsrc: sublib</span><br>    <span class="hljs-variable">$(MAKE)</span> -C src<br><br><span class="hljs-section">sublib:</span><br>    <span class="hljs-variable">$(MAKE)</span> -C lib<br><br><span class="hljs-section">clean:</span><br>    -rm *.exe src/*.o lib/*.o lib/*.a <br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(MAKE)</span> -C subdir<br></code></pre></td></tr></table></figure><p>这一指令会自动进入subdir文件夹然后执行make。</p><p>可以通过<code>export</code>指令向子项目的make传递变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> var  <span class="hljs-comment"># 传递var</span><br><span class="hljs-keyword">export</span>         <span class="hljs-comment"># 传递所有变量</span><br><span class="hljs-keyword">unexport</span>    <span class="hljs-comment"># 取消传递</span><br></code></pre></td></tr></table></figure><p>&amp;nbsp;</p><p>&amp;nbsp;</p><p>&amp;nbsp;</p><p>&amp;nbsp;</p><h1 id="后续学习过程"><a href="#后续学习过程" class="headerlink" title="后续学习过程"></a>后续学习过程</h1><p>读一些开源项目的Makefile</p><p><strong>redis</strong>:<a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p><p><strong>ffmpeg</strong>:<a href="https://github.com/FFmpeg/FFmpeg">https://github.com/FFmpeg/FFmpeg</a></p><p><strong>aubio</strong>:<a href="https://github.com/aubio/aubio">https://github.com/aubio/aubio</a></p><p><strong>libav</strong>:<a href="https://github.com/libav/libav">https://github.com/libav/libav</a></p><p><strong>OpenH264</strong>:<a href="https://github.com/cisco/openh264">https://github.com/cisco/openh264</a></p><p><strong>TinyVM</strong>:<a href="https://github.com/jakogut/tinyvm">https://github.com/jakogut/tinyvm</a></p><p><strong>TinyXML2</strong>:<a href="https://github.com/leethomason/tinyxml2">https://github.com/leethomason/tinyxml2</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nuttx</title>
    <link href="/2023/04/30/NuttX/"/>
    <url>/2023/04/30/NuttX/</url>
    
    <content type="html"><![CDATA[<h1 id="NuttX"><a href="#NuttX" class="headerlink" title="NuttX"></a>NuttX</h1><p><a href="https://nuttx.apache.org/docs/latest/quickstart/index.html">https://nuttx.apache.org/docs/latest/quickstart/index.html</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install \<br>bison flex gettext texinfo libncurses5-dev libncursesw5-dev xxd \<br>gperf automake libtool pkg-config build-essential gperf genromfs \<br>libgmp-dev libmpc-dev libmpfr-dev libisl-dev binutils-dev libelf-dev \<br>libexpat-dev gcc-multilib g++-multilib picocom u-boot-tools util-linux<br></code></pre></td></tr></table></figure><p>2.安装工具链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install gcc-arm-none-eabi binutils-arm-none-eabi<br></code></pre></td></tr></table></figure><p>3.安装KConfig</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Ubuntu20.04以上系统</span><br>apt install kconfig-frontends<br></code></pre></td></tr></table></figure><p>4.下载源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> nuttxspace<br><span class="hljs-built_in">cd</span> nuttxspace<br>git <span class="hljs-built_in">clone</span> https://github.com/apache/nuttx.git nuttx<br>git <span class="hljs-built_in">clone</span> https://github.com/apache/nuttx-apps apps<br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>1.初始化配置，列出所有支持的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> nuttx<br>./tools/configure.sh -L | less<br></code></pre></td></tr></table></figure><p>2.选择配置指明主机平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> nuttx<br>./tools/configure.sh -l stm32f4discovery:nsh<br></code></pre></td></tr></table></figure><p>3.使用菜单来自定义配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> nuttx<br>make menuconfig<br></code></pre></td></tr></table></figure><h3 id="构建Nuttx"><a href="#构建Nuttx" class="headerlink" title="构建Nuttx"></a>构建Nuttx</h3><p>1.构建</p><p>构建会在目录中生成二进制文件。通常包括NuttX ELF文件和一个<code>nuttx.bin</code>可以被烧录到板上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> nuttx<br>make<br></code></pre></td></tr></table></figure><p>加速构建可以使用<code>-jN</code>参数，多线程并行编译，<code>N</code>通常取决于电脑的处理器个数。（make -j8）</p><p>2.清理构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make clean<br></code></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><h3 id="连接NuttShell"><a href="#连接NuttShell" class="headerlink" title="连接NuttShell"></a>连接NuttShell</h3><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1.初始化模拟器配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./tools/configure.sh -l sim:nsh<br></code></pre></td></tr></table></figure><p>2.构建和运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">make clean<br><span class="hljs-comment">#make报错注意看报错信息，可能需要安装依赖，pip install pyelftools cxxfilt</span><br>make<br><span class="hljs-comment">#执行</span><br>./nuttx<br></code></pre></td></tr></table></figure><p>默认有用户名和密码：username&#x3D;admin, password&#x3D;Administrator</p><p>可以通过配置关闭，Application Configuration-&gt;NSH Library-&gt;Console Login</p><p>修改完配置需要重新make</p><p>3.关闭模拟器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#新建一个终端</span><br>pkill nuttx<br><br><span class="hljs-comment">#或者在nsh下执行poweroff</span><br></code></pre></td></tr></table></figure><p>可以使用<code>make menuconfig</code>修改配置重新make再执行。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h2 id="NuttX架构"><a href="#NuttX架构" class="headerlink" title="NuttX架构"></a>NuttX架构</h2><ul><li><p>NSH(nuttx shell)、各种app：实际的应用层，应用程序可以作为是我们在终端中运行的东西，或者可以看作是一个终端。</p></li><li><p>Virtual File System(虚拟文件系统)：虚拟文件系统，符合Linux系统的思想，这一层的主要作用是<strong>将设备的操作转化为对虚拟文件的操作</strong>。</p></li><li><p>Upper Half Drivers(上层驱动)：这些驱动可以看作为是对各种设备的操作接口的定义，比如PWM、Network等等。这一层也可以视作为系统的API。在这里你可以不需要管底层的实现，直接调用就可以了。</p></li><li><p>Lower Half Drivers(下层驱动)：这一层是上层驱动的具体化，在这里是每种芯片都有不一样的寄存器操作，这一层的驱动提供的API直接操作各种芯片，各种芯片的驱动在这里都是不相同的。</p></li><li><p>Microcontroller + Peripherals(外设)：这一层是各种硬件以及外设。位于<code>Nuttx/arch/*</code>。</p></li></ul><h2 id="NuttX目录结构"><a href="#NuttX目录结构" class="headerlink" title="NuttX目录结构"></a>NuttX目录结构</h2><p><a href="https://nuttx.apache.org/docs/latest/quickstart/organization.html">https://nuttx.apache.org/docs/latest/quickstart/organization.html</a></p><h3 id="nuttx-x2F-arch"><a href="#nuttx-x2F-arch" class="headerlink" title="nuttx&#x2F;arch"></a>nuttx&#x2F;arch</h3><p>该目录包含多个子目录，每个子目录包含特定于体系结构的逻辑。</p><h3 id="nuttx-x2F-binfmt"><a href="#nuttx-x2F-binfmt" class="headerlink" title="nuttx&#x2F;binfmt"></a>nuttx&#x2F;binfmt</h3><p>包含将文件系统中的二进制文件以可用于执行它们的形式加载到内存中的逻辑。</p><h3 id="nuttx-x2F-audio"><a href="#nuttx-x2F-audio" class="headerlink" title="nuttx&#x2F;audio"></a>nuttx&#x2F;audio</h3><p>包含nuttx音频子系统。</p><h3 id="nuttx-x2F-boards"><a href="#nuttx-x2F-boards" class="headerlink" title="nuttx&#x2F;boards"></a>nuttx&#x2F;boards</h3><p>包含电路板特定的配置文件。</p><p>其子目录结构为&#x2F;&lt;arch-name&gt;&#x2F;&lt;chip-name&gt;&#x2F;&lt;board-name&gt;</p><h3 id="nuttx-x2F-crypto"><a href="#nuttx-x2F-crypto" class="headerlink" title="nuttx&#x2F;crypto"></a>nuttx&#x2F;crypto</h3><p>包含nuttx加密子系统</p><h3 id="nuttx-x2F-drivers"><a href="#nuttx-x2F-drivers" class="headerlink" title="nuttx&#x2F;drivers"></a>nuttx&#x2F;drivers</h3><p>包含与体系结构无关的设备驱动程序</p><h3 id="nuttx-x2F-fs"><a href="#nuttx-x2F-fs" class="headerlink" title="nuttx&#x2F;fs"></a>nuttx&#x2F;fs</h3><p>包含nuttx的文件系统</p><h3 id="nuttx-x2F-graphics"><a href="#nuttx-x2F-graphics" class="headerlink" title="nuttx&#x2F;graphics"></a>nuttx&#x2F;graphics</h3><p>包含nuttx下的图形、视频支持</p><h3 id="nuttx-x2F-include"><a href="#nuttx-x2F-include" class="headerlink" title="nuttx&#x2F;include"></a>nuttx&#x2F;include</h3><p>包含nuttx头文件</p><h3 id="nuttx-x2F"><a href="#nuttx-x2F" class="headerlink" title="nuttx&#x2F;"></a>nuttx&#x2F;</h3><p>这是一个（几乎是）空的目录，它有一个存放生成的静态库的地方。NuttX构建系统在编译阶段会在这个目录中生成一系列静态库。这些库在最后的链接阶段被放在一个已知的地方，在那里它们被访问以生成最终的二进制文件。</p><h3 id="nuttx-x2F-libs-x2F-libc"><a href="#nuttx-x2F-libs-x2F-libc" class="headerlink" title="nuttx&#x2F;libs&#x2F;libc"></a>nuttx&#x2F;libs&#x2F;libc</h3><h3 id="nuttx-x2F-libs-x2F-libxx"><a href="#nuttx-x2F-libs-x2F-libxx" class="headerlink" title="nuttx&#x2F;libs&#x2F;libxx"></a>nuttx&#x2F;libs&#x2F;libxx</h3><p>包含一个微小的、最小的标准 C++，可用于在 NuttX 中构建一些简单的 C++ 应用程序。</p><h3 id="nuttx-x2F-mm"><a href="#nuttx-x2F-mm" class="headerlink" title="nuttx&#x2F;mm"></a>nuttx&#x2F;mm</h3><p>NuttX 内存管理器。</p><h3 id="nuttx-x2F-net"><a href="#nuttx-x2F-net" class="headerlink" title="nuttx&#x2F;net"></a>nuttx&#x2F;net</h3><p>含 NuttX 网络层的实现，包括内部套接字 API。</p><h3 id="nuttx-x2F-sched"><a href="#nuttx-x2F-sched" class="headerlink" title="nuttx&#x2F;sched"></a>nuttx&#x2F;sched</h3><p>构成 NuttX RTOS 核心的文件位于此处。</p><h3 id="nuttx-x2F-syscall"><a href="#nuttx-x2F-syscall" class="headerlink" title="nuttx&#x2F;syscall"></a>nuttx&#x2F;syscall</h3><p>如果 NuttX 构建为单独编译的内核（使用 <code>CONFIG_BUILD_PROTECTED=y</code>或<code>CONFIG_BUILD_KERNEL=y</code>），则构建该目录的内容。该目录包含一个系统调用接口，可用于用户模式应用程序和内核模式 RTOS 之间的通信。</p><h3 id="nuttx-x2F-tools"><a href="#nuttx-x2F-tools" class="headerlink" title="nuttx&#x2F;tools"></a>nuttx&#x2F;tools</h3><p>该目录包含一组工具和脚本，用于简化配置、构建和维护 NuttX。</p><h3 id="nuttx-x2F-wireless"><a href="#nuttx-x2F-wireless" class="headerlink" title="nuttx&#x2F;wireless"></a>nuttx&#x2F;wireless</h3><p>该目录包含对独立于硬件的无线支持。</p><h3 id="nuttx-x2F-Makefile"><a href="#nuttx-x2F-Makefile" class="headerlink" title="nuttx&#x2F;Makefile"></a>nuttx&#x2F;Makefile</h3><p>位于<code>$(TOPDIR)</code>目录的顶层<code>Makefile</code>包含构建nuttx的所有顶层控制逻辑。</p><h2 id="NSH应用程序"><a href="#NSH应用程序" class="headerlink" title="NSH应用程序"></a>NSH应用程序</h2><p>进入nuttxspace&#x2F;nuttx，执行<code>make menuconfig</code>进入配置</p><ol><li><p>配置：File Systems :arrow_right: ROMFS file system（开启此选项，默认开启）</p></li><li><p>到达：<code>Application Configuration → NSH Library → Scripting Support -&gt; Support ROMFS start-up script</code>，可以看到这个系统的默认启动脚本为<code>init.d/rc.sysinit</code>，可以通过这个地方进行修改，但是最好还是不要改了，避免有bug，可以进入系统的文件中修改（进入<code>/nuttxspace/nuttx/boards/sim/sim/sim/src/etc/init.d</code>，打开rcS文件，进行修改）</p></li></ol><p>NuttxShell是一个简单的Shell应用程序，支持各种命令，也可以自定义命令，可以添加新命令、更改初始化序列等，其shell语句具体实现在<code>/nuttxspace/apps/nshlib</code>（这个是它的库）</p><h3 id="内置应用程序"><a href="#内置应用程序" class="headerlink" title="内置应用程序"></a>内置应用程序</h3><blockquote><p>内置应用程序主要是支持从NSH命令行执行应用程序</p></blockquote><p>在<code>/apps/builtin</code>可以找到内置应用程序逻辑</p><ul><li>用来支持注册机制，以便内置应用程序可以在构建时动态注册自己</li><li>用于查找、列出和执行内置应用程序的实用函数</li></ul><p>内置应用程序逻辑导出的实用函数原型在 ：<code>nuttx/include/nuttx/lib/builtin.h</code>和<code>apps/include/builtin.h</code></p><ul><li><p><code>int builtin_isavail(FAR const char *appname);</code>在构建期间检查以appname注册的应用程序的可用性</p></li><li><p><code>const char *builtin_getname(int index);</code>返回指向应用程序名称的指针，可以在输入”nsh&gt; help”时列出可用的内置函数。</p></li><li><p><code>int exec_builtin(FAR const char *appname, FAR const char **argv);</code>执行在编译时注册的内置应用程序</p></li></ul><p><strong>自动生成头文件</strong></p><p>构建Nuttx时，应用程序入口被收集在两个文件中：</p><ul><li><code>apps/builtin/builtin_proto.h</code>:应用程序任务入口点的原型。</li><li><code>apps/builtin/builtin_list.h</code>:应用特定信息和启动要求。</li></ul><p><strong>内置程序的注册</strong></p><p>在执行不同的构建目标时，NuttX的构建分为几个阶段：</p><p>（1）建立配置时的上下文</p><p>（2）生成目标依赖时的依赖</p><p>（3）默认（全部）的内置程序当正常编译和链接操作时被执行</p><p>内置应用程序信息是在make context构建阶段收集的。</p><p>以<code>apps/examples/hello</code>目录为例，其主程序为<code>apps/example/hello/hello_main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, FAR <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个在NuttX构建上下文阶段注册的内置函数，由<code>apps/examples/hello/Makefile</code>执行注册逻辑。</p><p>构建系统的构建逻辑：</p><ol><li><p>顶级的上下文编译目标在nuttx&#x2F;Makefile中。所有构建目标都依赖于上下文构建目标。对于app&#x2F;目录，该构建目标将执行app&#x2F;Makefile中的上下文目标。</p></li><li><p>apps&#x2F;Makefile反过来会执行所有配置的子目录中的上下文目标。在我们的例子中，将包括apps&#x2F;examples中的Makefile。</p></li><li><p>最后，apps&#x2F;examples&#x2F;Makefile将在所有配置好的examples子目录中执行上下文目标。</p></li></ol><p>注意：由于上下文构建阶段只能执行一次，因此任何后续配置都不会反映在构建序列中。在实例化配置之前，需要先删除旧配置，最简单的方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make distclean<br></code></pre></td></tr></table></figure><p>但是这种方法需要重新配置NuttX，如果只想在<code>apps/</code>子目录中重新构建配置执行如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make apps_distclean<br></code></pre></td></tr></table></figure><p><code> apps/examples/hello/Makefile</code>会把hello_main()应用注册到<code>apps/builtin</code>里的<code>builtin_proto.h</code>和<code>builtin_list.h</code>文件中</p><h3 id="同步内置应用程序"><a href="#同步内置应用程序" class="headerlink" title="同步内置应用程序"></a>同步内置应用程序</h3><p>默认情况下，从NSH命令行启动的内置命令将与NSH异步运行。如果想强制执行命令然后等待命令执行可以在<code>/home/leiyongke/nuttxspace/nuttx/boards/sim/sim/sim/configs/nsh/defconfig</code>(以sim中的nsh为例)添加该配置：<code>CONFIG_SCHED_WAITPID=y</code>来启用该功能，启用后特定应用程序仍然可以通过在NSH命令后添加符号(&amp;)强制异步执行。</p><h2 id="自定义NSH初始化"><a href="#自定义NSH初始化" class="headerlink" title="自定义NSH初始化"></a>自定义NSH初始化</h2><p>三种方法自定义NSH启动行为，难度依次递增</p><ol><li>可以扩展<code>boards/arm/stm32/stm3240g-eval/src/stm32_appinit.c</code>中的初始化逻辑，每次启动NSH时都会调用该逻辑，特别是对任何与设备相关的初始化来说是个好地方。</li><li>你可以用你想要的启动逻辑替换<code>app/system/nsh/nsh_main.c中</code>的示例代码。apps&#x2F;system&#x2F;nsh只是一个很小的启动函数（CONFIG_INIT_ENTRYPOINT()）的例子，它可以立即运行并说明如何启动NSH，如果你想要其他东西立即运行，那么你可以写你自己的自定义CONFIG_INIT_ENTRYPOINT()函数，然后从你的自定义CONFIG_INIT_ENTRYPOINT()启动其他任务。(CONFIG_INIT_ENTRYPOINT在defconfig中配置)</li><li>NSH还支持在首次运行时执行一个启动脚本。这种机制的优点是启动脚本可以包含任何NSH命令，因此可以用很少的代码完成大量的工作。缺点是，创建启动脚本要复杂得多。</li></ol><h2 id="直接启动自己的应用程序而不是启动NSH"><a href="#直接启动自己的应用程序而不是启动NSH" class="headerlink" title="直接启动自己的应用程序而不是启动NSH"></a>直接启动自己的应用程序而不是启动NSH</h2><p>以”hello”为例，修改ENTRYPOINT调用”hello_main”而不是”nsh_main”</p><p>RTOS Features -&gt; Tasks and Scheduling -&gt; (hello_main) Application entry point</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/04/11/Linux/"/>
    <url>/2023/04/11/Linux/</url>
    
    <content type="html"><![CDATA[<p>Linux系统中一切皆文件</p><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><ul><li>&#x2F;bin（谨慎修改）<ul><li>binery，放常用命令</li></ul></li><li>&#x2F;boot（勿动）<ul><li>boot分区（引导分区）</li></ul></li><li>&#x2F;dev（勿动）<ul><li>device，设备目录</li></ul></li><li>&#x2F;etc（勿动）<ul><li>系统管理所需的配置文件</li></ul></li><li>&#x2F;home（随便动）<ul><li>普通用户的主目录</li></ul></li><li>&#x2F;lib（勿动）<ul><li>library（依赖），库文件，类似system32</li></ul></li><li>&#x2F;lib64（勿动）<ul><li>同样是依赖，类似system</li></ul></li><li>&#x2F;media（勿动）<ul><li>媒体目录（可移动设备挂载点），识别可移动媒体设备，如U盘、光驱等，将其挂在到此目录中</li></ul></li><li>&#x2F;mnt（勿动）<ul><li>mount，移动设备的另一个挂载点</li></ul></li><li>&#x2F;opt（随便动）<ul><li>optional（可选目录），给第三方软件包安装的位置</li></ul></li><li>&#x2F;proc（勿动）<ul><li>process（进程目录，一个虚拟目录），存放系统进程信息</li></ul></li><li>&#x2F;root（随便动）<ul><li>超级管理员的主目录</li></ul></li><li>&#x2F;run（勿动）<ul><li>运行目录，系统运行期间所有运行信息，重启就没了</li></ul></li><li>&#x2F;sbin（谨慎修改）</li><li>&#x2F;srv（勿动）<ul><li>service，系统服务相关信息</li></ul></li><li>&#x2F;sys（勿动）<ul><li>system，系统硬件信息的相关文件</li></ul></li><li>&#x2F;tmp（随便动）<ul><li>temp（临时目录），可动</li></ul></li><li>&#x2F;usr（勿动）</li><li>&#x2F;var（可以动）<ul><li>varible（可变目录），一般存放不断扩充会变化的文件，如日志</li></ul></li></ul><p>可以随意使用的目录<code>/root</code>,<code>/home</code>,<code>/opt</code>,<code>/tmp</code>,<code>/var</code></p><p>可能需要自行修改的目录<code>/bin</code>,<code>/etc</code></p><h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><p>文本编辑器</p><p>1.命令：<code>vim 目标文件</code>进入一般模式（主要操作：删除、复制、粘贴）</p><p>2.按<code>i</code>进入编辑模式，按<code>esc</code>退出编辑模式进入一般模式</p><p>3.输入<code>:</code>进入命令模式，<code>:w</code>保存，<code>:q</code>退出vim，<code>:wq</code>保存并退出，<code>u</code>撤销</p><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><p>常用语法</p><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>yy</td><td>复制光标当前1行</td></tr><tr><td>y数字y</td><td>复制一段（从光标当前行到后n行）</td></tr><tr><td>p</td><td>箭头移动到目的行粘贴</td></tr><tr><td>u</td><td>撤销上一步</td></tr><tr><td>dd</td><td>删除光标当前行</td></tr><tr><td>d数字d</td><td>删除光标（含）后多少行</td></tr><tr><td>x</td><td>剪切一个字符（当前光标），相当于del</td></tr><tr><td>X</td><td>剪切一个字符（当前光标的前一个），相当于backspace</td></tr><tr><td>yw</td><td>复制一个词</td></tr><tr><td>dw</td><td>删除一个词</td></tr><tr><td>shift+^</td><td>光标移动到行头</td></tr><tr><td>shift+$</td><td>光标移动到行尾</td></tr><tr><td>d + shift + ^</td><td>删除光标移动到行头</td></tr><tr><td>d+shift+$</td><td>删除光标移动到行尾</td></tr><tr><td>y+shift+^</td><td>复制光标移动到行头</td></tr><tr><td>y+shift+$</td><td>复制光标移动到行尾</td></tr><tr><td>b</td><td>光标移动到单词头</td></tr><tr><td>e</td><td>光标移动到单词尾</td></tr><tr><td>gg  或 shift + h</td><td>光标移动到文件头</td></tr><tr><td>G 或 L</td><td>光标移动到文件尾</td></tr></tbody></table><p><code>:set nu</code> 显示行号，<code>:set nonu</code>关闭行号显示</p><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><ol><li>进入编辑模式常用语法</li></ol><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>当前光标前</td></tr><tr><td>a</td><td>当前光标后</td></tr><tr><td>o</td><td>当前光标行的下一行</td></tr><tr><td>I</td><td>光标所在行最前</td></tr><tr><td>A</td><td>光标所在行最后</td></tr><tr><td>O</td><td>当前光标行的上一行</td></tr></tbody></table><ol start="2"><li>退出编辑模式</li></ol><p>按esc键</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>基本语法</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>:q!</td><td>不保存强制退出</td></tr><tr><td>&#x2F;要查找的词</td><td>n查找下一个，N往上查找</td></tr><tr><td>:noh</td><td>取消高亮显示</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>关闭行号</td></tr><tr><td>:s&#x2F;old&#x2F;new</td><td>光标所在行中的第一个”old”替换为”new”</td></tr><tr><td>:s&#x2F;old&#x2F;new&#x2F;g</td><td>光标所在行中所有”old”替换为”new”</td></tr><tr><td>:%s&#x2F;old&#x2F;new</td><td>将每行中的第一个”old”替换为”new”</td></tr><tr><td>:%s&#x2F;old&#x2F;new&#x2F;g</td><td>将所有”old”替换为”new”</td></tr></tbody></table><h1 id="网络配置和系统管理操作"><a href="#网络配置和系统管理操作" class="headerlink" title="网络配置和系统管理操作"></a>网络配置和系统管理操作</h1><p>VMware提供了三种网络连接模式：</p><p>桥接模式：</p><p>虚拟机直接连接外部物理网络的模式，主机起到了网桥的作用。这种模式下，虚拟机可以直接访问外部网络，并且对外部网络是可见的。</p><p>NAT模式：</p><p>虚拟机和主机构建一个专用网络，并通过虚拟网络地址转换（NAT）设备对IP进行转换。虚拟机通过共享主机IP可以访问外部网络，但外部网络无法访问虚拟机。</p><p>仅主机模式：</p><p>虚拟机只与主机共享一个专用网络，与外部网络无法通信。</p><h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>hostname（查看当前服务器的主机名称）</p><p>修改主机名<code>vi /etc/hostname</code>重启后生效</p><h1 id="service服务管理"><a href="#service服务管理" class="headerlink" title="service服务管理"></a>service服务管理</h1><p>基本语法</p><p>centos 6：</p><p><code>service 服务名 start | stop | restart | status</code></p><p>比如：service network status</p><p>centos7：（重要）</p><p><code>systemctl start | stop | restart | status 服务名</code></p><p>比如：systemctl status firewalld</p><p>在终端使用命令<code>setup</code>进入图形化界面配置开机自启动服务，有*号表示开机自启动，按空格(space)选中或取消选中，按<code>tab</code>跳转按钮</p><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>centos6运行级别：</p><p>Linux有7种运行级别(runlevel)：常用的是级别3和5</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆（类似windows安全模式）</li><li>运行级别2：多用户状态（没有NFS），不支持网络</li><li>运行级别3：完全的多用户状态（有NFS），登陆后进入控制台命令行模式。（常用）</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登录后进入图形GUI模式。（常用）</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。</li></ul><p>centos7运行级别进行了简化：</p><p>multi-user.target等价于原运行级别3（多用户有网，无图形界面）</p><p>graphical.target等价于原运行级别5（多用户有网，有图形界面）</p><p>查看系统默认运行级别：<code>systemct get-default</code></p><p>设置系统运行级别：system set-default graphical.target</p><p>查看所有自启动服务<code>systemctl list-unit-files</code></p><h1 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h1><p>基本语法：</p><ol><li><p>sync（功能描述：将数据由内存 同步到硬盘中）</p></li><li><p>halt       （功能描述：停机，关闭系统，但不断电）</p></li><li><p>poweroff  （功能描述：关机，停电）</p></li><li><p>reboot       （功能描述：就是重启，等同于shutdown -r now）</p></li><li><p>shutdown [选项] 时间</p></li></ol><p>关机指令：</p><p><code>shutdown</code>（默认1分钟后关机，可以使用命令<code>shutdown -c</code>取消）</p><p><code>shutdown now</code>立刻关机</p><p><code>shutdown 3</code>3分钟后关机</p><p><code>shutdown 15:28</code> 15时28分关机（定时关机）</p><h1 id="常用基本命令（重要）"><a href="#常用基本命令（重要）" class="headerlink" title="常用基本命令（重要）"></a>常用基本命令（重要）</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="1-man-manual-获得帮助信息"><a href="#1-man-manual-获得帮助信息" class="headerlink" title="1.man (manual)获得帮助信息"></a>1.man (manual)获得帮助信息</h3><p>基本语法：</p><p>man [命令或配置文件]（功能描述：获得帮助信息）</p><h3 id="2-help获得shell内置命令的帮助信息"><a href="#2-help获得shell内置命令的帮助信息" class="headerlink" title="2.help获得shell内置命令的帮助信息"></a>2.help获得shell内置命令的帮助信息</h3><p>​一部分基础功能的系统命令是直接内嵌在shell中的，系统加载启动之后会随着shell一起加载，常驻系统内存中。这部分命令被称为“内置(built-in)命令”；相应的其他命令被称为“外部命令”。</p><p>基本语法：help 命令（功能描述：获得shell内置命令的帮助信息）</p><p>查看cd命令的帮助信息：help cd</p><p>使用<code>type</code>命令查看命令类型</p><h3 id="3-常用快捷键"><a href="#3-常用快捷键" class="headerlink" title="3.常用快捷键"></a>3.常用快捷键</h3><p>ctrl + c：退出当前进程</p><p>ctrl + l：清屏</p><p>tab键：提示</p><p>上下键：查找执行过的命令</p><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><h3 id="1-pwd显示当前工作目录的绝对路径"><a href="#1-pwd显示当前工作目录的绝对路径" class="headerlink" title="1.pwd显示当前工作目录的绝对路径"></a>1.pwd显示当前工作目录的绝对路径</h3><p>pwd:print working directory 打印工作目录</p><h3 id="2-ls列出目录的内容"><a href="#2-ls列出目录的内容" class="headerlink" title="2.ls列出目录的内容"></a>2.ls列出目录的内容</h3><p>ls:list 列出目录内容</p><p>参数: </p><ul><li>-a 全部文件（包括隐藏文件，即以.开头的文件）</li><li>-l 长数据串列出，包含文件的属性与权限等等数据，等价于<code>ll</code>命令</li></ul><h3 id="3-cd切换目录"><a href="#3-cd切换目录" class="headerlink" title="3.cd切换目录"></a>3.cd切换目录</h3><p>cd:change directory</p><p>cd：进入当前用户的主目录</p><p>cd -：回到上一次所在的目录</p><h3 id="4-mkdir创建一个新的目录"><a href="#4-mkdir创建一个新的目录" class="headerlink" title="4.mkdir创建一个新的目录"></a>4.mkdir创建一个新的目录</h3><h3 id="5-rmdir删除一个空的目录"><a href="#5-rmdir删除一个空的目录" class="headerlink" title="5.rmdir删除一个空的目录"></a>5.rmdir删除一个空的目录</h3><h3 id="6-touch创建空文件"><a href="#6-touch创建空文件" class="headerlink" title="6.touch创建空文件"></a>6.touch创建空文件</h3><h3 id="7-cp复制文件或目录"><a href="#7-cp复制文件或目录" class="headerlink" title="7.cp复制文件或目录"></a>7.cp复制文件或目录</h3><h3 id="8-rm删除文件或目录"><a href="#8-rm删除文件或目录" class="headerlink" title="8.rm删除文件或目录"></a>8.rm删除文件或目录</h3><h3 id="9-mv移动文件与目录或重命名"><a href="#9-mv移动文件与目录或重命名" class="headerlink" title="9.mv移动文件与目录或重命名"></a>9.mv移动文件与目录或重命名</h3><h3 id="10-cat查看文件内容"><a href="#10-cat查看文件内容" class="headerlink" title="10.cat查看文件内容"></a>10.cat查看文件内容</h3><p>查看文件内容，从第一行开始显示</p><p>基本语法：cat [选项] 要查看的文件</p><p>cat -n a.txt</p><h3 id="11-more文件内容分屏查看器"><a href="#11-more文件内容分屏查看器" class="headerlink" title="11.more文件内容分屏查看器"></a>11.more文件内容分屏查看器</h3><p>基本语法：more 要查看的文件</p><p>操作说明：</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键（space）</td><td>代表向下翻一页</td></tr><tr><td>Enter</td><td>代表向下翻一行</td></tr><tr><td>q</td><td>代表立刻离开more，不再显示该文件内容</td></tr><tr><td>Ctrl + F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + B</td><td>返回上一屏</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><h3 id="12-less分屏显示文件内容"><a href="#12-less分屏显示文件内容" class="headerlink" title="12.less分屏显示文件内容"></a>12.less分屏显示文件内容</h3><p>less指令用来分屏查看文件内容，功能与more类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载的内容，对于显示大型文件具有较高的效率。</p><p>基本语法：less 要查看的文件</p><p>操作说明：</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻动一页</td></tr><tr><td>[pagedown]</td><td>向下翻动一页</td></tr><tr><td>[pageup]</td><td>向上翻动一页</td></tr><tr><td>&#x2F;字串</td><td>向下搜寻【字串】的功能；n：向下查找；N：向上查找</td></tr><tr><td>?字串</td><td>向上搜寻【字串】的功能；n：向上查找；N：向下查找</td></tr></tbody></table><h3 id="13-echo"><a href="#13-echo" class="headerlink" title="13.echo"></a>13.echo</h3><p>echo输出内容到控制台</p><p>基本语法：echo [选项] [输出内容]</p><p>选项：</p><p>-e：支持反斜线控制的字符转换</p><table><thead><tr><th>控制字符</th><th>作用</th></tr></thead><tbody><tr><td>\\</td><td>输出\本身</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr></tbody></table><p>输出所有系统环境变量：echo $ (按tab，不要按回车)</p><p>查看某个环境变量：echo $PATH</p><h3 id="14-head显示文件头部内容"><a href="#14-head显示文件头部内容" class="headerlink" title="14.head显示文件头部内容"></a>14.head显示文件头部内容</h3><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p><h3 id="15-tail输出文件尾部内容"><a href="#15-tail输出文件尾部内容" class="headerlink" title="15.tail输出文件尾部内容"></a>15.tail输出文件尾部内容</h3><p>tail用于显示文件尾部的内容，默认情况下tail指令显示文件的后10行内容</p><p>基本语法</p><ol><li>tail 文件</li><li>tail -n 5 文件          （功能描述：查看文件尾部5行内容，5可以是任意行数）</li><li>tail -f 文件               （功能描述：实时追踪该文档的所有更新，f即follow）</li></ol><p>ctrl + s暂停监听，ctrl+q继续监听</p><h3 id="16-gt-输出重定向和-gt-gt-追加"><a href="#16-gt-输出重定向和-gt-gt-追加" class="headerlink" title="16.&gt;输出重定向和&gt;&gt;追加"></a>16.&gt;输出重定向和&gt;&gt;追加</h3><p>基本语法：</p><ol><li>ls -l &gt; 文件（功能描述：列表的内容写入文件a.txt（覆盖写））</li><li>ls -al &gt;&gt; 文件               （功能描述：列表的内容追加到文件aa.txt的末尾）</li><li>cat 文件1 &gt; 文件2        （功能描述：将文件1的内容覆盖到文件2）</li><li>echo “内容” &gt;&gt; 文件     （功能描述：将“内容”追加到文件）</li></ol><p>echo $HOSTNAME &gt;&gt; info</p><h3 id="17-ln软连接"><a href="#17-ln软连接" class="headerlink" title="17.ln软连接"></a>17.ln软连接</h3><p>​软连接也称为符号链接，类似于windows里的快捷方式，有自己的数据块，主要存放了链接其他文件的路径</p><p>基本语法：ln -s [原文件或目录] [软链接名]      （功能描述：给原文件创建一个软连接）</p><p><strong>不使用-s参数是创建硬链接！！！</strong></p><p>经验技巧：</p><p>删除软链接：<code>rm -rf 软链接名</code>，而不是<code>rm -rf 软链接名/</code>，如果使用<code>rm -rf 软链接名/</code>删除，会把软链接对应的真实目录下内容删掉。</p><h3 id="18-history查看已经执行过的历史命令"><a href="#18-history查看已经执行过的历史命令" class="headerlink" title="18.history查看已经执行过的历史命令"></a>18.history查看已经执行过的历史命令</h3><p>history显示输入过的命令</p><p>使用<code>![执行history命令后显示的对应命令的行数]</code>可以执行历史命令</p><p>history -c 清理历史记录</p><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><h3 id="1-date显示当前时间"><a href="#1-date显示当前时间" class="headerlink" title="1.date显示当前时间"></a>1.date显示当前时间</h3><ol><li>date（功能描述：显示当前时间）</li><li>date +%Y         （功能描述：显示当前年份）</li><li>date +%m         （功能描述：显示当前月份）</li><li>date +%d         （功能描述：显示当前是哪一天）</li><li>date +”%Y-%m-%d %H:%M:%S”         （功能描述：显示年月日时分秒）</li></ol><p>%s表示时间戳</p><p>需要把+写上</p><h3 id="2-date显示非当前时间"><a href="#2-date显示非当前时间" class="headerlink" title="2.date显示非当前时间"></a>2.date显示非当前时间</h3><h3 id="3-date设置系统时间"><a href="#3-date设置系统时间" class="headerlink" title="3.date设置系统时间"></a>3.date设置系统时间</h3><h3 id="4-cal查看日历"><a href="#4-cal查看日历" class="headerlink" title="4.cal查看日历"></a>4.cal查看日历</h3><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="1-useradd添加新用户"><a href="#1-useradd添加新用户" class="headerlink" title="1.useradd添加新用户"></a>1.useradd添加新用户</h3><p>基本语法：</p><p><code>useradd 用户名</code>                        （功能描述：添加新用户）</p><p><code>useradd -g 组名 用户名</code>（功能描述：添加新用户到某个组）</p><h3 id="2-passwd设置用户密码"><a href="#2-passwd设置用户密码" class="headerlink" title="2.passwd设置用户密码"></a>2.passwd设置用户密码</h3><h3 id="3-id查看用户是否存在"><a href="#3-id查看用户是否存在" class="headerlink" title="3.id查看用户是否存在"></a>3.id查看用户是否存在</h3><p><code>id czh</code></p><h3 id="4-cat-x2F-etc-x2F-passwd-查看创建了哪些用户"><a href="#4-cat-x2F-etc-x2F-passwd-查看创建了哪些用户" class="headerlink" title="4.cat &#x2F;etc&#x2F;passwd 查看创建了哪些用户"></a>4.cat &#x2F;etc&#x2F;passwd 查看创建了哪些用户</h3><h3 id="5-su切换用户"><a href="#5-su切换用户" class="headerlink" title="5.su切换用户"></a>5.su切换用户</h3><h3 id="6-userdel删除用户"><a href="#6-userdel删除用户" class="headerlink" title="6.userdel删除用户"></a>6.userdel删除用户</h3><p><code>userdel czh</code>会删除掉此用户，但不会删除此用户的主目录，如果要删除则需要另外删除<code>rm -rf czh</code></p><p>如果要删除此用户及其主目录，则加上参数-r</p><h3 id="7-who查看登录用户信息"><a href="#7-who查看登录用户信息" class="headerlink" title="7.who查看登录用户信息"></a>7.who查看登录用户信息</h3><p><code>who am i</code>查看最外层用户名（在使用su切换用户后相当于会话间的嵌套）</p><p><code>whoami</code>查看当前会话的用户名</p><h3 id="8-sudo设置普通用户具有root权限"><a href="#8-sudo设置普通用户具有root权限" class="headerlink" title="8.sudo设置普通用户具有root权限"></a>8.sudo设置普通用户具有root权限</h3><p>若普通用户想要查看&#x2F;root目录中的文件则使用命令<code>sudo ls</code>，然后输入当前用户的密码。</p><p>但是前提是root用户在&#x2F;etc&#x2F;sudoers文件中赋予了当前用户权限。</p><p><code>vim /etc/sudoers</code></p><p>修改&#x2F;etc&#x2F;sudoers文件，在root下面添加一行</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">root<span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>)<span class="hljs-keyword">ALL</span><br>czh<span class="hljs-keyword">ALL</span>=<span class="hljs-keyword">ALL</span><span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>或者配置成采用sudo命令时，不需要输入密码</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">root<span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>)<span class="hljs-keyword">ALL</span><br>czh<span class="hljs-keyword">ALL</span>=<span class="hljs-keyword">ALL</span>NOPASSWD:<span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><h3 id="9-usermod修改用户"><a href="#9-usermod修改用户" class="headerlink" title="9.usermod修改用户"></a>9.usermod修改用户</h3><p>基本语法</p><p>usermod -g 用户组 用户名</p><h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><h3 id="1-groupadd新增组"><a href="#1-groupadd新增组" class="headerlink" title="1.groupadd新增组"></a>1.groupadd新增组</h3><h3 id="2-groupdel删除组"><a href="#2-groupdel删除组" class="headerlink" title="2.groupdel删除组"></a>2.groupdel删除组</h3><h3 id="3-groupmod修改组"><a href="#3-groupmod修改组" class="headerlink" title="3.groupmod修改组"></a>3.groupmod修改组</h3><h3 id="4-cat-x2F-etc-x2F-group查看创建了哪些组"><a href="#4-cat-x2F-etc-x2F-group查看创建了哪些组" class="headerlink" title="4.cat &#x2F;etc&#x2F;group查看创建了哪些组"></a>4.cat &#x2F;etc&#x2F;group查看创建了哪些组</h3><h2 id="文件权限类"><a href="#文件权限类" class="headerlink" title="文件权限类"></a>文件权限类</h2><h3 id="1-文件属性"><a href="#1-文件属性" class="headerlink" title="1.文件属性"></a>1.文件属性</h3><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l 命令来显示一个文件的属性以及文件所属的用户和组。</p><p>从左到右10个字符表示：</p><table><thead><tr><th>文件类型</th><th>←</th><th align="left">属主权限（u）</th><th>→</th><th>←</th><th>属组权限（g）</th><th>→</th><th>←</th><th>其他用户权限（o）</th><th>→</th></tr></thead><tbody><tr><td>0</td><td>1</td><td align="left">2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>d</td><td>r</td><td align="left">w</td><td>x</td><td>r</td><td>-</td><td>x</td><td>r</td><td>-</td><td>x</td></tr><tr><td>文件目录</td><td>读</td><td align="left">写</td><td>执行</td><td>读</td><td>写</td><td>执行</td><td>读</td><td>写</td><td>执行</td></tr></tbody></table><p>文件类型：</p><ul><li>-：文件</li><li>d：目录</li><li>c：字符设备文件（如键盘）</li><li>b：块设备文件（如硬盘）</li></ul><p>属主权限（u）：创建者（该文件的所有者）拥有的权限</p><p>属组权限（g）：文件所属的组用户（所有者的同组用户）拥有的权限</p><p>其他用户权限（o）：其他用户的权限</p><h4 id="rwx作用文件和目录的不同解释"><a href="#rwx作用文件和目录的不同解释" class="headerlink" title="rwx作用文件和目录的不同解释"></a>rwx作用文件和目录的不同解释</h4><p>（1）作用到文件：</p><ul><li>r：代表可读：可以读取，查看</li><li>w：代表可写：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li><li>x：代表可执行：可以被系统执行</li></ul><p>（2）作用到目录：</p><ul><li>r：代表可读：可以读取，ls查看目录内容</li><li>w：代表可写：可以修改，目录内创建+删除+重命名目录</li><li>x：代表可执行：可以进入该目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rw-------. 1 root root 1837 10月  2 17:27 anaconda-ks.cfg<br>-rw-r--r--. 1 root root 1885 10月  2 17:28 initial-setup-ks.cfg<br>drwxr-xr-x. 2 root root   34 10月  7 17:06 test<br>drwxr-xr-x. 2 root root    6 10月  2 17:29 公共<br>drwxr-xr-x. 2 root root    6 10月  2 17:29 模板<br>drwxr-xr-x. 2 root root    6 10月  2 17:29 视频<br>drwxr-xr-x. 2 root root    6 10月  2 17:29 图片<br>drwxr-xr-x. 2 root root    6 10月  2 17:29 文档<br>drwxr-xr-x. 2 root root    6 10月  2 17:29 下载<br>drwxr-xr-x. 2 root root    6 10月  2 17:29 音乐<br>drwxr-xr-x. 2 root root    6 10月  7 17:05 桌面<br></code></pre></td></tr></table></figure><p>权限后的数字表示<strong>链接数</strong>：</p><ul><li>如果查看的是文件：链接数指的是硬链接个数</li><li>如果查看的是文件夹：链接数指的是子文件夹个数</li></ul><p>第一个root表示属主，第二个root表示属组，之后的数字表示文件大小。 </p><h3 id="2-chmod改变权限"><a href="#2-chmod改变权限" class="headerlink" title="2.chmod改变权限"></a>2.chmod改变权限</h3><p>第一种方式变更权限：</p><p>chmod [{ugoa} {+-&#x3D;} {rwx}] 目录或文件，<code>chmod g=rw</code>，<code>chmod g+r</code></p><p>+表示增加哪个权限，-表示减少哪个权限</p><p>第二种方式变更权限：</p><p>chmod [mode&#x3D;421] [文件或目录]</p><p>r&#x3D;4, w&#x3D;2, x&#x3D;1</p><p>如果修改目录权限希望该目录下所有文件或文件夹都有相同权限，则使用参数-R</p><h3 id="3-chown改变所有者"><a href="#3-chown改变所有者" class="headerlink" title="3.chown改变所有者"></a>3.chown改变所有者</h3><p>基本语法：chown [选项] [最终用户] [文件或目录]（功能描述：改变文件或者目录的所有者）</p><h3 id="4-chgrp改变所属组"><a href="#4-chgrp改变所属组" class="headerlink" title="4.chgrp改变所属组"></a>4.chgrp改变所属组</h3><h2 id="搜索查找类（常用）"><a href="#搜索查找类（常用）" class="headerlink" title="搜索查找类（常用）"></a>搜索查找类（常用）</h2><h3 id="1-find查找文件或者目录"><a href="#1-find查找文件或者目录" class="headerlink" title="1.find查找文件或者目录"></a>1.find查找文件或者目录</h3><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端</p><p>基本语法：find [搜索范围] [选项]</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件，单位为：b-块（512字节），c-字节，w-字（2字节），k-千字节，M-兆字节，G-G字节</td></tr></tbody></table><p>示例：<code>find /root -name &quot;*.cfg&quot;</code>,<code>find /root -size +10M</code>（大于等于10M）</p><h3 id="2-locate快速定位文件路径"><a href="#2-locate快速定位文件路径" class="headerlink" title="2.locate快速定位文件路径"></a>2.locate快速定位文件路径</h3><p>locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确性，管理员必须定期更新locate时刻</p><p>基本语法：locate 搜索文件</p><p>经验技巧：由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。</p><p>案例实操：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@study ~]<span class="hljs-comment"># updatedb</span><br>[root@study ~]<span class="hljs-comment"># locate tmp</span><br></code></pre></td></tr></table></figure><p>查找命令在哪<code>which ls</code>，<code>whereis ls</code></p><h3 id="3-grep过滤查找及“-”管道符"><a href="#3-grep过滤查找及“-”管道符" class="headerlink" title="3.grep过滤查找及“|”管道符"></a>3.grep过滤查找及“|”管道符</h3><p>管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理</p><p>基本语法：grep 选项 查找内容 源文件</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr></tbody></table><p>查找某文件在第几行</p><p><code>ls|grep -n test</code></p><p>查找boot在initial-setup-ks.cfg中第几行</p><p><code>grep -n boot initial-setup-ks.cfg</code></p><p><code>grep -n boot initial-setup-ks.cfg | wc</code>(wc:word count，输出结果为： 几行出现 总个数  总字节大小)</p><h2 id="压缩解压类"><a href="#压缩解压类" class="headerlink" title="压缩解压类"></a>压缩解压类</h2><h3 id="1-gzip-x2F-gunzip压缩"><a href="#1-gzip-x2F-gunzip压缩" class="headerlink" title="1.gzip&#x2F;gunzip压缩"></a>1.gzip&#x2F;gunzip压缩</h3><p>基本语法：</p><p>gzip 文件（功能描述：压缩文件，只能将文件压缩为*.gz文件）</p><p>gunzip 文件.gz（功能描述：解压文件命令）</p><p>经验技巧：</p><ol><li>只能压缩文件，不能压缩目录</li><li>不会保留原来的文件</li><li>同时多个文件会产生多个压缩包</li></ol><h3 id="2-zip-x2F-unzip压缩"><a href="#2-zip-x2F-unzip压缩" class="headerlink" title="2.zip&#x2F;unzip压缩"></a>2.zip&#x2F;unzip压缩</h3><p>基本语法：</p><p>zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）</p><p>unzip [选项] XXX.zip （功能描述：解压缩文件）</p><p>选项说明：</p><table><thead><tr><th>zip选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>压缩目录</td></tr></tbody></table><table><thead><tr><th>unzip选项</th><th>功能</th></tr></thead><tbody><tr><td>-d&lt;目录&gt;</td><td>指定解压后文件存放的目录</td></tr></tbody></table><p>经验技巧：</p><p>zip压缩命令在windows&#x2F;linux都通用，可以压缩目录且保留源文件</p><p><code>zip -r myroot.zip /root</code></p><p><code>unzip -d /tmp myroot.zip</code></p><h3 id="3-tar打包"><a href="#3-tar打包" class="headerlink" title="3.tar打包"></a>3.tar打包</h3><p>基本语法：</p><p>tar [选项] XXXX.tar.gz 将要打包进去的内容（功能描述：打包目录，压缩后的文件格式.tar.gz）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr><tr><td>-C</td><td>解压到指定目录</td></tr></tbody></table><p>打包</p><p><code>tar -zcvf test.tar.gz test.txt</code></p><p>解包</p><p><code>tar -zxvf test.tar.gz -C /tmp</code></p><h2 id="磁盘查看和分区类"><a href="#磁盘查看和分区类" class="headerlink" title="磁盘查看和分区类"></a>磁盘查看和分区类</h2><h3 id="1-du查看文件和目录占用的磁盘空间"><a href="#1-du查看文件和目录占用的磁盘空间" class="headerlink" title="1.du查看文件和目录占用的磁盘空间"></a>1.du查看文件和目录占用的磁盘空间</h3><p>du即disk usage 磁盘占用情况</p><p>基本语法：<code>du 目录/文件</code>（功能描述：显示目录下每个子目录的磁盘使用情况）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-h</td><td>以人们较易阅读的GBytes，MBytes，KBytes等格式自行显示</td></tr><tr><td>-a</td><td>不仅查看子目录大小，还要包括文件</td></tr><tr><td>-c</td><td>显示所有的文件和子目录大小后，显示总和</td></tr><tr><td>-s</td><td>只显示总和</td></tr><tr><td>–max-depth&#x3D;n</td><td>指定统计子目录的深度为第n层</td></tr></tbody></table><p>案例实操：</p><p>查看当前用户主目录占用的磁盘空间大小：<code>du -sh</code></p><p>只显示当前一级目录子目录及子文件的大小：<code>du --max-depth=1 -ah</code></p><h3 id="2-df查看磁盘空间使用情况"><a href="#2-df查看磁盘空间使用情况" class="headerlink" title="2.df查看磁盘空间使用情况"></a>2.df查看磁盘空间使用情况</h3><p>df即disk free 空余磁盘</p><p>基本语法：<code>df 选项</code>（功能描述：列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-h</td><td>以人们较易阅读的GBytes，MBytes，KBytes等格式自行显示</td></tr></tbody></table><p>案例实操：</p><p>查看磁盘使用情况：<code>df -h</code></p><p>使用<code>free</code>命令查看物理内存和虚拟内存使用情况：<code>free -h</code></p><h3 id="3-lsblk查看设备挂载情况"><a href="#3-lsblk查看设备挂载情况" class="headerlink" title="3.lsblk查看设备挂载情况"></a>3.lsblk查看设备挂载情况</h3><p>lsblk即list block （功能描述：查看设备挂载情况）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>查看详细的设备挂载情况，显示文件系统信息</td></tr></tbody></table><h3 id="4-mount-x2F-umount-挂载-x2F-卸载"><a href="#4-mount-x2F-umount-挂载-x2F-卸载" class="headerlink" title="4.mount&#x2F;umount 挂载&#x2F;卸载"></a>4.mount&#x2F;umount 挂载&#x2F;卸载</h3><p>对于Linux用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根目录、一个独立且唯一的文件结构。</p><p>Linux中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，要载入的那个分区将使它的存储空间在这个目录下获得。</p><p>基本语法：</p><p><code>mount [-t vfstype] [-o options] device dir</code>（功能描述：挂载设备）</p><p><code>umount 设备文件名或挂载点</code>（功能描述：卸载设备）</p><p>参数说明：</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-t vfstype</td><td>指定文件系统的类型，通常不必指定。mount会自动选择正确的类型。常用类型有：<br>光盘或光盘镜像：iso9660<br />DOS fat16文件系统：msdos<br />Windows 9x fat32 文件系统：vfat<br />Windows NT ntfs 文件系统：ntfs<br />Mount Windows文件网络共享：smbfs<br />UNIX(LINUX) 文件网络共享：nfs</td></tr><tr><td>-o options</td><td>主要用来描述设备或归档的挂接方式。常用参数有：<br />loop：用来把一个文件当成硬盘分区挂接上系统<br />ro：采用只读方式挂接设备<br />rw：采用读写方式挂接设备<br />iocharset：指定访问文件系统所用字符集</td></tr><tr><td>device</td><td>要挂接(mount)的设备</td></tr><tr><td>dir</td><td>设备在系统上的挂载点(mount point)</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /mnt/cdrom<br>mount /dev/cdrom /mnt/cdrom/<br>umount /dev/cdrom<br></code></pre></td></tr></table></figure><h3 id="5-fdisk分区"><a href="#5-fdisk分区" class="headerlink" title="5.fdisk分区"></a>5.fdisk分区</h3><p>基本语法：</p><p><code>fdisk -l</code>（功能描述：查看磁盘分区详情）</p><p><code>fdisk 硬盘设备名</code>（功能描述：对新增硬盘进行分区操作）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-l</td><td>显示所有硬盘的分区列表</td></tr></tbody></table><p>经验技巧：该命令必须在root用户下才能使用</p><p>添加硬盘后先使用<code>fdisk</code>进行分区，再使用<code>mkfs</code>命令进行格式化设置文件系统</p><p><code>mkfs -t xfs /dev/sdb1</code></p><p><code>mount /dev/sdb1 /home/czh/</code>（进行挂载）</p><h2 id="进程管理类（重要）"><a href="#进程管理类（重要）" class="headerlink" title="进程管理类（重要）"></a>进程管理类（重要）</h2><p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源</p><h3 id="1-ps查看当前系统进程状态"><a href="#1-ps查看当前系统进程状态" class="headerlink" title="1.ps查看当前系统进程状态"></a>1.ps查看当前系统进程状态</h3><p>ps即process status进程状态</p><p>基本语法：</p><p><code>ps aux | grep xxx</code>（功能描述：查看系统中所有进程）</p><p><code>ps -ef | grep xxx</code>（功能描述：可以查看子父进程之间的关系）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>列出带有终端的所有用户的进程</td></tr><tr><td>x</td><td>列出当前用户的所有进程，包括没有终端的进程</td></tr><tr><td>u</td><td>面向用户友好的显示风格</td></tr><tr><td>-e</td><td>列出所有进程</td></tr><tr><td>-u</td><td>列出某个用户关联的所有进程</td></tr><tr><td>-f</td><td>显示完整格式的进程列表</td></tr></tbody></table><p>（不带-的选项是UNIX风格，带-的选项是BSD风格）</p><p>功能说明：</p><p>ps aux显示信息说明</p><p>USER：该进程是由哪个用户产生的</p><p>PID：进程的ID号</p><p>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；</p><p>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</p><p>VSZ：该进程占用虚拟内存的大小，单位KB；</p><p>RSS：该进程占用实际物理内存的大小，单位KB；</p><p>TTY：该进程是在哪个终端中运行的。对于CentOS来说，tty1是图形化终端，tty2-tty6是本地的字符界面终端。pts&#x2F;0-255代表虚拟终端。?表示后台</p><p>STAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示</p><p>START：该进程的启动时间</p><p>TIME：该进程占用CPU的运算时间，注意不是系统时间</p><p>COMMAND：产生此进程的命令名</p><p>经验技巧：</p><p>如果想查看进程的CPU占用率和内存占用率，可以使用aux，</p><p>如果想查看进程的父进程ID可以使用 -ef</p><h3 id="2-kill终止进程"><a href="#2-kill终止进程" class="headerlink" title="2.kill终止进程"></a>2.kill终止进程</h3><p>基本语法：</p><p><code>kill [选项] 进程号</code>（功能描述：通过进程号杀死进程）</p><p><code>killall 进程名称</code>（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）（谨慎使用）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-9</td><td>表示强迫进程立即停止</td></tr></tbody></table><h3 id="3-pstree查看进程树"><a href="#3-pstree查看进程树" class="headerlink" title="3.pstree查看进程树"></a>3.pstree查看进程树</h3><p>基本语法：</p><p><code>pstree [选项]</code></p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>显示进程的PID</td></tr><tr><td>-u</td><td>显示进程的所属用户</td></tr></tbody></table><h3 id="4-top实时监控系统进程状态"><a href="#4-top实时监控系统进程状态" class="headerlink" title="4.top实时监控系统进程状态"></a>4.top实时监控系统进程状态</h3><p>基本命令：</p><p><code>top [选项]</code></p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令</td></tr><tr><td>-i</td><td>使top不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控进程ID来仅仅监控某个进程的状态</td></tr></tbody></table><p>操作说明：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P（大写）</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr><tr><td>u</td><td>显示某个用户的进程</td></tr><tr><td>k</td><td>杀死某个进程</td></tr></tbody></table><h3 id="5-netstat显示网络统计信息和端口占用信息"><a href="#5-netstat显示网络统计信息和端口占用信息" class="headerlink" title="5.netstat显示网络统计信息和端口占用信息"></a>5.netstat显示网络统计信息和端口占用信息</h3><p>基本语法：</p><p><code>netstat -anp | grep 进程号</code>  （功能描述：查看该进程网络信息）</p><p><code>netstat -nlp | grep 端口号</code>（功能描述：查看网络端口号占用情况）</p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示所有正在监听（listen）和未监听的套接字（socket）</td></tr><tr><td>-n</td><td>拒绝显示别名，能显示数字的全部转化为数字</td></tr><tr><td>-l</td><td>仅列出在监听的服务状态</td></tr><tr><td>-p</td><td>表示显示哪个进程在调用</td></tr></tbody></table><p>案例实操：</p><p>通过进程号查看sshd进程的网络信息：<code>netstat -anp | grep sshd</code></p><h2 id="crontab系统定时任务"><a href="#crontab系统定时任务" class="headerlink" title="crontab系统定时任务"></a>crontab系统定时任务</h2><h3 id="1-crontab服务管理"><a href="#1-crontab服务管理" class="headerlink" title="1.crontab服务管理"></a>1.crontab服务管理</h3><p>重新启动crond服务</p><p><code>systemctl restart crond</code></p><h3 id="2-crontab定时任务设置"><a href="#2-crontab定时任务设置" class="headerlink" title="2.crontab定时任务设置"></a>2.crontab定时任务设置</h3><p>基本语法：</p><p><code>crontab [选项]</code></p><p>选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>编辑crontab定时任务</td></tr><tr><td>-l</td><td>查询crontab任务</td></tr><tr><td>-r</td><td>删除当前用户所有的crontab任务</td></tr></tbody></table><p>（1）参数说明</p><p>使用<code>crontab -e</code>命令进入crontab编辑界面，会打开vim编辑你的工作。</p><p>* * * * *执行的任务</p><table><thead><tr><th align="left">项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td align="left">第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td align="left">第二个“*”</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td align="left">第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td align="left">第四个“*”</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td align="left">第五个“*”</td><td>一周当中的星期几</td><td>0-7（0和7都代表周日）</td></tr></tbody></table><p>（2）特殊符号</p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任何时间。比如第一个*就代表一小时中每分钟都执行一次的意思</td></tr><tr><td>,</td><td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td></tr><tr><td>-</td><td>代表连续的时间范围。比如“0 5 * * 1-6”，代表在周一到周六的凌晨5点0分执行命令。</td></tr><tr><td>*&#x2F;n</td><td>代表每隔多久执行一次。比如“*&#x2F;10 * * * * 命令”代表每隔10分钟就执行一遍命令。</td></tr></tbody></table><p>（3）特定时间执行命令</p><table><thead><tr><th>时间</th><th>含义</th></tr></thead><tbody><tr><td>45 22 * * * 命令</td><td>每天22点45分执行命令</td></tr><tr><td>0 17 * * 1 命令</td><td>每周一的17点0分执行命令</td></tr><tr><td>0 5 1,15 * * 命令</td><td>每月1号和15号的凌晨5点0分执行命令</td></tr><tr><td>*&#x2F;10 4 * * * 命令</td><td>每天凌晨4点，每隔10分钟执行一次命令</td></tr><tr><td>0 0 1,15 * 1 命令</td><td>每月1号和15号，每周1的0点0分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们的定义都是天，非常容易让管理员混乱。</td></tr></tbody></table><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="1-RPM"><a href="#1-RPM" class="headerlink" title="1.RPM"></a>1.RPM</h3><h4 id="RPM概述"><a href="#RPM概述" class="headerlink" title="RPM概述"></a>RPM概述</h4><p>RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe，是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p><p>RPM包的格式名称</p><p>Apache-1.3.23-11.i386.rpm</p><ul><li>“apache”软件名称</li><li>“1.3.23-11”软件的版本号，主版本和此版本</li><li>“i386”是软件所运行的硬件平台，Intel32位处理器的统称</li><li>“rpm”文件扩展名，代表rpm包</li></ul><h4 id="RPM查询命令（rpm-qa）"><a href="#RPM查询命令（rpm-qa）" class="headerlink" title="RPM查询命令（rpm -qa）"></a>RPM查询命令（rpm -qa）</h4><p>基本语法</p><p><code>rpm -qa</code>（功能描述：查询所安装的所有rpm软件包）</p><p>rpm -qa | grep firefox</p><p>rpm -qi firefox</p><h4 id="RPM卸载命令（rpm-e）"><a href="#RPM卸载命令（rpm-e）" class="headerlink" title="RPM卸载命令（rpm -e）"></a>RPM卸载命令（rpm -e）</h4><p>基本语法：</p><p><code>rpm -e RPM软件包</code></p><p><code>rpm -e --nodeps</code></p><p>选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>卸载软件包</td></tr><tr><td>-nodeps</td><td>卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能不能正常工作</td></tr></tbody></table><h4 id="RPM安装命令（rpm-ivh）"><a href="#RPM安装命令（rpm-ivh）" class="headerlink" title="RPM安装命令（rpm -ivh）"></a>RPM安装命令（rpm -ivh）</h4><p>基本语法：</p><p><code>rpm -ivh RPM包全名</code></p><p>选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-i</td><td>install，安装</td></tr><tr><td>-v</td><td>–verbose，显示详细信息</td></tr><tr><td>-h</td><td>–hash，进度条</td></tr><tr><td>–nodeps</td><td>安装前不检查依赖</td></tr></tbody></table><p>rpm的问题：1.安装软件必须指定<strong>全名</strong>。2.依赖关系：例如软件A依赖b和c，如果系统中没有b或c，则安装过程报错。</p><p>（yum可以全自动化自动处理软件依赖，一键安装）</p><h3 id="2-YUM"><a href="#2-YUM" class="headerlink" title="2.YUM"></a>2.YUM</h3><h4 id="YUM概叙"><a href="#YUM概叙" class="headerlink" title="YUM概叙"></a>YUM概叙</h4><p>YUM（全称为Yellow dog Updater，Modified）是一个在Fedora和RedHat以及CentOS中的shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，<font style="color:red">可以自动处理依赖性关系</font>，并且一次安装所有依赖的软件包，无需频繁地一次次下载、安装。</p><h4 id="YUM的常用命令"><a href="#YUM的常用命令" class="headerlink" title="YUM的常用命令"></a>YUM的常用命令</h4><p>基本语法：</p><p><code>yum [选项] [参数]</code></p><p>选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-y</td><td>对所有提问都回答“yes”</td></tr></tbody></table><p>参数说明</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>install（重要）</td><td>安装rpm软件包</td></tr><tr><td>update（重要）</td><td>更新rpm软件包</td></tr><tr><td>check-update</td><td>检查是否有可用的更新rpm软件包</td></tr><tr><td>remove（重要）</td><td>删除指定的rpm软件包</td></tr><tr><td>list</td><td>显示软件包信息</td></tr><tr><td>clean</td><td>清理yum过期的缓存</td></tr><tr><td>deplist</td><td>显示yum软件包的所有依赖关系</td></tr></tbody></table><p>案例实操：</p><p>采用yum方式安装firefox：yum -y install firefox</p><h4 id="修改网络YUM源"><a href="#修改网络YUM源" class="headerlink" title="修改网络YUM源"></a>修改网络YUM源</h4><p>默认的系统YUM源，需要连接国外apache网站，网速比较慢，可以修改关联的网络YUM源为国内镜像的网站，比如网易163，aliyun等</p><p>（1）安装wget，wget用来从指定的URL下载文件</p><p><code>yum install wget</code></p><p>（2）在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下，备份默认的repos文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@study yum.repos.d] <span class="hljs-built_in">pwd</span><br>/etc/yum.repos.d<br>[root@study yum.repos.d] <span class="hljs-built_in">cp</span> CentOS-Base.repo CentOS-Base.repo.backup<br></code></pre></td></tr></table></figure><p>（3）下载网易163或者是aliyun的repos文件，任选其一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@study yum.repos.d] wget http://mirrors.aliyun.com/repo/Centos-7.repo<br>[root@study yum.repos.d] wget http://mirrors.163.com/.help/CentOS7-Base-163.repo<br></code></pre></td></tr></table></figure><p>（4）使用下载好的repos文件替换默认的repos文件</p><p><code>mv CentOS7-Base-163.repo CentOS-Base.repo</code></p><p>（5）清理旧缓存，缓存新数据</p><p><code>yum clean all</code></p><p><code>yum makecache</code></p><p>（6）测试</p><p><code>yum list | grep firefox</code></p><p><code>yum -y install firefox</code></p><h1 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h1><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><h2 id="shell概述"><a href="#shell概述" class="headerlink" title="shell概述"></a>shell概述</h2><p>Shell是一个<u><em><strong>命令解释器</strong></em></u>，它接收应用程序&#x2F;用户命令，然后调用操作系统内核。Shell还是一个功能相当强大的编程语言，易编写、易调试、灵活性强。</p><p>Linux提供的Shell解释器有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@study ~]<span class="hljs-comment"># less /etc/shells</span><br></code></pre></td></tr></table></figure><p>&#x2F;bin&#x2F;sh</p><p>&#x2F;bin&#x2F;bash</p><p>&#x2F;usr&#x2F;bin&#x2F;sh</p><p>&#x2F;usr&#x2F;bin&#x2F;bash</p><p>&#x2F;bin&#x2F;tcsh</p><p>&#x2F;bin&#x2F;csh</p><h2 id="shell脚本入门"><a href="#shell脚本入门" class="headerlink" title="shell脚本入门"></a>shell脚本入门</h2><h3 id="1-脚本格式"><a href="#1-脚本格式" class="headerlink" title="1.脚本格式"></a>1.脚本格式</h3><p>脚本以<code>#!/bin/bash</code> 开头（指定解析器）</p><h3 id="2-第一个Shell脚本：helloworld-sh"><a href="#2-第一个Shell脚本：helloworld-sh" class="headerlink" title="2.第一个Shell脚本：helloworld.sh"></a>2.第一个Shell脚本：helloworld.sh</h3><p>（可以不加任何后缀，只要格式符合shell编程即可执行）</p><p>需求：创建一个Shell脚本，输出helloworld</p><p>案例实操：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@study test2]<span class="hljs-comment"># touch helloworld.sh</span><br>[root@study test2]<span class="hljs-comment"># vim helloworld.sh </span><br><br>在helloworld.sh中输入如下内容<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;helloworld&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-脚本的常用执行方式"><a href="#3-脚本的常用执行方式" class="headerlink" title="3.脚本的常用执行方式"></a>3.脚本的常用执行方式</h3><p>第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p><p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p><p><code>chmod a+x helloworld.sh</code></p><p>（了解）第三种：在脚本的路径前加上“.”或者source</p><p><code>source helloworld.sh</code></p><p><code>. helloworld.sh</code></p><p>区别：</p><ul><li><p>前两种方式是在当前shell中打开一个子shell来执行脚本内容，当脚本内容结束，则子shell关闭，回到父shell中。</p></li><li><p>第三种，也就是使用在脚本路径前加“.”或者source的方式，可以使脚本内容在当前shell里执行，而无需打开子shell，这也是为什么我们每次修改完&#x2F;etc&#x2F;profile文件以后，需要source一下的原因。</p></li></ul><p>开子shell与不开子shell的区别就在于，环境变量的继承关系，如在子shell中设置的当前变量，父shell是不可见的。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="系统预定义变量"><a href="#系统预定义变量" class="headerlink" title="系统预定义变量"></a>系统预定义变量</h3><p>常用系统变量：$HOME、$PWD、$SHELL、$USER等</p><p><code>echo $</code></p><p><code>env | less</code></p><p><code>printenv | less</code>（查看全局变量），<code>printenv USER</code>（不用加$）</p><p>查看当前定义的全部变量（全局和局部）：<code>set</code></p><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>基本语法：</p><p>（1）定义变量：变量名&#x3D;变量值，***<u>注意：&#x3D;号后面不能有空格</u>***</p><p>（2）撤销变量：unset 变量名</p><p>（3）声明只读变量：readonly 变量，***<u>注意：不能unset</u>***</p><p>局部变量提升为全局变量</p><ul><li>先定义局部变量</li><li><code>export my_var</code>，即导出为全局变量</li></ul><p>注意：在子shell中修改了全局变量不会影响父shell中对应的全局变量（export导出也不行）</p><p>（局部变量只能在当前shell中访问到，提升为全局变量后，自己及子shell可以获取到）</p><p>变量定义规则：</p><p>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，***<u>环境变量名建议大写</u>***。</p><p>（2）等号两侧不能有空格。</p><p>（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</p><p>（4）变量的值如果有空格，需要使用双引号或单引号括起来。</p><h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p>单引号</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><p>双引号：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><p>获取字符串长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">string=<span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#string&#125;</span> <br></code></pre></td></tr></table></figure><p>当变量为数组时，&#96;$</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ADB学习</title>
    <link href="/2023/02/10/ADB%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/02/10/ADB%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>ADB学习</p><p>adb（android debug bridge）安卓调试桥，用于完成电脑和android手机间的通信控制。（使用xcode来完成对于ios设备的操控，前提是有个mac电脑）</p><h1 id="adb的安装"><a href="#adb的安装" class="headerlink" title="adb的安装"></a>adb的安装</h1><p>本身adb是android SDK其中自带的工具，用于完成电脑和手机之间的通信控制。</p><p>最简单的使用方法：将adb的三个必备文件，放到自己的电脑目录上，配置环境变量path就可以用。</p><p>推荐安装sdk：<a href="http://tools.android-studio.org/index.php/sdk">http://tools.android-studio.org/index.php/sdk</a></p><ul><li>下载zip包，解压即可</li><li>解压之后，将sdk的platform-tools配置到环境变量path里。</li><li>adb version用于查看版本，验证配置成功</li></ul><h1 id="将设备与电脑连接"><a href="#将设备与电脑连接" class="headerlink" title="将设备与电脑连接"></a>将设备与电脑连接</h1><p>建议练习时使用android模拟器，mumu 或 夜神</p><ol><li><p>打开手机上的开发者选项，通过点击手机版本号7次。</p></li><li><p>开发者选项中，打开usb调试。</p></li><li><p>连接模拟器设备：<code>adb connect 127.0.0.1:xxxxx</code></p></li><li><p>连接完成之后，用<code>adb devices</code>命令查看当前连接的设备，注意后面的device表示连接成功。</p></li></ol><h1 id="常用的adb命令"><a href="#常用的adb命令" class="headerlink" title="常用的adb命令"></a>常用的adb命令</h1><p>adb shell：用于进入android系统进行操作，exit退出。</p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p>adb install [电脑上apk包路径]：安装apk安装包。</p><p>adb uninstall [安卓系统中应用的包名（package）]：卸载应用</p><h2 id="包管理（pm）操作"><a href="#包管理（pm）操作" class="headerlink" title="包管理（pm）操作"></a>包管理（pm）操作</h2><p>adb shell pm list package：列出手机中安装的所有应用的package名字。</p><p>adb shell pm list package -3：查看安装的第三方应用。</p><p>在执行的时候，实际上先通过adb shell进入安卓手机系统，然后调用手机中的pm命令：放在system&#x2F;bin目录下的pm脚本。</p><p>（如果已经通过adb shell进入到手机，则直接使用<code>pm list package</code>）</p><h2 id="下载和上传文件"><a href="#下载和上传文件" class="headerlink" title="下载和上传文件"></a>下载和上传文件</h2><p>adb pull [手机上的文件路径] [电脑上的目标目录]：将文件从手机下载到电脑。</p><p>adb push [电脑上的文件] [手机上目标目录]：将文件从电脑上传到手机。</p><h2 id="页面管理操作"><a href="#页面管理操作" class="headerlink" title="页面管理操作"></a>页面管理操作</h2><p>am:activity manager，手机应用中的每个页面就是一个activity。</p><p>启动应用，需要通过应用的启动activity来完成调用。</p><p>adb shell am start -W -S [包名]&#x2F;[启动activity名]：启动对应的应用</p><p>获取应用的activity：</p><ol><li><p>adb shell dumpsys activity | grep “mFocuse”（使用此命令时需要打开被测应用，实际上获取的是当前应用打开的activity名，有可能并不是启动用的activity）</p></li><li><p>使用sdk中的aapt工具来进行apk包的解析。（获取到的一定是启动用的activity）</p></li><li><p>adb shell monkey -p [被测包名] -v -v -v 1 （通过查看日志信息中，找到using开头的那一句，其中activity名字就是启动页面）</p></li></ol><p>交互型命令：</p><p>adb shell input text [文本]</p><h1 id="adb完成自动化操作"><a href="#adb完成自动化操作" class="headerlink" title="adb完成自动化操作"></a>adb完成自动化操作</h1><ol><li><p>先获取包名：<code>adb shell pm list package -3</code></p></li><li><p>根据包名获取应用的启动activity：<code>adb shell monkey -p [被测包名] -v -v -v 1</code></p></li><li><p>根据获取到的activity名字，启动应用：<code>adb shell am start -W -S [包名]/[启动activity名]</code></p></li></ol><p>互联互通，多设备下通信，</p><p>设备：tv，音响，嵌入式设备，</p><p>系统：android</p><p>app1：调用系统底层</p><p>app2：sdk，进程通信，异步收消息</p><p>通信设备：蓝牙</p><p>接口调用时序</p><p>安卓版本影响、wifi适配器影响（接口调用时间）</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架</title>
    <link href="/2023/02/05/Gin%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/02/05/Gin%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>Gin框架</p><h1 id="Gin介绍"><a href="#Gin介绍" class="headerlink" title="Gin介绍"></a>Gin介绍</h1><p>Gin是一个Go（Golang）编写的轻量级http web框架，运行速度非常快，Gin最擅长的就是Api接口的高并发。</p><p>Gin官网：<a href="https://gin-gonic.com/zh-cn">https://gin-gonic.com/zh-cn</a></p><p>Gin Github地址：<a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p><p>Gin框架中文文档：<a href="https://gin-gonic.com/zh-cn/docs/">文档 | Gin Web Framework (gin-gonic.com)</a></p><h1 id="Gin环境搭建"><a href="#Gin环境搭建" class="headerlink" title="Gin环境搭建"></a>Gin环境搭建</h1><ol><li>下载并安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/git-gonic/gin<br></code></pre></td></tr></table></figure><ol start="2"><li>将gin引入到代码中</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>（可选）如果使用诸如http.StatusOK之类的常量，则需要引入net&#x2F;http包</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>新建Main.go路由</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br><span class="hljs-comment">//配置路由</span><br>engine.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;值：%v&quot;</span>, <span class="hljs-string">&quot;你好golang&quot;</span>)<br>&#125;)<br>engine.GET(<span class="hljs-string">&quot;/get&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个Get请求&quot;</span>)<br>&#125;)<br>engine.POST(<span class="hljs-string">&quot;/post&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个Post请求&quot;</span>)<br>&#125;)<br>engine.PUT(<span class="hljs-string">&quot;/put&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个Put请求&quot;</span>)<br>&#125;)<br>engine.DELETE(<span class="hljs-string">&quot;/delete&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个delete请求&quot;</span>)<br>&#125;)<br>engine.Run(<span class="hljs-string">&quot;:8000&quot;</span>) <span class="hljs-comment">//启动一个web服务</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="golang程序热加载"><a href="#golang程序热加载" class="headerlink" title="golang程序热加载"></a>golang程序热加载</h1><p>热加载就是当我们对代码进行修改时，程序能够自动重新加载并执行，省去了每次手动重新编译。</p><p>beego中可以使用官方提供的bee工具来热加载项目，但是gin中并没有官方提供的热加载工具，这个时候可以借助第三方工具。</p><p>工具1（推荐）：<a href="https://github.com/gravityblast/fresh">https://github.com/gravityblast/fresh</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/pilu/fresh<br></code></pre></td></tr></table></figure><p>工具2：<a href="https://github.com/codegangsta/gin">https://github.com/codegangsta/gin</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/codegangsta/gin<br></code></pre></td></tr></table></figure><h1 id="Gin框架中的路由"><a href="#Gin框架中的路由" class="headerlink" title="Gin框架中的路由"></a>Gin框架中的路由</h1><h2 id="路由概述"><a href="#路由概述" class="headerlink" title="路由概述"></a>路由概述</h2><p>路由（Routing）是由一个URI（或者叫路径）和一个特定的HTTP方法（GET、POST等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p><p>RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。</p><p>在RESTful架构中，每个网址代表一种资源，不同的请求方式表示执行不同的操作：</p><table><thead><tr><th>GET（SELECT）</th><th>从服务器取出资源（一项或多项）</th></tr></thead><tbody><tr><td>POST（CREATE）</td><td>在服务器新建一个资源</td></tr><tr><td>PUT（UPDATE）</td><td>在服务器更新资源（客户端提供改变后的完整资源）</td></tr><tr><td>DELETE（DELETE）</td><td>从服务器删除资源</td></tr></tbody></table><h2 id="c-String-c-JSON-c-JSONP-c-XML-c-HTML"><a href="#c-String-c-JSON-c-JSONP-c-XML-c-HTML" class="headerlink" title="c.String(),c.JSON(),c.JSONP(),c.XML(),c.HTML()"></a>c.String(),c.JSON(),c.JSONP(),c.XML(),c.HTML()</h2><h3 id="返回一个字符串"><a href="#返回一个字符串" class="headerlink" title="返回一个字符串"></a>返回一个字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br><span class="hljs-comment">//配置路由</span><br>engine.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;值：%v&quot;</span>, <span class="hljs-string">&quot;你好golang&quot;</span>)<br>&#125;)<br>engine.GET(<span class="hljs-string">&quot;/get&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个Get请求&quot;</span>)<br>&#125;)<br>engine.POST(<span class="hljs-string">&quot;/post&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个Post请求&quot;</span>)<br>&#125;)<br>engine.PUT(<span class="hljs-string">&quot;/put&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个Put请求&quot;</span>)<br>&#125;)<br>engine.DELETE(<span class="hljs-string">&quot;/delete&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *gin.Context)</span></span> &#123;<br>context.String(http.StatusOK, <span class="hljs-string">&quot;你发送了一个delete请求&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="返回json"><a href="#返回json" class="headerlink" title="返回json"></a>返回json</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.GET(<span class="hljs-string">&quot;/json1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;你好golang&quot;</span>,<br>&#125;)<br>&#125;)<br><br>engine.GET(<span class="hljs-string">&quot;/json2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><br>a := Article&#123;<br>Title:   <span class="hljs-string">&quot;标题&quot;</span>,<br>Desc:    <span class="hljs-string">&quot;描述&quot;</span>,<br>Content: <span class="hljs-string">&quot;内容&quot;</span>,<br>&#125;<br>c.JSON(http.StatusOK, a)<br>&#125;)<br></code></pre></td></tr></table></figure><p>返回结构体json的时候，如果结构体中某个字段不想返回可以加上标签<code>json:&quot;-&quot;</code></p><h3 id="返回jsonp"><a href="#返回jsonp" class="headerlink" title="返回jsonp"></a>返回jsonp</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.GET(<span class="hljs-string">&quot;/jsonp&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><br>a := Article&#123;<br>Title:   <span class="hljs-string">&quot;标题-jsonp&quot;</span>,<br>Desc:    <span class="hljs-string">&quot;描述&quot;</span>,<br>Content: <span class="hljs-string">&quot;内容&quot;</span>,<br>&#125;<br>c.JSONP(http.StatusOK, a)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="返回xml"><a href="#返回xml" class="headerlink" title="返回xml"></a>返回xml</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.GET(<span class="hljs-string">&quot;/xml&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.XML(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;返回xml&quot;</span>,<br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br><span class="hljs-comment">//配置模板文件</span><br>engine.LoadHTMLGlob(<span class="hljs-string">&quot;templates/*&quot;</span>)<br>engine.GET(<span class="hljs-string">&quot;/news&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.HTML(http.StatusOK, <span class="hljs-string">&quot;news.html&quot;</span>, gin.H&#123;<br><span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;后台数据&quot;</span>,<br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="Gin-HTML模板渲染"><a href="#Gin-HTML模板渲染" class="headerlink" title="Gin HTML模板渲染"></a>Gin HTML模板渲染</h1><h2 id="全部模板放在一个目录里面的配置方法"><a href="#全部模板放在一个目录里面的配置方法" class="headerlink" title="全部模板放在一个目录里面的配置方法"></a>全部模板放在一个目录里面的配置方法</h2><ol><li><p>在项目根目录新建templates文件夹（文件夹名字自定义），在文件夹中新建index.html（前端页面模板）</p></li><li><p>Gin框架中使用c.HTML()可以渲染模板，渲染模板前需要使用LoadHTMLGlob()或者LoadHTMLFiles()方法加载模板。</p></li></ol><h2 id="模板放在不同目录里面的配置方法"><a href="#模板放在不同目录里面的配置方法" class="headerlink" title="模板放在不同目录里面的配置方法"></a>模板放在不同目录里面的配置方法</h2><p>定义模板的时候需要通过define定义名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; define &quot;admin/index.html&quot;&#125;&#125; <span class="hljs-comment">&lt;!--相当于给模板定义一个名称，define与end成对出现--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>&#123;&#123; end &#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br><span class="hljs-comment">//配置模板文件</span><br>engine.LoadHTMLGlob(<span class="hljs-string">&quot;templates/**/*&quot;</span>)<br>    engine.GET(<span class="hljs-string">&quot;/admin&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.HTML(http.StatusOK, <span class="hljs-string">&quot;admin/index.html&quot;</span>, gin.H&#123;<br><span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;首页&quot;</span>,<br>&#125;)<br>&#125;)<br>engine.Run(<span class="hljs-string">&quot;:8000&quot;</span>) <span class="hljs-comment">//启动一个web服务</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="gin模板基本语法"><a href="#gin模板基本语法" class="headerlink" title="gin模板基本语法"></a>gin模板基本语法</h2><h3 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h3><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>可以在模板中声明变量，用来保存传入模板的数据或其他语句生成的结果。语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;$obj := .title&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span><br>   &#123;&#123;$obj&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="移除空格"><a href="#移除空格" class="headerlink" title="移除空格"></a>移除空格</h3><p>有时候在使用模板语法的时候会不可避免地引入一下空格或者换行符，这样模板最终渲染出来的内容就可能和我们想的不一样，这个时候可以使用<code>&#123;&#123;-`语法去除模板内容左侧的所有空白符号，使用`-&#125;&#125;</code>去除模板内容右侧的所有空白符号。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;- .Name -&#125;&#125;<br></code></pre></td></tr></table></figure><p>注意：-要紧挨，同时与模板值之间需要使用空格分隔。</p><h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><p>布尔函数会将任何类型的零值视为假，其余视为真。</p><p>下面是定义为函数的二元比较运算的集合：</p><p>eq如果arg1 &#x3D;&#x3D; arg2 则返回真</p><p>ne如果arg1 !&#x3D; arg2 则返回真</p><p>lt如果arg1 &lt; arg2 则返回真</p><p>le如果arg1 &lt;&#x3D; arg2 则返回真</p><p>gt如果arg1 &gt; arg2 则返回真</p><p>ge如果arg1 &gt;&#x3D; arg2 则返回真</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html">//举例<br>&#123;&#123;if gt .score 60&#125;&#125;<br>及格<br>&#123;&#123;else&#125;&#125;<br>不及格<br>&#123;&#123;end&#125;&#125;<br><br><br>&#123;&#123;if gt .score 90&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    优秀<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;&#123;else if gt .score 60&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;&#123;else&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    不及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>Go的模板语法中使用range关键字进行遍历，有以下两种写法，其中pipeline的值必须是数组、切片、字典或者通道。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;range $key,$value := .obj&#125;&#125;<br>&#123;&#123;value&#125;&#125;<br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure><p>如果pipeline的值其长度为0，不会有任何输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;range $key,$value := .obj&#125;&#125;<br>&#123;&#123;value&#125;&#125;<br>&#123;&#123;else&#125;&#125;<br>pipeline的值其长度为0<br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="With"><a href="#With" class="headerlink" title="With"></a>With</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：&#123;&#123;.user.Name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性别：&#123;&#123;.user.Gender&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>年龄：&#123;&#123;.user.Age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--解构结构体--&gt;</span><br>&#123;&#123;with .user&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>姓名：&#123;&#123;.Name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>性别：&#123;&#123;.Gender&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>年龄：&#123;&#123;.Age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="预定义函数（了解）"><a href="#预定义函数（了解）" class="headerlink" title="预定义函数（了解）"></a>预定义函数（了解）</h3><p>执行模板时，函数从两个函数字典中查找：首先是模板函数字典，然后是全局函数字典。一般不在模板内定义函数，而是使用Funcs方法添加函数到模板里。</p><p>预定义的全局函数如下：</p><p>and：函数返回它的第一个empty参数或者最后一个参数；就是说“and x y”等价于“if x then y else x”；所有参数都会执行；</p><p>or：返回第一个非empty参数或者最后一个参数；“or x y”等价于“if x then x else y”；所有参数都会执行；</p><p>not：返回它的单个参数的布尔值的否定</p><p>len：返回它的参数的整数类型长度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;len .title&#125;&#125;<br></code></pre></td></tr></table></figure><p>index：执行结果为第一个参数以剩下的参数为索引&#x2F;键指向的值；</p><h3 id="自定义函数模板"><a href="#自定义函数模板" class="headerlink" title="自定义函数模板"></a>自定义函数模板</h3><p>通过engine.SetFuncMap()设定模板函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//时间戳转换成日期</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnixToTime</span><span class="hljs-params">(timeStamp <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>t := time.Unix(<span class="hljs-type">int64</span>(timeStamp), <span class="hljs-number">0</span>)<br>date := t.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)<br><span class="hljs-keyword">return</span> date<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br>    <span class="hljs-comment">//自定义模板函数 注意要把这个函数放在加载模板前</span><br>engine.SetFuncMap(template.FuncMap&#123;<br><span class="hljs-string">&quot;UnixToTime&quot;</span>: UnixToTime,<br>&#125;)<br>    <span class="hljs-comment">//配置模板文件，必须放在配置路由上面</span><br>engine.LoadHTMLGlob(<span class="hljs-string">&quot;templates/**/*&quot;</span>)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>前端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;UnixToTime .date&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="嵌套template"><a href="#嵌套template" class="headerlink" title="嵌套template"></a>嵌套template</h3><p>1.新建template&#x2F;public&#x2F;page_header.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; define &quot;public/page_header.html&quot; &#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>公共标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>&#123;&#123;end&#125;&#125;<br></code></pre></td></tr></table></figure><p>2.外部引入</p><p>注意：</p><ul><li>引入的名字为page_header.html中定义的名字</li><li>引入的时候注意最后的点（.）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;template &quot;public/page_header.html&quot; .&#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; define &quot;admin/index.html&quot;&#125;&#125;<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>&#123;&#123;template &quot;public/page_header.html&quot; .&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>&#123;&#123; end &#125;&#125;<br></code></pre></td></tr></table></figure><h1 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h1><p>当我们渲染的HTML文件中引用了静态文件时，我们需要配置静态web服务</p><p>r.Static(“&#x2F;static”, “.&#x2F;static”) 前面的&#x2F;static表示网站访问路径，后面的.&#x2F;static表示本地文件路径（相对于项目根目录）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br><span class="hljs-comment">//自定义模板函数 注意要把这个函数放在加载模板前</span><br>engine.SetFuncMap(template.FuncMap&#123;<br><span class="hljs-string">&quot;UnixToTime&quot;</span>: UnixToTime,<br>&#125;)<br><span class="hljs-comment">//配置模板文件，必须放在配置路由上面</span><br>engine.LoadHTMLGlob(<span class="hljs-string">&quot;templates/**/*&quot;</span>)<br><span class="hljs-comment">//配置静态web目录 第一个参数表示路由，第二个参数表示映射的目录</span><br>engine.Static(<span class="hljs-string">&quot;/static&quot;</span>, <span class="hljs-string">&quot;./static&quot;</span>)<span class="hljs-comment">//表示访问路径/static的时候会去templates中的static目录中寻找</span><br> ...   <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;static/css/base.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h1><h2 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h2><h3 id="Get请求查询参数-Query"><a href="#Get请求查询参数-Query" class="headerlink" title="Get请求查询参数 Query"></a>Get请求查询参数 Query</h3><p>Get &#x2F;user?username&#x3D;20&amp;age&#x3D;1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.GET(<span class="hljs-string">&quot;/user&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>username := c.Query(<span class="hljs-string">&quot;username&quot;</span>)<br>age := c.DefaultQuery(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;username=%v, age=%v\n&quot;</span>, username, age)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="表单PostForm"><a href="#表单PostForm" class="headerlink" title="表单PostForm"></a>表单PostForm</h3><p>通过c.PostForm()或c.DefaultPostForm()获取表单中的数据</p><p>（获取请求体中的生json数据，使用c.GetRawData()，然后使用json包解析成map或结构体，再把数据取出来）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.POST(<span class="hljs-string">&quot;/postUser&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//username := c.PostForm(&quot;username&quot;)</span><br><span class="hljs-comment">//age := c.DefaultPostForm(&quot;age&quot;, &quot;0&quot;)</span><br>body, _ := c.GetRawData()<br><span class="hljs-keyword">var</span> jsonMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br>json.Unmarshal(body, &amp;jsonMap)<br><br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;username&quot;</span> : jsonMap[<span class="hljs-string">&quot;username&quot;</span>],<br><span class="hljs-string">&quot;age&quot;</span>: jsonMap[<span class="hljs-string">&quot;age&quot;</span>],<br>&#125;)<br><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="获取Get和Post传递的数据绑定到结构体"><a href="#获取Get和Post传递的数据绑定到结构体" class="headerlink" title="获取Get和Post传递的数据绑定到结构体"></a>获取Get和Post传递的数据绑定到结构体</h3><p>为了能够更方便地获取请求相关参数，提高开发效率，可以基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。.ShouldBind()能够基于请求自动提取JSON、form表单和QueryString类型的数据，并把值绑定到指定的结构体对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;username&quot; form:&quot;username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot; form:&quot;password&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.GET(<span class="hljs-string">&quot;/getUser&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>user := UserInfo&#123;&#125;<br><span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;user); err == <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, user)<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, user)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;err&quot;</span>: err.Error(),<br>&#125;)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.POST(<span class="hljs-string">&quot;/postUser2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>user := UserInfo&#123;&#125;<br><span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;user); err == <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, user)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(http.StatusInternalServerError, gin.H&#123;<br><span class="hljs-string">&quot;err&quot;</span>: err.Error(),<br>&#125;)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="bind绑定参数"><a href="#bind绑定参数" class="headerlink" title="bind绑定参数"></a>bind绑定参数</h3><p>gin中的bind可以很方便地将前端传递来的数据与<code>结构体</code>进行<code>参数绑定</code>，以及参数校验。</p><ul><li>参数绑定：在使用这个功能的时候，需要给结构体加上Tag <code>json</code>,<code>form</code>,<code>uri</code>,<code>xml</code>,<code>yaml</code></li><li>Must Bind：不用，校验失败会改状态码</li><li>Should Bind：可以绑定json，query，param，yaml，xml，如果校验不通过会返回错误。会根据请求头中的content-type去自动绑定，form-data的参数也用这个，tag用form</li><li>BindJSON、BindQuery等本质是调用MustBind，一般不用这种方式，因为会修改状态码</li></ul><h3 id="常用验证器"><a href="#常用验证器" class="headerlink" title="常用验证器"></a>常用验证器</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//不能为空，并且不能没有这个字段</span><br>required: 必填字段，如： binding:<span class="hljs-string">&quot;required&quot;</span><br><br><span class="hljs-comment">//针对字符串的长度</span><br><span class="hljs-keyword">min</span> 最小长度，如：binding:<span class="hljs-string">&quot;min=5&quot;</span><br><span class="hljs-keyword">max</span> 最大长度，如：binding:<span class="hljs-string">&quot;max=10&quot;</span><br>len 长度，如：binding:<span class="hljs-string">&quot;len=6&quot;</span> <span class="hljs-comment">//长度只能为4</span><br><br><span class="hljs-comment">//针对数字的大小</span><br><span class="hljs-literal">eq</span> 等于，如：binding:<span class="hljs-string">&quot;eq=3&quot;</span><br>ne 不等于，如：binding:<span class="hljs-string">&quot;ne=12&quot;</span><br><span class="hljs-literal">gt</span> 大于，如：binding:<span class="hljs-string">&quot;gt=10&quot;</span><br><span class="hljs-literal">gte</span> 大于等于，如：binding:<span class="hljs-string">&quot;gte=10&quot;</span><br><span class="hljs-literal">lt</span> 小于，如：binding:<span class="hljs-string">&quot;lt=30,gt=18&quot;</span><br><span class="hljs-literal">lte</span> 小于等于，如：binding:<span class="hljs-string">&quot;lte=10&quot;</span><br><br><span class="hljs-comment">//针对同级字段</span><br>eqfield 等于其他字段的值，如：Password <span class="hljs-built_in">string</span> <span class="hljs-string">`binding:&quot;eqfield=ConfirmPassword&quot;`</span><br>nefield 不等于其他字段的值<br>- 忽略字段，如：binding:<span class="hljs-string">&quot;-&quot;</span><br></code></pre></td></tr></table></figure><h3 id="gin内置验证器"><a href="#gin内置验证器" class="headerlink" title="gin内置验证器"></a>gin内置验证器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//枚举 只能是red或green</span><br>oneof=red green <span class="hljs-comment">//binding:&quot;required,oneof=red green&quot;</span><br><br><span class="hljs-comment">//字符串</span><br>contains=czh<span class="hljs-comment">//包含czh的字符串</span><br>excludes <span class="hljs-comment">//不包含</span><br>startswith <span class="hljs-comment">//字符串前缀</span><br>endswith   <span class="hljs-comment">//字符串后缀</span><br><br><span class="hljs-comment">//数组</span><br>dive <span class="hljs-comment">//dive后面的验证就是针对数组中的每一个元素</span><br><br><span class="hljs-comment">//网络验证</span><br>ip<br>ipv4<br>ipv6<br>uri<br>url<br><span class="hljs-comment">//uri在于Identifier是统一资源标示区，可以唯一标识一个资源</span><br><span class="hljs-comment">//url在于Locater，是统一资源定位符，提供找到该资源的确切路径</span><br><br><span class="hljs-comment">//日期验证</span><br>datetime=<span class="hljs-number">2006</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span><br></code></pre></td></tr></table></figure><h3 id="自定义验证的错误信息"><a href="#自定义验证的错误信息" class="headerlink" title="自定义验证的错误信息"></a>自定义验证的错误信息</h3><p>当验证不通过的时候，会给出错误信息，但是原始的错误信息不太友好，不利于用户查看。</p><p>需要给结构体加一个msg（msg名字自定义）的tag，再使用反射</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SignUserInfo <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; binding:&quot;required&quot; msg:&quot;name不能为空&quot;`</span><span class="hljs-comment">//用户名</span><br>Age <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;age&quot;`</span><span class="hljs-comment">//年龄</span><br>Sex <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sex&quot; binding:&quot;oneof=man woman&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot;`</span><span class="hljs-comment">//密码</span><br>RePassword <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;re_password&quot; binding:&quot;eqfield=Password&quot;`</span><span class="hljs-comment">//确认密码</span><br>&#125;<br><br><span class="hljs-comment">//获取结构体中的msg参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetValidMsg</span><span class="hljs-params">(err <span class="hljs-type">error</span>, obj any)</span></span> <span class="hljs-type">string</span> &#123;<br>getObj := reflect.TypeOf(obj)<br><br><span class="hljs-comment">//将err断言为具体的类型</span><br><span class="hljs-keyword">if</span> errors, ok := err.(validator.ValidationErrors); ok &#123;<br><span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> errors &#123;<br><span class="hljs-comment">//根据报错字段名获取结构体的具体字段</span><br><span class="hljs-keyword">if</span> f, exist := getObj.Elem().FieldByName(e.Field()); exist&#123;<br>msg := f.Tag.Get(<span class="hljs-string">&quot;msg&quot;</span>)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br>router.POST(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> user SignUserInfo<br>err := c.ShouldBindJSON(&amp;user)<br>fmt.Printf(<span class="hljs-string">&quot;%v -- %T\n&quot;</span>, err, err)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: GetValidMsg(err, &amp;user),<br>&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;data&quot;</span>: user,<br>&#125;)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8002&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h3><p>注册验证器函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">signValid</span><span class="hljs-params">(fl validator.FieldLevel)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> nameList = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>&#125;<br><span class="hljs-keyword">for</span> _, nameStr := <span class="hljs-keyword">range</span> nameList &#123;<br>name := fl.Field().Interface().(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> name == nameStr &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><span class="hljs-keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;<br>v.RegisterValidation(<span class="hljs-string">&quot;sign&quot;</span>, signValid)<br>&#125;<br><br>router.POST(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> user SignUserInfo<br>err := c.ShouldBindJSON(&amp;user)<br>fmt.Printf(<span class="hljs-string">&quot;%v -- %T\n&quot;</span>, err, err)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: GetValidMsg(err, &amp;user),<br>&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;data&quot;</span>: user,<br>&#125;)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8002&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取Post、XML数据"><a href="#获取Post、XML数据" class="headerlink" title="获取Post、XML数据"></a>获取Post、XML数据</h3><p>在API开发中，经常会用到JSON或XML来作为数据交换格式，这时可以使用c.GetRawData()获取数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">userinfo</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>czh<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">userinfo</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.POST(<span class="hljs-string">&quot;/postUserXml&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>xmlRawData, _ := c.GetRawData()<br>userInfo := UserInfo&#123;&#125;<br>xml.Unmarshal(xmlRawData, &amp;userInfo)<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, userInfo)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="动态路由传值"><a href="#动态路由传值" class="headerlink" title="动态路由传值"></a>动态路由传值</h3><p>域名&#x2F;user&#x2F;20</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">engine.GET(<span class="hljs-string">&quot;/userParam/:uid&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>uid := c.Param(<span class="hljs-string">&quot;uid&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, uid)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Gin路由分组、Gin路由文件抽离"><a href="#Gin路由分组、Gin路由文件抽离" class="headerlink" title="Gin路由分组、Gin路由文件抽离"></a>Gin路由分组、Gin路由文件抽离</h2><p>路由分组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">apiRouters := engine.Group(<span class="hljs-string">&quot;/api&quot;</span>)<br>&#123;<br>apiRouters.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;我是一个api接口&quot;</span>)<br>&#125;)<br>apiRouters.GET(<span class="hljs-string">&quot;/userList&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;我是一个api接口&quot;</span>)<br>&#125;)<br>apiRouters.GET(<span class="hljs-string">&quot;/cart&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;我是一个api接口&quot;</span>)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>文件抽离</p><ol><li><p>新建一个routers目录</p></li><li><p>在routers目录中分别为&#x2F;api,&#x2F;admin等路由新建一个go文件</p></li><li><p>写一个参数为*gin.Engin的路由初始化方法</p></li><li><p>在main.go中调用路由初始化方法</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br><span class="hljs-comment">//自定义模板函数 注意要把这个函数放在加载模板前</span><br>engine.SetFuncMap(template.FuncMap&#123;<br><span class="hljs-string">&quot;UnixToTime&quot;</span>: UnixToTime,<br>&#125;)<br><span class="hljs-comment">//配置模板文件，必须放在配置路由上面</span><br>engine.LoadHTMLGlob(<span class="hljs-string">&quot;templates/**/**/*&quot;</span>)<br><span class="hljs-comment">//配置静态web目录 第一个参数表示路由，第二个参数表示映射的目录</span><br>engine.Static(<span class="hljs-string">&quot;/static&quot;</span>, <span class="hljs-string">&quot;./static&quot;</span>)<br><br>routers.TestRoutersInit(engine)<br><br>routers.ApiRoutersInit(engine)<br><br>routers.AdminRoutersInit(engine)<br><br>routers.DefaultRoutersInit(engine)<br><br>engine.Run(<span class="hljs-string">&quot;:8000&quot;</span>) <span class="hljs-comment">//启动一个web服务</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> routers<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ApiRoutersInit</span><span class="hljs-params">(engine *gin.Engine)</span></span>  &#123;<br>apiRouters := engine.Group(<span class="hljs-string">&quot;/api&quot;</span>)<br>&#123;<br>apiRouters.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;我是一个api接口&quot;</span>)<br>&#125;)<br>apiRouters.GET(<span class="hljs-string">&quot;/userList&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;我是一个api接口&quot;</span>)<br>&#125;)<br>apiRouters.GET(<span class="hljs-string">&quot;/cart&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;我是一个api接口&quot;</span>)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Gin自定义控制器及实现控制器的继承"><a href="#Gin自定义控制器及实现控制器的继承" class="headerlink" title="Gin自定义控制器及实现控制器的继承"></a>Gin自定义控制器及实现控制器的继承</h1><p>（抽离处理路由的方法）</p><ol><li><p>新建controllers目录</p></li><li><p>在controllers目录内为不同路由分别新建一个目录，如&#x2F;admin,&#x2F;api将对应处理路由的方法抽离到此目录下</p></li></ol><p>控制器的继承</p><ol><li>新建对应的结构体，将为处理路由的方法添加接收者为此结构体即可。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//userController.go</span><br><span class="hljs-keyword">type</span> UserController <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserController)</span></span> UserIndex(c *gin.Context) &#123;<br>c.HTML(http.StatusOK, <span class="hljs-string">&quot;admin/index.html&quot;</span>, gin.H&#123;<br><span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;首页&quot;</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserController)</span></span> User(c *gin.Context) &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;用户列表&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserController)</span></span> UserAdd(c *gin.Context) &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;用户列表&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserController)</span></span> UserEdit(c *gin.Context) &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;用户列表&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserController)</span></span> Article(c *gin.Context) &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;文章&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">//adminRouters.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AdminRoutersInit</span><span class="hljs-params">(engine *gin.Engine)</span></span>  &#123;<br>adminRouters := engine.Group(<span class="hljs-string">&quot;/admin&quot;</span>)<br>&#123;<br>adminRouters.GET(<span class="hljs-string">&quot;/&quot;</span>, admin.UserController&#123;&#125;.UserIndex)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user&quot;</span>, admin.UserController&#123;&#125;.User)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user/add&quot;</span>, admin.UserController&#123;&#125;.UserAdd)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user/edit&quot;</span>, admin.UserController&#123;&#125;.UserEdit)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/article&quot;</span>, admin.UserController&#123;&#125;.Article)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="请求头相关"><a href="#请求头相关" class="headerlink" title="请求头相关"></a>请求头相关</h1><h2 id="请求头参数获取"><a href="#请求头参数获取" class="headerlink" title="请求头参数获取"></a>请求头参数获取</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">router.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span>&#123;<br>    <span class="hljs-comment">//字母不区分大小写，单词与单词之间用 - 连接</span><br>    c.GetHeader(<span class="hljs-string">&quot;User-Agent&quot;</span>)<span class="hljs-comment">//源码中调用c.Request.Header.Get()</span><br>    <span class="hljs-comment">//字母不区分大小写</span><br>    c.Request.Header.Get(<span class="hljs-string">&quot;User-Agent&quot;</span>)<br>    <br>    c.Request.Header[<span class="hljs-string">&quot;User-Agent&quot;</span>]<span class="hljs-comment">//区分大小写</span><br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="响应头相关"><a href="#响应头相关" class="headerlink" title="响应头相关"></a>响应头相关</h1><h2 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">router.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span>&#123;<br>    c.Header(<span class="hljs-string">&quot;Token&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>)<br>    c.Header(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/text; charset=utf-8&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="Gin文件上传"><a href="#Gin文件上传" class="headerlink" title="Gin文件上传"></a>Gin文件上传</h1><h2 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h2><p><a href="https://gin-gonic.com/zh-cn/docs/examples/upload-file/single-file/">单文件 | Gin Web Framework (gin-gonic.com)</a></p><p>form标签中需要添加<code>enctype=&quot;multipart/form-data&quot;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><span class="hljs-comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span><br>router.MaxMultipartMemory = <span class="hljs-number">8</span> &lt;&lt; <span class="hljs-number">20</span>  <span class="hljs-comment">// 8 MiB</span><br>router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 单文件</span><br>file, _ := c.FormFile(<span class="hljs-string">&quot;file&quot;</span>)<br>log.Println(file.Filename)<br><br>dst := <span class="hljs-string">&quot;./&quot;</span> + file.Filename<br><span class="hljs-comment">// 上传文件至指定的完整文件路径</span><br>c.SaveUploadedFile(file, dst)<br><br>c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename))<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><span class="hljs-comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span><br>router.MaxMultipartMemory = <span class="hljs-number">8</span> &lt;&lt; <span class="hljs-number">20</span>  <span class="hljs-comment">// 8 MiB</span><br>router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// Multipart form</span><br>form, _ := c.MultipartForm()<br>files := form.File[<span class="hljs-string">&quot;upload[]&quot;</span>]<span class="hljs-comment">//前端&lt;input type=&quot;file&quot; name=&quot;upload[]&quot;&gt;，前端有多个name为“upload[]”的input标签</span><br><br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>log.Println(file.Filename)<br><br><span class="hljs-comment">// 上传文件至指定目录</span><br>c.SaveUploadedFile(file, dst)<br>&#125;<br>c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;%d files uploaded!&quot;</span>, <span class="hljs-built_in">len</span>(files)))<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="按日期存储图片"><a href="#按日期存储图片" class="headerlink" title="按日期存储图片"></a>按日期存储图片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u UserController)</span></span> DoUpload(c *gin.Context)&#123;<br><span class="hljs-comment">//username := c.PostForm(&quot;username&quot;)</span><br><span class="hljs-comment">//1.获取上传的文件</span><br>file, err := c.FormFile(<span class="hljs-string">&quot;face&quot;</span>)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//2.获取后缀名 判断类型是否正确</span><br>extName := path.Ext(file.Filename)<br>allowExtName := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;<br><span class="hljs-string">&quot;.jpg&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;.png&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;.gif&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;.jpeg&quot;</span>: <span class="hljs-literal">true</span>,<br>&#125;<br><br><span class="hljs-keyword">if</span> _, ok := allowExtName[extName]; !ok &#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;上传的文件类型不合法&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">//3.创建图片保存目录 static/upload/20230119</span><br>day := models.GetDay()<br><br>dir := <span class="hljs-string">&quot;./static/upload/&quot;</span> + day<br><br><span class="hljs-comment">//4.生成目录</span><br>err := os.Mkdir(dir, <span class="hljs-number">0755</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>c.String(http.StatusOK, <span class="hljs-string">&quot;生成目录失败&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>unix := models.GetUnix()<br>filename := strconv.FormatInt(unix,<span class="hljs-number">10</span>) + extName<br><br><span class="hljs-comment">//5.上传</span><br>dst := path.Join(dir, filename)<br>c.SaveUploadedFile(file, dst)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Gin文件下载"><a href="#Gin文件下载" class="headerlink" title="Gin文件下载"></a>Gin文件下载</h1><p><strong>直接响应一个路径下的文件</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c.File(<span class="hljs-string">&quot;uploads/1.jpeg&quot;</span>)<br></code></pre></td></tr></table></figure><p>有些响应，比如图片，浏览器就会直接显示这个图片，而不是下载，所以我们需要使浏览器唤起下载行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">c.Header(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/octet-stream&quot;</span>) <span class="hljs-comment">//表示是文件读，唤起浏览器下载，一般设置了这个就要设置文件名</span><br>c.Header(<span class="hljs-string">&quot;Content-Disposition&quot;</span>,<span class="hljs-string">&quot;attachment; filename=&quot;</span> + <span class="hljs-string">&quot;1.jpeg&quot;</span>) <span class="hljs-comment">//用于指定下载下来的文件名</span><br>c.Header(<span class="hljs-string">&quot;Content-Transfer-Encoding&quot;</span>, <span class="hljs-string">&quot;binary&quot;</span>) <span class="hljs-comment">//表示传输过程中的编码形式，乱码问题可能就是因为它</span><br>c.File(<span class="hljs-string">&quot;uploads/1.jpeg&quot;</span>)<br></code></pre></td></tr></table></figure><p>文件下载浏览器可能会有缓存，解决办法是加查询参数</p><p><strong>前后端模式下的文件下载</strong></p><p>如果是前后端模式下，后端只需要响应一个文件数据</p><p>文件名和其他信息就写在请求头中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">c.Header(<span class="hljs-string">&quot;filename&quot;</span>,<span class="hljs-string">&quot;xxx.png&quot;</span>)<br>c.File(<span class="hljs-string">&quot;uploads/1.png&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h1><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p><p>通俗地讲：中间件就是匹配路由前和匹配路由完成后执行的一系列操作。</p><h2 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h2><p>Gin中的中间件必须是一个gin.HandlerFunc类型，配置路由的时候可以传递多个func回调函数，最后一个func回调函数前面触发的方法都可以称为中间件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">adminRouters.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我是一个中间件&quot;</span>)<br>&#125;, admin.IndexController&#123;&#125;.Index)<br></code></pre></td></tr></table></figure><p>GET方法的第二个参数是可变参数，参数类型是参数为<code>*gin.Context</code>类型的函数，最后一个函数（路由处理函数）执行之前会执行前面的函数，这些写在前面的函数就称为路由中间件，如：</p><p>func(ctx *gin.Context) {<br>            fmt.Println(“我是一个中间件”)<br>        }</p><h2 id="c-Next-调用该请求的剩余处理程序"><a href="#c-Next-调用该请求的剩余处理程序" class="headerlink" title="c.Next()调用该请求的剩余处理程序"></a>c.Next()调用该请求的剩余处理程序</h2><p>中间件里面加上ctx.Next()可以在路由匹配完成后执行一些操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitMiddleware</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;中间件1&quot;</span>)<br>start := time.Now().Unix()<br>ctx.Next()<br>end := time.Now().Unix()<br>fmt.Printf(<span class="hljs-string">&quot;执行时间：%vs\n&quot;</span>, end - start)<br>fmt.Println(<span class="hljs-string">&quot;中间件2&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AdminRoutersInit</span><span class="hljs-params">(engine *gin.Engine)</span></span>  &#123;<br>adminRouters := engine.Group(<span class="hljs-string">&quot;/admin&quot;</span>)<br>&#123;<br>adminRouters.GET(<span class="hljs-string">&quot;/user&quot;</span>, InitMiddleware, admin.UserController&#123;&#125;.User)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c-Abort"><a href="#c-Abort" class="headerlink" title="c.Abort()"></a>c.Abort()</h2><p>c.Abort表示终止调用该请求的剩余处理程序。</p><h2 id="一个路由配置多个中间件的执行顺序"><a href="#一个路由配置多个中间件的执行顺序" class="headerlink" title="一个路由配置多个中间件的执行顺序"></a>一个路由配置多个中间件的执行顺序</h2><h2 id="配置全局中间件"><a href="#配置全局中间件" class="headerlink" title="配置全局中间件"></a>配置全局中间件</h2><p>使用engine.Use()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initMiddlewareOne</span><span class="hljs-params">(ctx *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;全局-1-中间件-initMiddlewareOne&quot;</span>)<br>ctx.Next()<br>fmt.Println(<span class="hljs-string">&quot;全局-2-中间件-initMiddlewareOne&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initMiddlewareTwo</span><span class="hljs-params">(ctx *gin.Context)</span></span>  &#123;<br>fmt.Println(<span class="hljs-string">&quot;全局-1-中间件-initMiddlewareTwo&quot;</span>)<br>ctx.Next()<br>fmt.Println(<span class="hljs-string">&quot;全局-2-中间件-initMiddlewareTwo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//创建一个默认的路由引擎</span><br>engine := gin.Default()<br><span class="hljs-comment">//自定义模板函数 注意要把这个函数放在加载模板前</span><br>engine.SetFuncMap(template.FuncMap&#123;<br><span class="hljs-string">&quot;UnixToTime&quot;</span>: UnixToTime,<br>&#125;)<br><span class="hljs-comment">//配置模板文件，必须放在配置路由上面</span><br>engine.LoadHTMLGlob(<span class="hljs-string">&quot;templates/**/**/*&quot;</span>)<br><span class="hljs-comment">//配置静态web目录 第一个参数表示路由，第二个参数表示映射的目录</span><br>engine.Static(<span class="hljs-string">&quot;/static&quot;</span>, <span class="hljs-string">&quot;./static&quot;</span>)<br><br><span class="hljs-comment">//全局中间件</span><br>engine.Use(initMiddlewareOne, initMiddlewareTwo)<br><br>routers.AdminRoutersInit(engine)<br><br>engine.Run(<span class="hljs-string">&quot;:8000&quot;</span>) <span class="hljs-comment">//启动一个web服务</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路由分组配置中间件"><a href="#路由分组配置中间件" class="headerlink" title="路由分组配置中间件"></a>路由分组配置中间件</h2><p>第一种：作为第二个参数写在Group方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AdminRoutersInit</span><span class="hljs-params">(engine *gin.Engine)</span></span>  &#123;<br>adminRouters := engine.Group(<span class="hljs-string">&quot;/admin&quot;</span>, middlewares.InitMiddlewareForGroup)<span class="hljs-comment">//路由分组配置中间件</span><br><br>&#123;<br>adminRouters.GET(<span class="hljs-string">&quot;/&quot;</span>, admin.IndexController&#123;&#125;.Index)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user&quot;</span>, initMiddlewareOne, initMiddlewareTwo, admin.UserController&#123;&#125;.User)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user/add&quot;</span>, admin.UserController&#123;&#125;.UserAdd)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user/edit&quot;</span>, admin.UserController&#123;&#125;.UserEdit)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/article&quot;</span>, admin.ArticleController&#123;&#125;.Article)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种：使用Use()方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AdminRoutersInit</span><span class="hljs-params">(engine *gin.Engine)</span></span>  &#123;<br>adminRouters := engine.Group(<span class="hljs-string">&quot;/admin&quot;</span>)<br>adminRouters.Use(middlewares.InitMiddlewareForGroup)<span class="hljs-comment">//路由分组配置中间件</span><br>&#123;<br>adminRouters.GET(<span class="hljs-string">&quot;/&quot;</span>, admin.IndexController&#123;&#125;.Index)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user&quot;</span>, initMiddlewareOne, initMiddlewareTwo, admin.UserController&#123;&#125;.User)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user/add&quot;</span>, admin.UserController&#123;&#125;.UserAdd)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/user/edit&quot;</span>, admin.UserController&#123;&#125;.UserEdit)<br><br>adminRouters.GET(<span class="hljs-string">&quot;/article&quot;</span>, admin.ArticleController&#123;&#125;.Article)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中间件和对应控制器之间共享数据"><a href="#中间件和对应控制器之间共享数据" class="headerlink" title="中间件和对应控制器之间共享数据"></a>中间件和对应控制器之间共享数据</h2><p>可以在中间件中使用c.Set(“key”, value)方法设置数据，在路由处理函数（handler）中使用c.Get(“key”)获取数据</p><h2 id="gin-New"><a href="#gin-New" class="headerlink" title="gin.New()"></a>gin.New()</h2><p>使用gin.Default()创建的默认引擎有Logger()和Recovery()两个中间件，其中：</p><ul><li>Logger中间件将日志写入gin.DefaultWriter，即配置了GIN_MODE&#x3D;release。</li><li>Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。</li></ul><p>如果不想要默认的两个中间件，可以使用gin.New()创建引擎。（推荐使用gin.Default()）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Default</span><span class="hljs-params">()</span></span> *Engine &#123;<br>debugPrintWARNINGDefault()<br>engine := New()<br>engine.Use(Logger(), Recovery())<br><span class="hljs-keyword">return</span> engine<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h2><p>当在中间件或handler中启动新的gouroutine时，不能使用原始的上下文(c *gin.Context)，必须使用其只读副本（c.Copy()）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitMiddlewareForGroup</span><span class="hljs-params">(c *gin.Context)</span></span>  &#123;<br>fmt.Println(time.Now())<br>fmt.Println(c.Request.URL)<br>c.Set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;czh&quot;</span>)<br><br>cCp := c.Copy()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;path:&quot;</span>, cCp.Request.URL)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Gin内置日志组件"><a href="#Gin内置日志组件" class="headerlink" title="Gin内置日志组件"></a>Gin内置日志组件</h1><h2 id="输出日志到log文件"><a href="#输出日志到log文件" class="headerlink" title="输出日志到log文件"></a>输出日志到log文件</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>file, _ := os.Create(<span class="hljs-string">&quot;gin.log&quot;</span>)<br><span class="hljs-comment">//gin.DefaultWriter = io.MultiWriter(file)//只输出到文件</span><br>gin.DefaultWriter = io.MultiWriter(file, os.Stdout)<span class="hljs-comment">//输出到文件和控制台</span><br><br>router := gin.Default()<br>    router.POST(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span>&#123;&#125;)<br>    <br>    router.Run()<br></code></pre></td></tr></table></figure><h2 id="定义路由格式"><a href="#定义路由格式" class="headerlink" title="定义路由格式"></a>定义路由格式</h2><p>启动gin，它会显示所有的路由，默认格式如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[GIN-debug]</span> POST   /                         --&gt; <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.main</span><span class="hljs-selector-class">.func1</span> (<span class="hljs-number">3</span> handlers)<br><span class="hljs-selector-attr">[GIN-debug]</span> POST   /upload                   --&gt; <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.main</span><span class="hljs-selector-class">.func2</span> (<span class="hljs-number">3</span> handlers)<br><span class="hljs-selector-attr">[GIN-debug]</span> GET    /download                 --&gt; <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.main</span><span class="hljs-selector-class">.func3</span> (<span class="hljs-number">3</span> handlers)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">gin.DebugPrintRouteFunc = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(httpMethod, absolutePath, handlerName <span class="hljs-type">string</span>, nuHandlers <span class="hljs-type">int</span>)</span></span>&#123;<br>log.Printf(<br><span class="hljs-string">&quot;[czh] %v %v %v %v\n&quot;</span>,<br>httpMethod,<br>absolutePath,<br>handlerName,<br>nuHandlers,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>用处不大</p><h2 id="查看路由"><a href="#查看路由" class="headerlink" title="查看路由"></a>查看路由</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">router.Routes() <span class="hljs-comment">//返回已注册的路由列表</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _,info := <span class="hljs-keyword">range</span> router.Routes()&#123;<br>    fmt.Println(info.Path, info.method, info.Handler)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">gin.SetMode(gin.ReleaseMode)<br></code></pre></td></tr></table></figure><h2 id="修改log的显示"><a href="#修改log的显示" class="headerlink" title="修改log的显示"></a>修改log的显示</h2><p>默认显示如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[GIN] <span class="hljs-number">2023</span>/<span class="hljs-number">02</span>/<span class="hljs-number">05</span> - <span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">36</span> | <span class="hljs-number">200</span> |       <span class="hljs-number">375.5</span>µs |             ::<span class="hljs-number">1</span> | POST     <span class="hljs-string">&quot;/&quot;</span><br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">router := gin.New()<br>router.Use(gin.LoggerWithFormatter(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(params gin.LogFormatterParams)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;[CZH] %s |%d| %s %s\n&quot;</span>,<br>params.TimeStamp.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>),<br>params.StatusCode,<br>params.MethodColor() + params.Method + params.ResetColor(),<br>params.Path,<br>)<br>&#125;), gin.Recovery())<br></code></pre></td></tr></table></figure><h1 id="Gin中的Cookie"><a href="#Gin中的Cookie" class="headerlink" title="Gin中的Cookie"></a>Gin中的Cookie</h1><h2 id="Cookie介绍"><a href="#Cookie介绍" class="headerlink" title="Cookie介绍"></a>Cookie介绍</h2><ul><li>Http是无状态协议。简单地说，当浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次访问，都是没有任何关系的，如果要实现多个页面之间共享数据的话我们就可以使用cookie或者session实现。</li><li>cookie是存储与访问者计算机的浏览器中，可以让我们用同一个浏览器访问同一个域名的时候共享数据。</li></ul><h2 id="Cookie能实现的功能"><a href="#Cookie能实现的功能" class="headerlink" title="Cookie能实现的功能"></a>Cookie能实现的功能</h2><ol><li>保持用户登录状态</li><li>保存用户浏览的历史记录</li><li>电商网站的加入购物车</li></ol><h2 id="设置和获取Cookie"><a href="#设置和获取Cookie" class="headerlink" title="设置和获取Cookie"></a>设置和获取Cookie</h2><p><a href="https://gin-gonic.com/zh-cn/docs/examples/cookie/">设置和获取 Cookie | Gin Web Framework (gin-gonic.com)</a></p><h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><p>c.SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool)</p><ul><li>第一个参数：key</li><li>第二个参数：value</li><li>第三个参数：过期时间，如果只想设置Cookie的保存路径而不想设置存活时间，可以在第三个参数中传递nil</li><li>第四个参数：cookie的路径</li><li>第五个参数：cookie的路径Domain作用域，本地调试配置成localhost，正式上线配置成域名</li><li>第六个参数：当secure为true时，cookie在http中是无效的，在https中才有效。</li><li>第七个参数：httpOnly是微软对Cookie做的扩展。如果在cookie中设置了“httpOnly”属性，则通过程序（JS脚本、applet等）将无法读取到Cookie信息，防止XSS攻击。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    router := gin.Default()<br><br>    router.GET(<span class="hljs-string">&quot;/cookie&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><br>        cookie, err := c.Cookie(<span class="hljs-string">&quot;gin_cookie&quot;</span>)<br><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            cookie = <span class="hljs-string">&quot;NotSet&quot;</span><br>            c.SetCookie(<span class="hljs-string">&quot;gin_cookie&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)<br>        &#125;<br><br>        fmt.Printf(<span class="hljs-string">&quot;Cookie value: %s \n&quot;</span>, cookie)<br>    &#125;)<br><br>    router.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><p>cookie, err :&#x3D; c.Cookie(“name”)</p><h3 id="多个二级域名共享cookie"><a href="#多个二级域名共享cookie" class="headerlink" title="多个二级域名共享cookie"></a>多个二级域名共享cookie</h3><p>用户在a.xxx.com中设置cookie信息后在b.xxx.com中获取刚才设置的cookie，实现多个二级域名共享cookie。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c.SetCookie(<span class="hljs-string">&quot;gin_cookie&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;.xxx.com&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)<span class="hljs-comment">//把域名配置成.xxx.com</span><br></code></pre></td></tr></table></figure><h1 id="Gin中的Session"><a href="#Gin中的Session" class="headerlink" title="Gin中的Session"></a>Gin中的Session</h1><h2 id="Session简单介绍"><a href="#Session简单介绍" class="headerlink" title="Session简单介绍"></a>Session简单介绍</h2><p>session是另一种记录客户状态的机制，不同的是cookie保存在客户端浏览器中，而session保存在服务器上。</p><h2 id="Session的工作流程"><a href="#Session的工作流程" class="headerlink" title="Session的工作流程"></a>Session的工作流程</h2><p>当客户端浏览器第一次访问服务器并发送请求时，服务器端会创建一个session对象，生成一个类似key，value的键值对，然后将value保存到服务器，将key（cookie）返回到浏览器端。浏览器下次访问时会携带key（cookie），找到对应的session（value）。</p><h2 id="Gin中使用session"><a href="#Gin中使用session" class="headerlink" title="Gin中使用session"></a>Gin中使用session</h2><p>Gin官方没有提供Session相关文档，可以使用第三方的Session中间件来实现。</p><p><a href="https://github.com/gin-contrib/sessions">https://github.com/gin-contrib/sessions</a></p><p>gin-contrib&#x2F;sessions中间件支持的存储引擎：</p><ul><li>cookie</li><li>memstore</li><li>redis</li><li>memcached</li><li>mongodb</li></ul><p>基于cookie</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;github.com/gin-contrib/sessions&quot;</span><br>  <span class="hljs-string">&quot;github.com/gin-contrib/sessions/cookie&quot;</span><br>  <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  r := gin.Default()<br>    <span class="hljs-comment">//创建基于cookie的存储引擎，secret参数是用于加密的密钥</span><br>  store := cookie.NewStore([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;secret&quot;</span>))<br>    <span class="hljs-comment">//配置session的中间件，store是创建的存储引擎</span><br>  r.Use(sessions.Sessions(<span class="hljs-string">&quot;mysession&quot;</span>, store))<br><br>  r.GET(<span class="hljs-string">&quot;/incr&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>      <span class="hljs-comment">//设置session</span><br>    session := sessions.Default(c)<br>    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br>    v := session.Get(<span class="hljs-string">&quot;count&quot;</span>)<br>    <span class="hljs-keyword">if</span> v == <span class="hljs-literal">nil</span> &#123;<br>      count = <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      count = v.(<span class="hljs-type">int</span>)<br>      count++<br>    &#125;<br>    session.Set(<span class="hljs-string">&quot;count&quot;</span>, count)<br>    session.Save()<br>    c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;count&quot;</span>: count&#125;)<br>  &#125;)<br>  r.Run(<span class="hljs-string">&quot;:8000&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>基于redis（session存储在redis）</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  r := gin.Default()<br>  store, _ := redis.NewStore(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:6379&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;secret&quot;</span>))<br>  r.Use(sessions.Sessions(<span class="hljs-string">&quot;mysession&quot;</span>, store))<br><br>  r.GET(<span class="hljs-string">&quot;/incr&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    session := sessions.Default(c)<br>    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br>    v := session.Get(<span class="hljs-string">&quot;count&quot;</span>)<br>    <span class="hljs-keyword">if</span> v == <span class="hljs-literal">nil</span> &#123;<br>      count = <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      count = v.(<span class="hljs-type">int</span>)<br>      count++<br>    &#125;<br>    session.Set(<span class="hljs-string">&quot;count&quot;</span>, count)<br>      <span class="hljs-comment">//保存session</span><br>    session.Save()<br>    c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;count&quot;</span>: count&#125;)<br>  &#125;)<br>  r.Run(<span class="hljs-string">&quot;:8000&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="logrus日志框架"><a href="#logrus日志框架" class="headerlink" title="logrus日志框架"></a>logrus日志框架</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/sirupsen/logrus<br></code></pre></td></tr></table></figure><h2 id="logrus常用方法"><a href="#logrus常用方法" class="headerlink" title="logrus常用方法"></a>logrus常用方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><span class="hljs-comment">//设置日志级别</span><br>logrus.SetLevel(logrus.DebugLevel)<br>logrus.Error(<span class="hljs-string">&quot;出错了&quot;</span>)<br>logrus.Warning(<span class="hljs-string">&quot;警告&quot;</span>)<br>logrus.Info(<span class="hljs-string">&quot;信息&quot;</span>)<br>logrus.Debug(<span class="hljs-string">&quot;debug&quot;</span>)<br>logrus.Println(<span class="hljs-string">&quot;打印&quot;</span>)<br><br><span class="hljs-comment">//日志等级</span><br>fmt.Println(logrus.GetLevel())<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">debug</span><br><span class="hljs-attribute">time</span>=<span class="hljs-string">&quot;2023-02-05T21:12:45+08:00&quot;</span> <span class="hljs-attribute">level</span>=error <span class="hljs-attribute">msg</span>=<span class="hljs-string">&quot;出错了&quot;</span><br><span class="hljs-attribute">time</span>=<span class="hljs-string">&quot;2023-02-05T21:12:45+08:00&quot;</span> <span class="hljs-attribute">level</span>=warning <span class="hljs-attribute">msg</span>=<span class="hljs-string">&quot;警告&quot;</span><br><span class="hljs-attribute">time</span>=<span class="hljs-string">&quot;2023-02-05T21:12:45+08:00&quot;</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">&quot;信息&quot;</span><br><span class="hljs-attribute">time</span>=<span class="hljs-string">&quot;2023-02-05T21:12:45+08:00&quot;</span> <span class="hljs-attribute">level</span>=debug <span class="hljs-attribute">msg</span>=debug<br><span class="hljs-attribute">time</span>=<span class="hljs-string">&quot;2023-02-05T21:12:45+08:00&quot;</span> <span class="hljs-attribute">level</span>=info <span class="hljs-attribute">msg</span>=<span class="hljs-string">&quot;打印&quot;</span><br></code></pre></td></tr></table></figure><p>日志等级</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// PanicLevel level, highest level of severity. Logs and then calls panic with the</span><br><span class="hljs-comment">// message passed to Debug, Info, ...</span><br>PanicLevel Level = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 会抛一个异常</span><br><span class="hljs-comment">// FatalLevel level. Logs and then calls `logger.Exit(1)`. It will exit even if the</span><br><span class="hljs-comment">// logging level is set to Panic.</span><br>FatalLevel<span class="hljs-comment">//打印日志后就会退出</span><br><span class="hljs-comment">// ErrorLevel level. Logs. Used for errors that should definitely be noted.</span><br><span class="hljs-comment">// Commonly used for hooks to send errors to an error tracking service.</span><br>ErrorLevel<br><span class="hljs-comment">// WarnLevel level. Non-critical entries that deserve eyes.</span><br>WarnLevel<br><span class="hljs-comment">// InfoLevel level. General operational entries about what&#x27;s going on inside the</span><br><span class="hljs-comment">// application.</span><br>InfoLevel<br><span class="hljs-comment">// DebugLevel level. Usually only enabled when debugging. Very verbose logging.</span><br>DebugLevel<br><span class="hljs-comment">// TraceLevel level. Designates finer-grained informational events than the Debug.</span><br>TraceLevel<span class="hljs-comment">//低级别</span><br>)<br></code></pre></td></tr></table></figure><h2 id="更改日志级别"><a href="#更改日志级别" class="headerlink" title="更改日志级别"></a>更改日志级别</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">logrus.SetLevel(logrus.DebugLevel)<br></code></pre></td></tr></table></figure><h2 id="设置特定字段"><a href="#设置特定字段" class="headerlink" title="设置特定字段"></a>设置特定字段</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">log := logrus.WithField(<span class="hljs-string">&quot;app&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>).WithField(<span class="hljs-string">&quot;service&quot;</span>, <span class="hljs-string">&quot;logrus&quot;</span>)<br>log = logrus.WithFields(logrus.Fields&#123;<br><span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;czh&quot;</span>,<br>&#125;)<br><br>log.Errorf(<span class="hljs-string">&quot;你好&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="显示样式Text和Json"><a href="#显示样式Text和Json" class="headerlink" title="显示样式Text和Json"></a>显示样式Text和Json</h2><p>默认的是以text的形式展示，也可以设置为json</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">logrus.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)<br>log := logrus.WithField(<span class="hljs-string">&quot;app&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>).WithField(<span class="hljs-string">&quot;service&quot;</span>, <span class="hljs-string">&quot;logrus&quot;</span>)<br>log.Errorf(<span class="hljs-string">&quot;你好&quot;</span>)<br><span class="hljs-comment">//&#123;&quot;app&quot;:&quot;study&quot;,&quot;level&quot;:&quot;error&quot;,&quot;msg&quot;:&quot;你好&quot;,&quot;service&quot;:&quot;logrus&quot;,&quot;time&quot;:&quot;2023-02-05T21:32:22+08:00&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h2><p>如果我们想要在控制中显示颜色，一般的做法都是使用ANSI控制码，用于设置文本颜色。\033是控制码的开始，是八进制数字，[31m表示将文明设置为红色。ANSI控制码是用于在终端和控制台中控制文本格式和颜色的一种标准。它们通常用于在命令行界面（CLI）程序中输出彩色文本或者在文本模式下的图形界面（GUI）中输出文本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//前景色</span><br>fmt.Println(<span class="hljs-string">&quot;\033[30m 黑色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[31m 红色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[32m 绿色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[33m 黄色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[34m 蓝色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[35m 紫色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[36m 青色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[37m 灰色 \033[0m&quot;</span>)<br><br><span class="hljs-comment">//背景色</span><br>fmt.Println(<span class="hljs-string">&quot;\033[40m 黑色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[41m 红色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[42m 绿色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[43m 黄色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[44m 蓝色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[45m 紫色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[46m 青色 \033[0m&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;\033[47m 灰色 \033[0m&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>logrus支持颜色输出，在配置中去进行开启</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">logrus.SetFormatter(&amp;logrus.TextFormatter&#123;<br>    ForceColors: <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>还有一些其他配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ForceColors:是否强制使用颜色输出<br>DisableColors:是否禁用颜色输出<br>ForceQuote:是否强制引用所有值<br>DisableQuote:是否禁用引用所有值<br>DisableTimestamp:是否禁用时间戳记录<br>FullTimestamp:是否在连接到TTY时输出完成的时间戳<br>TimestampFormat:用于输出完整时间戳的时间戳格式<br></code></pre></td></tr></table></figure><h1 id="Gin中使用GORM操作mysql数据库"><a href="#Gin中使用GORM操作mysql数据库" class="headerlink" title="Gin中使用GORM操作mysql数据库"></a>Gin中使用GORM操作mysql数据库</h1><p>gorm官方支持的数据库类型有：Mysql，PostgreSQL，SQlite，SQL Server</p><p><a href="https://gorm.io/zh_CN/docs/index.html">GORM 指南 | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></p><p>在实际项目中定义数据库模型注意以下几点：</p><p>1.结构体的名称必须首字母大写，并和数据库表名称对应。例如：表名称为user的结构体名称定义成User，表名称为article_cate结构体名称定义成ArticleCate</p><p>2.结构体中的字段名称首字母必须大写，并和数据库表中的字段一一对应。例如结构体中的Id和数据库中的id对应，Username和数据库中的username对应，Age和数据库中的age对应，Email和数据库中的email对应，AddTime和数据库中的add_time字段对应。</p><p>3.默认情况表名是结构体名称的复数形式。如果我们的结构体名称定义成User，表示这个模型默认操作的是users表。</p><p>4.可以使用结构体中的自定义方法TableName改变结构体的默认表名称，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(User)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><a href="https://gorm.io/zh_CN/docs/query.html">查询 | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p><a href="https://gorm.io/zh_CN/docs/update.html">更新 | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h1 id="微服务架构和微服务"><a href="#微服务架构和微服务" class="headerlink" title="微服务架构和微服务"></a>微服务架构和微服务</h1><p>微服务架构：微服务架构是一种具体的设计实现或者设计方案，是将复杂的系统使用组件化的方式进行拆分，并使用轻量级通讯方式进行整合的一种设计方法。</p><p>微服务：微服务是微服务架构具体的实现方案，是通过微服务架构设计方法拆分出来的一个独立的组件化的小应用。</p><h2 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a>RPC调用</h2><p>服务端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义一个远程调用的方法</span><br><span class="hljs-keyword">type</span> Hello <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">1.方法只能有两个可序列化的参数，其中第二个参数是指针类型</span><br><span class="hljs-comment">req 表示获取客户端传过来的数据</span><br><span class="hljs-comment">res 表示客户端返回数据</span><br><span class="hljs-comment">2.方法要返回一个error类型，同时必须是公开的方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Go中的类型比如：channel（通道）、complex（复数类型）、func（函数）均不能进行序列化，因此req和res不能是上述类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Hello)</span></span> SayHello(req <span class="hljs-type">string</span>, res *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>fmt.Println(req)<br>*res = <span class="hljs-string">&quot;你好&quot;</span> + req<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>fmt.Println(<span class="hljs-string">&quot;你好 server&quot;</span>)<br><span class="hljs-comment">//1.注册rpc服务</span><br>err1 := rpc.RegisterName(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-built_in">new</span>(Hello))<br><span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err1)<br>&#125;<br><br><span class="hljs-comment">//2.监听端口</span><br>listener, err2 := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>)<br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err2)<br>&#125;<br><br><span class="hljs-comment">//3.应用退出的时候关闭监听端口</span><br><span class="hljs-keyword">defer</span> listener.Close()<br><br><span class="hljs-keyword">for</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;开始建立连接&quot;</span>)<br><span class="hljs-comment">//4.建立连接</span><br>conn, err3 := listener.Accept()<br><br><span class="hljs-keyword">if</span> err3 != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err3)<br>&#125;<br><br><span class="hljs-comment">//5.绑定服务</span><br>rpc.ServeConn(conn)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client&quot;</span>)<br><span class="hljs-comment">//1.用rpc连接服务器 --Dial()</span><br>conn, err1 := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>)<br><span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err1)<br>&#125;<br><span class="hljs-comment">//2.当客户端退出的时候关闭连接</span><br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">//3.调用远程函数</span><br><span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br>err2 := conn.Call(<span class="hljs-string">&quot;hello.SayHello&quot;</span>, <span class="hljs-string">&quot;我是客户端&quot;</span>, &amp;reply)<br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err2)<br>&#125;<br><span class="hljs-comment">//4.获取微服务返回的数据</span><br>fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="net-x2F-rpc-x2F-jsonrpc库以及RPC跨语言"><a href="#net-x2F-rpc-x2F-jsonrpc库以及RPC跨语言" class="headerlink" title="net&#x2F;rpc&#x2F;jsonrpc库以及RPC跨语言"></a>net&#x2F;rpc&#x2F;jsonrpc库以及RPC跨语言</h2><p>标准库的RPC默认采用Go语言特有的gob编码，没法实现跨语言调用。golang官方还提供了<code>net/rpc/jsonrpc</code>库实现RPC方法，JSON RPC采用JSON进行数据编解码，因此支持跨语言调用。但目前的jsonrpc库是基于tcp协议实现的，暂不支持使用http进行数据传输。</p><h2 id="Linux命令之nc创建tcp服务测试数据传输"><a href="#Linux命令之nc创建tcp服务测试数据传输" class="headerlink" title="Linux命令之nc创建tcp服务测试数据传输"></a>Linux命令之nc创建tcp服务测试数据传输</h2><p>nc是netcat的简写，是一个功能强大的网络工具，有着网络界的瑞士军刀美誉</p><p>nc命令的主要作用如下：</p><ul><li>实现任意TCP&#x2F;UDP端口的监听，nc可以作为server以TCP或UDP方式监听指定端口</li><li>端口的扫描，nc可以作为client发起TCP或UDP连接</li><li>机器之间传输文件</li><li>机器之间网络测速</li></ul><p>centos中如果找不到nc命令可以使用<code>yum install -y nc</code>安装</p><p>使用nc作为微服务server端接收客户端数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">nc -l <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.135</span> <span class="hljs-number">8001</span><br></code></pre></td></tr></table></figure><p>使用<code>net/rpc/jsonrpc</code>库中的rpc.ServeCodec函数替代rpc.ServeConn函数，传入的参数是针对服务端的json编码器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//5.绑定服务</span><br><span class="hljs-comment">//rpc.ServeConn(conn)</span><br><br><span class="hljs-comment">//服务端</span><br>rpc.ServeCodec(jsonrpc.NewServerCodec(conn))<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//客户端</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client&quot;</span>)<br><span class="hljs-comment">//1.用rpc连接服务器 --Dial()</span><br><span class="hljs-comment">//conn, err1 := rpc.Dial(&quot;tcp&quot;, &quot;192.168.80.135:8001&quot;)</span><br>    <br>    <span class="hljs-comment">//1.用net.Dial和rpc微服务建立连接</span><br>conn, err1 := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;192.168.80.135:8001&quot;</span>)<br><span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err1)<br>&#125;<br><span class="hljs-comment">//2.当客户端退出的时候关闭连接</span><br><span class="hljs-keyword">defer</span> conn.Close()<br><br>client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))<br><br><span class="hljs-comment">//3.调用远程函数</span><br><span class="hljs-keyword">var</span> reply <span class="hljs-type">string</span><br><span class="hljs-comment">//err2 := conn.Call(&quot;hello.SayHello&quot;, &quot;我是客户端&quot;, &amp;reply)</span><br>err2 := client.Call(<span class="hljs-string">&quot;hello.SayHello&quot;</span>, <span class="hljs-string">&quot;我是客户端&quot;</span>, &amp;reply)<br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err2)<br>&#125;<br><span class="hljs-comment">//4.获取微服务返回的数据</span><br>fmt.Println(reply)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ProtoBuf认识与使用"><a href="#ProtoBuf认识与使用" class="headerlink" title="ProtoBuf认识与使用"></a>ProtoBuf认识与使用</h2><h3 id="protobuf简介"><a href="#protobuf简介" class="headerlink" title="protobuf简介"></a>protobuf简介</h3><p>Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做<strong>数据存储</strong>或<strong>RPC数据交换格式</strong>。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化数据格式。是一种灵活，高效，自动化的机制，用于序列化结构化数据，对比于XML和JSON，它更小、更快、更简单。</p><p>Protobuf刚开源时的定位类似于XML、JSON等数据描述语言，通过附带工具生成代码并实现将结构化数据序列化的功能。这里我们更关注的是Protobuf作为接口规范的描述语言，可以作为设计安全的跨语言RPC接口的基础工具。</p><p>protobuf的优势和劣势：</p><p>优势：</p><ol><li>序列化后体积相比json和xml很小，适合网络传输</li><li>支持跨平台多语言</li><li>消息格式升级和兼容性很好</li><li>序列化和反序列化速度很快，快于json的处理速度</li></ol><p>劣势：</p><ol><li>应用不够广（相比xml和json）</li><li>二进制格式导致可读性差</li><li>缺乏自描述</li></ol><h3 id="protobuf安装"><a href="#protobuf安装" class="headerlink" title="protobuf安装"></a>protobuf安装</h3><p><a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers&#x2F;protobuf · GitHub</a></p><p>windows系统选择win64.zip，解压后将bin目录放入系统环境变量Path</p><p>查看版本： <code>protoc --version</code></p><p>protobuf的go语言插件protoc-gen-go插件</p><p><code>go install github.com/golang/protobuf/protoc-gen-go@latest</code></p><h3 id="protobuf简单语法"><a href="#protobuf简单语法" class="headerlink" title="protobuf简单语法"></a>protobuf简单语法</h3><p><a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-comment">//指定版本信息，不指定会报错，默认是proto2</span><br>option_go_package = <span class="hljs-string">&quot;./proto;helloworld&quot;</span>;<span class="hljs-comment">//分号前面的表明go文件生成到哪个目录（相对当前目录），分号后面表示生成go文件的包名（可以省略，省略后包名与分号前面所写的目录名相同）</span><br><span class="hljs-comment">//message定义一种消息类型，关键字message定义结构，并且结构中可以嵌套定义结构，message定义的内容和生成一个结构体</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-comment">//名字</span><br><span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<span class="hljs-comment">//1为编号，表示处于第1位，不能重复</span><br><span class="hljs-comment">//年龄</span><br><span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//爱好</span><br><span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> hobby = <span class="hljs-number">3</span>;<span class="hljs-comment">//数组 golang中会生成string类型的切片</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="protobuf高级用法"><a href="#protobuf高级用法" class="headerlink" title="protobuf高级用法"></a>protobuf高级用法</h3><h4 id="message嵌套"><a href="#message嵌套" class="headerlink" title="message嵌套"></a>message嵌套</h4><p>message除了能放简单数据类型外，还能存放另外的message类型：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Order</span>&#123;<br>  <span class="hljs-type">int64</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">double</span> price = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> name = <span class="hljs-number">3</span>;<br>  <span class="hljs-type">string</span> tel = <span class="hljs-number">4</span>;<br>  <span class="hljs-type">string</span> address = <span class="hljs-number">5</span>;<br>  <span class="hljs-type">string</span> addTime = <span class="hljs-number">6</span>;<br>  <span class="hljs-comment">//message可以嵌套</span><br><span class="hljs-comment">//  message OrderItem&#123;</span><br><span class="hljs-comment">//    int64 goodsId = 1;</span><br><span class="hljs-comment">//    string title = 2;</span><br><span class="hljs-comment">//    double price = 3;</span><br><span class="hljs-comment">//    int32 num = 4;</span><br><span class="hljs-comment">//  &#125;</span><br>  OrderItem orderItem = <span class="hljs-number">7</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">OrderItem</span>&#123;<br>  <span class="hljs-type">int64</span> goodsId = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">double</span> price = <span class="hljs-number">3</span>;<br>  <span class="hljs-type">int32</span> num = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="repeated关键字"><a href="#repeated关键字" class="headerlink" title="repeated关键字"></a>repeated关键字</h4><p>repeated关键字在go语言中相当于切片</p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解析数据时，如果编码的消息不包含特定的单数元素，则解析对象中的相应字段将设置为该字段的默认值。不同类型的默认值不同，如下：</p><ul><li>对于字符串，默认值为空字符串</li><li>对于字节，默认值为空字节</li><li>对于bools，默认值为false</li><li>对于数字类型，默认值为0</li><li>对于枚举，默认值是第一个定义的枚举值，该值必须为0</li><li>repeated字段默认值是空列表</li><li>message字段的默认值为空对象</li></ul><h4 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">PhoneType</span> &#123;<br>  MOBILE = <span class="hljs-number">0</span>;<br>  HOME = <span class="hljs-number">1</span>;<br>  WORK = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定义RPC服务"><a href="#定义RPC服务" class="headerlink" title="定义RPC服务"></a>定义RPC服务</h4><p>如果需要将message与RPC一起使用，则可以在.proto文件中定义RPC服务接口，protobuf编译器将根据选择的语言生成RPC代码接口，示例如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">//定义service服务</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">goodsService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> AddGoods(AddGoodsReq) <span class="hljs-keyword">returns</span> (AddGoodsRes)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">AddGoodsReq</span>&#123;<br>  <span class="hljs-type">string</span> title = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">double</span> price = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> content = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">AddGoodsRes</span>&#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">bool</span> success = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：<code>protoc --go_out=plugins=grpc:./ */proto</code></p><h3 id="protobuf基本编译"><a href="#protobuf基本编译" class="headerlink" title="protobuf基本编译"></a>protobuf基本编译</h3><p>protobuf编译是通过编译器protoc进行的，通过这个编译器，我们可以把.proto文件生成go、Java、Python、C++、Ruby、JavaNano、Objective-C或者C#代码，生成命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --proto_path=IMPORT_PATH --go_out=DST path/to/file.proto<br></code></pre></td></tr></table></figure><ol><li>–proto_path&#x3D;IMPORT_PATH,IMPORT_PATH是.proto文件所在的路径，如果忽略则默认当前目录。如果有多个目录则可以多次调用–proto_path，它们将会顺序得被访问并执行导入。</li><li>–go_out&#x3D;DST_DIR，指定了生成go语言代码文件放入的文件夹。</li><li>允许使用<code>protoc --go_out=./ *.proto</code>的方式一次性编译多个.proto文件。</li><li>go语言编译时，protobuf编译器会把.proto文件编译成.pd.go文件</li></ol><h3 id="protobuf序列化反序列化"><a href="#protobuf序列化反序列化" class="headerlink" title="protobuf序列化反序列化"></a>protobuf序列化反序列化</h3><p>序列化：<code>protobuf.Marshal()</code></p><p>反序列化：<code>protobuf.Unmarshal()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>userinfo := userService.Userinfo&#123;<br>Username: <span class="hljs-string">&quot;czh&quot;</span>,<br>Age:      <span class="hljs-number">23</span>,<br>Hobby:    []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;唱&quot;</span>, <span class="hljs-string">&quot;跳&quot;</span>, <span class="hljs-string">&quot;rap&quot;</span>, <span class="hljs-string">&quot;篮球&quot;</span>&#125;,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, userinfo)<br><br>bytes, _ := proto.Marshal(&amp;userinfo)<br>fmt.Println(bytes)<br><br>user := userService.Userinfo&#123;&#125;<br>proto.Unmarshal(bytes, &amp;user)<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, user)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="GRPC框架"><a href="#GRPC框架" class="headerlink" title="GRPC框架"></a>GRPC框架</h2><p>GRPC框架是Google公司基于Protobuf开发的跨语言的开源RPC框架。它是一个高性能、开源和通用的RPC框架，基于HTTP&#x2F;2协议设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等待，对于移动设备更加友好，更省电和节省空间占用。目前提供C、Java和Go语言版本，分别是：grpc，grpc-java，grpc-go。其中C版本支持C++，Node.js，Python，Ruby，Objective-C，PHP和C#支持。</p><p>GRPC特点：</p><ol><li>提供几乎所有主流语言的实现，打破语言隔阂。</li><li>基于HTTP&#x2F;2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多路复用请求等待。</li><li>默认使用Protocol Buffers序列化，性能相较于RESTFUL json好很多</li><li>工具链成熟，代码生成便捷，开箱即用。</li><li>支持双向流式的请求和响应，对批量处理、低延时场景友好。</li></ol><p>这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p><p>有了grpc，我们可以一次性地在一个.proto文件中定义服务并使用任何支持它的语法去实现客户端和服务器，grpc默认使用protocol buffers，它是google开源的一套成熟的结构数据序列化机制（也可以使用其他数据格式如json），可以用proto files创建grpc服务，用protocol buffers消息类型来定义方法参数和返回类型。</p><p>在grpc客户端可以直接调用不同服务器上的远程程序，就像调用本地程序一样，很容易构建分布式应用和服务。和很多rpc系统一样，服务负责实现定义好的接口并处理客户端请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用grpc支持不同语言实现。</p><p>proto代码</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./greeter&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello(HelloReq) <span class="hljs-keyword">returns</span> (HelloRes)</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloReq</span>&#123;<br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRes</span>&#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>protoc --go_out=plugins=grpc:./ */proto</code>生成go代码</p><p>服务端代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//1.定义远程调用的结构体和方法，这个结构体需要实现GreaterServer的接口</span><br><span class="hljs-keyword">type</span> Hello <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Hello)</span></span> SayHello(c context.Context, req *greeter.HelloReq) (*greeter.HelloRes, <span class="hljs-type">error</span>)  &#123;<br><span class="hljs-keyword">return</span> &amp;greeter.HelloRes&#123;<br>Message: <span class="hljs-string">&quot;你好&quot;</span> + req.GetName(),<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><span class="hljs-comment">//1.初始化grpc对象</span><br>grpcServer := grpc.NewServer()<br><span class="hljs-comment">//2.注册服务</span><br>greeter.RegisterGreeterServer(grpcServer, &amp;Hello&#123;&#125;)<br><span class="hljs-comment">//3.设置监听</span><br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><span class="hljs-comment">//4.退出监听</span><br><span class="hljs-keyword">defer</span> listener.Close()<br><span class="hljs-comment">//5.启动服务</span><br>grpcServer.Serve(listener)<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><span class="hljs-comment">//1.连接服务端</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">credential.NewClientTLSFromFile:从输入的证书文件中为客户端构造TLS凭证。</span><br><span class="hljs-comment">grpc.WithTransportCredentials:配置连接级别的安全凭证（例如，TLS/SSL），返回一个DialOption，用于连接服务器</span><br><span class="hljs-comment">*/</span><br>grpcClient, err := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><span class="hljs-comment">//2.注册客户端</span><br>client := greeter.NewGreeterClient(grpcClient)<br>    <span class="hljs-comment">//3.调用服务</span><br>res, err := client.SayHello(context.Background(), &amp;greeter.HelloReq&#123;Name: <span class="hljs-string">&quot;czh&quot;</span>&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;%#v %T\n&quot;</span>, res, res)<br>fmt.Println(res.Message)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go-micro框架"><a href="#go-micro框架" class="headerlink" title="go-micro框架"></a>go-micro框架</h2><p>Go Micro是一个简化分布式开发的微服务生态系统，该系统为开发分布式应用程序提供了高效，便捷的模块构建，主要目的是简化分布式系统的开发。它默认实现了consul作为服务发现（2019年源码修改了默认使用mdns），通过http进行通信，通过protobuf和json进行编码。</p><p>学习完该框架以后，可以方便开发者们非常简单地开发出微服务架构的项目，并且随着业务模块的增加和功能的增加，Go Micro还能够提供管理微服务环境的工具和功能。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang</title>
    <link href="/2023/01/27/Golang/"/>
    <url>/2023/01/27/Golang/</url>
    
    <content type="html"><![CDATA[<p>Golang</p><h1 id="Go语言基本语法"><a href="#Go语言基本语法" class="headerlink" title="Go语言基本语法"></a>Go语言基本语法</h1><h2 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h2><p>在Go程序中，一行就代表一个语句的结束，无需使用“;”结尾，如果打算将多个语句写在同一行，则需要使用”;”人为区分（不鼓励这种写法）</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释：&#x2F;&#x2F;</p><p>多行注释：&#x2F;*   *&#x2F;</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>一个标识符是一个或是多个字母（A-Za-z）数字（0-9）、下划线_组成的序列，但是***<u>第一个字符必须是字母或下划线</u>***而不能是数字。</p><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>go语言的字符串连接可以通过“+”实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>go代码中会使用到的25个关键字或保留字</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>Go语言中使用<code>fmt.Sprintf</code>或<code>fmt.Printf</code>格式化字符串并赋值给新串：</p><ul><li><strong>Sprintf</strong> 根据格式化参数生成格式化的字符串并返回该字符串。</li><li><strong>Printf</strong> 根据格式化参数生成格式化的字符串并写入标准输出。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> code = <span class="hljs-number">123</span><br><span class="hljs-keyword">var</span> enddate = <span class="hljs-string">&quot;2022-12-31&quot;</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;Code=%d&amp;endDate=%s&quot;</span><br><span class="hljs-comment">//fmt.Println(&quot;hello&quot; + &quot;world&quot;)</span><br>fmt.Printf(url, code, enddate)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h1><p>go语言中数据类型分为：<strong>基本数据类型</strong>和<strong>复合数据类型</strong></p><p>基本数据类型有：</p><p>整型、浮点型、布尔型、字符串</p><p>复合数据类型有：</p><p>数组、切片、结构体、函数、map、通道（channel）、接口等。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为一下两大类：<br>有符号整型按长度分为：int8、int16、int32、int64</p><p>对应的无符号整型：uint8、uint16、uint32、uint64</p><p>unsafe.Sizeof()查看变量占用空间</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>go语言支持两种浮点型数据：float32和float64，这两种浮点型数据格式遵循IEEE754标准：float32的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。float64的浮点数的最大范围约为1.8e308，可以使用一个常量定义：math.MaxFloat64</p><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>布尔型的值只可以是常量true或者false。var b bool &#x3D; true</p><ol><li>布尔类型变量的默认值为false</li><li>go语言中不允许将整型强制转换为布尔类型。</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</p><p>go语言中的字符串以基本数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64等）一样。</p><p><strong>string类型无法通过<code>unsafe.Sizeof()</code>得到存储空间大小，因为string底层使用的是结构体和指针实现，可以使用<code>len</code></strong></p><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>go语言中要定义一个多行字符串时，就必须使用反引号字符&#96;，反引号中转义字符无效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">str :=<br><span class="hljs-string">`this is str</span><br><span class="hljs-string">this is str</span><br><span class="hljs-string">this is str</span><br><span class="hljs-string">this is str</span><br><span class="hljs-string">this is str</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度（占用字节数）</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀&#x2F;后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置，查找到返回下标位置，查找不到返回-1</td></tr><tr><td>strings.Join(a []int, sep string)</td><td>join操作</td></tr></tbody></table><h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><p>组成每个字符串的元素叫做“字符”，可以通过遍历字符串元素获得字符。字符用单引号（’）包裹起来，不是基本数据类型</p><p>当我们直接输出byte（字符）的时候输出的是这个字符对应的码值</p><p>go语言的字符有以下两种：</p><ol><li>uint8类型，或者叫byte型，代表了ASCII码的一个字符</li><li>rune类型，代表一个UTF-8字符</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。</p><p>Go使用了特殊的rune类型来处理Unicode，让基于Unicode的文本处理更为方便，也可以使用byte型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    s := <span class="hljs-string">&quot;你好，golang&quot;</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<span class="hljs-comment">//byte</span><br>        fmt.Printf(<span class="hljs-string">&quot;%v(%c)&quot;</span>, s[i], s[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _,r := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-comment">//rune</span><br>        fmt.Printf(<span class="hljs-string">&quot;%v(%c)&quot;</span>, r, r)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeString</span><span class="hljs-params">()</span></span>  &#123;<br>s1 := <span class="hljs-string">&quot;big&quot;</span><br>byteS1 := []<span class="hljs-type">byte</span>(s1)<br>byteS1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;p&#x27;</span><br>fmt.Println(<span class="hljs-type">string</span>(byteS1))<br><br>s2 := <span class="hljs-string">&quot;白萝卜&quot;</span><br>runeS2 := []<span class="hljs-type">rune</span>(s2)<br>runeS2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;红&#x27;</span><br>fmt.Println(<span class="hljs-type">string</span>(runeS2))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h2><ul><li>指针类型（Pointer）</li><li>数组类型</li><li>结构体类型（struct）</li><li>Channel类型</li><li>函数类型</li><li>切片类型</li><li>接口类型（interface）</li><li>Map类型</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换用于将一种数据类型的变量转换为另一种类型的变量。Go语言类型转换基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">type_name(expression)<br><span class="hljs-comment">//type_name 为类型，expression 为表达式。</span><br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span> = <span class="hljs-number">17</span><br>   <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br>   <span class="hljs-keyword">var</span> mean <span class="hljs-type">float32</span><br>   <br>   mean = <span class="hljs-type">float32</span>(sum)/<span class="hljs-type">float32</span>(count)<br>   fmt.Printf(<span class="hljs-string">&quot;mean 的值为: %f\n&quot;</span>,mean)<br>&#125;<br></code></pre></td></tr></table></figure><p>go不支持隐式转换类型，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int64</span> = <span class="hljs-number">3</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int32</span><br>    b = a<br>    fmt.Printf(<span class="hljs-string">&quot;b 为 : %d&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>string转int、int转string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// string to int</span><br>  aStr := <span class="hljs-string">&quot;100&quot;</span><br>  bInt, err := strconv.Atoi(aStr)<br><br>  <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;aStr：%T %s，bInt：%T %d&quot;</span>, aStr, aStr, bInt, bInt)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;err：%s&quot;</span>, err)<br>  &#125;<br><br>  <span class="hljs-comment">// int to string</span><br>  cInt := <span class="hljs-number">200</span><br>  dStr := strconv.Itoa(cInt)<br><br>  fmt.Printf(<span class="hljs-string">&quot;cInt：%T %d，dStr：%T %s&quot;</span>, cInt, cInt, dStr, dStr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h3><p><em><strong><u>go语言中只有强制类型转换，没有隐式类型转换。</u></strong></em></p><p>转换的时候建议从低位转换为高位，高位转换成低位的时候如果转换不成功就会溢出。</p><h3 id="其他类型转换成String类型"><a href="#其他类型转换成String类型" class="headerlink" title="其他类型转换成String类型"></a>其他类型转换成String类型</h3><ol><li>Sprintf把其他类型转换成string类型</li></ol><p>注意：sprintf使用中需要注意转换的格式，int 为%d，float为%f，bool为%t，byte为%c</p><ol start="2"><li>使用strconv包里面的几种转换方法进行转换</li></ol><ul><li><p>整型转字符串：strconv.FormatInt(int64(i), 10)</p><ul><li>参数1：int64 的数值</li><li>参数2：传值int类型的进制</li></ul></li><li><p>浮点型转字符串：strconv.FormatFloat()</p><ul><li>参数1：要转换的值</li><li>参数2：格式化类型<ul><li>‘f’(-ddd.dddd)</li><li>‘b’(-ddddp±ddd，指数为二进制)</li><li>‘e’(-d.dddde±dd，十进制指数)</li><li>‘E’(-d.ddddE±dd，十进制指数)</li><li>‘g’(指数很大时用’e’格式，否则’f’格式)</li><li>‘G’(指数很大时用’E’格式，否则’f’格式)</li></ul></li><li>参数3：保留的小数点  -1（不对小数点格式化）</li><li>参数4：格式化的类型（32&#x2F;64）</li></ul></li><li><p>布尔型转字符：strconv.FormatBool()&#x2F;&#x2F;意义不大</p></li><li><p>字符转数值：strconv.FormatUint()</p></li><li><p>string类型转int类型：strconv.ParseInt(str, 10, 64)</p><ul><li>参数1：string数据</li><li>参数2：进制</li><li>参数3：位数32 64 16</li></ul></li><li><p>string类型转float类型：strconv.ParseFloat(str, 32)</p></li></ul><p><strong>数值类型无法和bool类型进行转换</strong></p><h2 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h2><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字。</p><p>如：num :&#x3D; 0b00011101</p><h1 id="Go语言变量"><a href="#Go语言变量" class="headerlink" title="Go语言变量"></a>Go语言变量</h1><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p><p>Go语言中变量是区分大小写的</p><p>声明变量的一般形式是使用 var 关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier <span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>可以一次声明多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">string</span> = <span class="hljs-string">&quot;czh&quot;</span><br>fmt.Println(a)<br><span class="hljs-keyword">var</span> b, c <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>fmt.Println(b, c)<br></code></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>第一种：指定变量类型，如果没有初始化，则变量默认为零值</p><ul><li>数值类型零值为0</li><li>布尔类型零值为false</li><li>字符串为“”（空字符串）</li></ul><p>第二种：根据值自行判定变量类型</p><p>第三种：如果变量已经使用var声明过了，再使用<code>:=</code>声明变量就产生编译错误。</p><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。</p><p>声明一个局部变量却没有在相同的代码块中使用它会得到编译错误，但是全局变量是允许声明但不使用的。</p><h2 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//类型相同多个变量, 非全局变量</span><br><span class="hljs-keyword">var</span> vname1, vname2, vname3 <span class="hljs-keyword">type</span><br>vname1, vname2, vname3 = v1, v2, v3<br><br><span class="hljs-keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="hljs-comment">// 和 python 很像,不需要显示声明类型，自动推断</span><br><br>vname1, vname2, vname3 := v1, v2, v3 <span class="hljs-comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span><br><br><span class="hljs-comment">// 这种因式分解关键字的写法一般用于声明全局变量</span><br><span class="hljs-keyword">var</span> (<br>    vname1 v_type1<br>    vname2 v_type2<br>)<br></code></pre></td></tr></table></figure><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>所有像int、float、bool、string这些基本类型都属于值类型，使用这些变量的类型直接指向存在内存中的值</p><h2 id="Go语言变量作用域"><a href="#Go语言变量作用域" class="headerlink" title="Go语言变量作用域"></a>Go语言变量作用域</h2><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p><p>Go语言中变量可以在三个地方声明：</p><ul><li>函数内定义的变量为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。</p><p>Go 语言程序中<strong>全局变量与局部变量名称可以相同</strong>，但是函数内的局部变量会被优先考虑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 声明全局变量 */</span><br><span class="hljs-keyword">var</span> g <span class="hljs-type">int</span> = <span class="hljs-number">20</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> g <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   fmt.Printf (<span class="hljs-string">&quot;结果： g = %d\n&quot;</span>,  g)<span class="hljs-comment">//10</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><p>形式参数会作为函数的局部变量来使用。</p><h1 id="Go语言常量"><a href="#Go语言常量" class="headerlink" title="Go语言常量"></a>Go语言常量</h1><p>常量是一个简单的标识符，在程序运行时，不会被修改的值。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> identifier [<span class="hljs-keyword">type</span>] = value<br></code></pre></td></tr></table></figure><p><em><strong><u>常量在定义的时候必须赋值。</u></strong></em></p><p>可以省略类型说明符[type]，因为编译器可以根据变量的值来推断其类型。</p><ul><li>显示类型定义：const b string &#x3D; “abc”</li><li>隐式类型定义：const b &#x3D; “abc”</li></ul><p>多个常量可以一起声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>pi = <span class="hljs-number">3.1415924</span><br>    a = <span class="hljs-string">&quot;a&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-number">100</span><br>    n2<br>    n3<br>)<br></code></pre></td></tr></table></figure><h2 id="const结合iota的使用"><a href="#const结合iota的使用" class="headerlink" title="const结合iota的使用"></a>const结合iota的使用</h2><p>iota是go语言的常量计数器，只能在常量的表达式中使用。</p><p>iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）。</p><p>1.iota只能在常量的表达式中使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-literal">iota</span>)<br>编译错误：undefined:<span class="hljs-literal">iota</span><br></code></pre></td></tr></table></figure><p>2.每次const出现时，都会让iota初始化为0（自增长）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a = <span class="hljs-literal">iota</span> <span class="hljs-comment">//a=0</span><br><span class="hljs-keyword">const</span> (<br>    b = <span class="hljs-literal">iota</span> <span class="hljs-comment">//b = 0</span><br>    c <span class="hljs-comment">//c = 1</span><br>)<br></code></pre></td></tr></table></figure><p>3.const iota使用_跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    n1 = <span class="hljs-literal">iota</span><span class="hljs-comment">//0</span><br>    _<br>    n2<span class="hljs-comment">//2</span><br>    n3<span class="hljs-comment">//3</span><br>)<br></code></pre></td></tr></table></figure><p>4.iota声明中插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>    n2 = <span class="hljs-number">100</span><span class="hljs-comment">//100</span><br>    n3 = <span class="hljs-literal">iota</span><span class="hljs-comment">//2</span><br>    n4<span class="hljs-comment">//3</span><br>)<br><span class="hljs-keyword">const</span> n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>5.多个iota定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a,b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span><br>    c,d<span class="hljs-comment">//2,3</span><br>    e,f<span class="hljs-comment">//3,4</span><br>)<br></code></pre></td></tr></table></figure><h1 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>假定A值为10，B值为20。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">相加</td><td align="left">A + B 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">相减</td><td align="left">A - B 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">相乘</td><td align="left">A * B 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">相除</td><td align="left">B &#x2F; A 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">求余</td><td align="left">B % A 输出结果 0</td></tr><tr><td align="left">++</td><td align="left">自增</td><td align="left">A++ 输出结果 11</td></tr><tr><td align="left">–</td><td align="left">自减</td><td align="left">A– 输出结果 9</td></tr></tbody></table><ol><li><p>除法注意：如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分</p></li><li><p>取余注意：余数&#x3D;被除数 - （被除数&#x2F;除数）*除数</p></li><li><p>注意：++（自增）和–（自减）在Go中是单独的语句，并不是运算符。++ 和 – 只能单独使用，不能赋值，错误写法如下：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">8</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>a = i++ <span class="hljs-comment">//错误i++只能单独使用</span><br>a = i-- <span class="hljs-comment">//错误i--只能单独使用</span><br></code></pre></td></tr></table></figure><p>注意：在golang中没有前++，错误写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>++i<span class="hljs-comment">//错误，在golang中没有前++</span><br>--i<span class="hljs-comment">//错误，在golang中没有前--</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>假定A值为10，B值为20。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False。</td><td align="left">(A &#x3D;&#x3D; B) 为 False</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td><td align="left">(A !&#x3D; B) 为 True</td></tr><tr><td align="left">&gt;</td><td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &gt; B) 为 False</td></tr><tr><td align="left">&lt;</td><td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &lt; B) 为 True</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &gt;&#x3D; B) 为 False</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &lt;&#x3D; B) 为 True</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>假定 A 值为 True，B 值为 False。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。</td><td align="left">(A &amp;&amp; B) 为 False</td></tr><tr><td align="left">||</td><td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。</td><td align="left">(A || B) 为 True</td></tr><tr><td align="left">!</td><td align="left">逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。</td><td align="left">!(A &amp;&amp; B) 为 True</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table><thead><tr><th align="left">p</th><th align="left">q</th><th align="left">p &amp; q</th><th align="left">p | q</th><th align="left">p ^ q</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr></tbody></table><p>假定 A 为60，B 为13</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td align="left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td align="left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td align="left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td><td align="left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="left">C &#x3D; A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td align="left">+&#x3D;</td><td align="left">相加后再赋值</td><td align="left">C +&#x3D; A 等于 C &#x3D; C + A</td></tr><tr><td align="left">-&#x3D;</td><td align="left">相减后再赋值</td><td align="left">C -&#x3D; A 等于 C &#x3D; C - A</td></tr><tr><td align="left">*&#x3D;</td><td align="left">相乘后再赋值</td><td align="left">C *&#x3D; A 等于 C &#x3D; C * A</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">相除后再赋值</td><td align="left">C &#x2F;&#x3D; A 等于 C &#x3D; C &#x2F; A</td></tr><tr><td align="left">%&#x3D;</td><td align="left">求余后再赋值</td><td align="left">C %&#x3D; A 等于 C &#x3D; C % A</td></tr><tr><td align="left">&lt;&lt;&#x3D;</td><td align="left">左移后赋值</td><td align="left">C &lt;&lt;&#x3D; 2 等于 C &#x3D; C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;&#x3D;</td><td align="left">右移后赋值</td><td align="left">C &gt;&gt;&#x3D; 2 等于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td align="left">&amp;&#x3D;</td><td align="left">按位与后赋值</td><td align="left">C &amp;&#x3D; 2 等于 C &#x3D; C &amp; 2</td></tr><tr><td align="left">^&#x3D;</td><td align="left">按位异或后赋值</td><td align="left">C ^&#x3D; 2 等于 C &#x3D; C ^ 2</td></tr><tr><td align="left">|&#x3D;</td><td align="left">按位或后赋值</td><td align="left">C |&#x3D; 2 等于 C &#x3D; C | 2</td></tr></tbody></table><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">返回变量存储地址</td><td align="left">&amp;a; 将给出变量的实际地址。</td></tr><tr><td align="left">*</td><td align="left">指针变量。</td><td align="left">*a; 是一个指针变量</td></tr></tbody></table><h1 id="Go语言条件语句"><a href="#Go语言条件语句" class="headerlink" title="Go语言条件语句"></a>Go语言条件语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>Go语言中if语句的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一种</span><br>age := <span class="hljs-number">30</span><br><span class="hljs-keyword">if</span> age &gt; <span class="hljs-number">20</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;成年人&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//第二种</span><br><span class="hljs-keyword">if</span> age := <span class="hljs-number">30</span>; age &gt; <span class="hljs-number">20</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;成年人&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//两种写法age的作用域不同，第二种作用域在if内</span><br></code></pre></td></tr></table></figure><h2 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h2><p>Go语言中if…else语句的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 在布尔表达式为 false 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。</p><h2 id="if语句嵌套"><a href="#if语句嵌套" class="headerlink" title="if语句嵌套"></a>if语句嵌套</h2><p>略</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。</p><p>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。</p><p>switch 默认情况下 <strong>case 最后自带 break 语句</strong>，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 <code>fallthrough</code>。</p><p>go语言中switch语句的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br>    <span class="hljs-keyword">case</span> val1:<br>        ...<br>    <span class="hljs-keyword">case</span> val2:<br>        ...<br>    <span class="hljs-keyword">default</span>:<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。</p><p>switch的另一种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> extName := <span class="hljs-string">&quot;.html&quot;</span>;extName &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.html&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;text/html&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.css&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;text/css&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.js&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;text/javascript&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;找不到此后缀&quot;</span>)<br>&#125;<br><span class="hljs-comment">//extName写switch内部或外部时的作用域不同</span><br></code></pre></td></tr></table></figure><p>switch的另一种写法：</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分割</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span><br><span class="hljs-keyword">switch</span> n &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>:<br>    fmt.Println(<span class="hljs-string">&quot;奇数&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>:<br>    fmt.Println(<span class="hljs-string">&quot;偶数&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>switch的另一种写法：</p><p>一个分支还可以使用表达式，此时switch后面不需要跟变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">age := <span class="hljs-number">20</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> age &lt; <span class="hljs-number">24</span>:<br>fmt.Println(<span class="hljs-string">&quot;好好学习&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p><h1 id="Go语言循环语句"><a href="#Go语言循环语句" class="headerlink" title="Go语言循环语句"></a>Go语言循环语句</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>go语言的for循环有3中形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//和C语言的for一样</span><br><span class="hljs-keyword">for</span> init; condition; post &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//和C的while一样</span><br><span class="hljs-keyword">for</span> condition &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//和C的for(;;)一样</span><br><span class="hljs-keyword">for</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>init：一般为赋值表达式，给控制变量赋初值；</li><li>condition：关系表达式或逻辑表达式，循环控制条件</li><li>post：一般为赋值表达式，给控制变量增量或减量</li></ul><p>for循环的range格式可以对slice、map、数组、字符串等进行迭代循环。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码中的key和value是可以省略的。</p><p>如果只想读取key，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> oldMap<br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">for</span> key,_ := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p> 如果只想读取value，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _,value := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>&#123;<br>   <span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>   &#123;<br>      statement(s);<br>   &#125;<br>   statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><ul><li>用于循环语句中跳出循环，并开始执行循环之后的语句。</li><li>break 在 switch（开关语句）中在执行一条 case 后跳出语句的作用。</li><li>在多重循环中，可以用标号 label 标出想 break 的循环。</li></ul><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>for 循环中，执行 continue 语句会触发 for 增量语句的执行。</p><p>在多重循环中，可以用标号 label 标出想 continue 的循环。</p><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>Go 语言的 goto 语句可以无条件地转移到过程中指定的行。</p><p>goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p><p>但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。</p><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">goto</span> label;<br>..<br>.<br>label: statement;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   <span class="hljs-comment">/* 循环 */</span><br>   LOOP: <span class="hljs-keyword">for</span> a &lt; <span class="hljs-number">20</span> &#123;<br>      <span class="hljs-keyword">if</span> a == <span class="hljs-number">15</span> &#123;<br>         <span class="hljs-comment">/* 跳过迭代 */</span><br>         a = a + <span class="hljs-number">1</span><br>         <span class="hljs-keyword">goto</span> LOOP<br>      &#125;<br>      fmt.Printf(<span class="hljs-string">&quot;a的值为 : %d\n&quot;</span>, a)<br>      a++    <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-literal">true</span>  &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;这是无限循环。\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go语言数组"><a href="#Go语言数组" class="headerlink" title="Go语言数组"></a>Go语言数组</h1><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variable_name [SIZE] variable_type<br></code></pre></td></tr></table></figure><p>例如以下定义了数组 balance 长度为 10 类型为 float32：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> balance [<span class="hljs-number">10</span>] <span class="hljs-type">float32</span><br></code></pre></td></tr></table></figure><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> balance = [<span class="hljs-number">5</span>]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br><br>balance := [<span class="hljs-number">5</span>]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br></code></pre></td></tr></table></figure><p>如果数组长度不确定，可以使用<code>...</code>代替数组的长度，编译器会根据元素个数自行推断数组的长度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> balance = [...]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br><span class="hljs-comment">//或</span><br>balance := [...]<span class="hljs-type">float32</span>&#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">50.0</span>&#125;<br></code></pre></td></tr></table></figure><p>如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">balance := [<span class="hljs-number">5</span>]float&#123;<span class="hljs-number">1</span>:<span class="hljs-number">2.0</span>, <span class="hljs-number">3</span>:<span class="hljs-number">7.0</span>&#125;<br></code></pre></td></tr></table></figure><p>初始化数组中<code>&#123;&#125;</code>中的元素个数不能大于<code>[]</code>中的数字。</p><p>如果忽略<code>[]</code>中的数字不设置数组的大小，go语言会根据元素的个数来设置数组的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">balance[<span class="hljs-number">4</span>] = <span class="hljs-number">50.0</span><br></code></pre></td></tr></table></figure><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>数组元素可以通过索引（位置）来读取。格式为数组后加中括号，中括号为索引的值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> salary <span class="hljs-type">float32</span> = balance[<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h3 id="go语言多维数组"><a href="#go语言多维数组" class="headerlink" title="go语言多维数组"></a>go语言多维数组</h3><p>Go 语言支持多维数组，以下为常用的多维数组声明方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type<br><br><span class="hljs-keyword">var</span> threedim [<span class="hljs-number">5</span>][<span class="hljs-number">10</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p><strong>注意：多维数组只有第一层可以使用…来让编译器推导数组长度。</strong></p><h3 id="go语言向函数传递数组"><a href="#go语言向函数传递数组" class="headerlink" title="go语言向函数传递数组"></a>go语言向函数传递数组</h3><p>如果你想向函数传递数组参数，你需要在函数定义时，声明形参为数组，我们可以通过以下两种方式来声明：</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>形参设定数组大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">void myFunction(param [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>)<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>形参未设定数组大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">void myFunction(param []<span class="hljs-type">int</span>)<br>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 数组长度为 5 */</span><br>   <span class="hljs-keyword">var</span>  balance = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br>   <span class="hljs-keyword">var</span> avg <span class="hljs-type">float32</span><br><br>   <span class="hljs-comment">/* 数组作为参数传递给函数 */</span><br>   avg = getAverage( balance, <span class="hljs-number">5</span> ) ;<br><br>   <span class="hljs-comment">/* 输出返回的平均值 */</span><br>   fmt.Printf( <span class="hljs-string">&quot;平均值为: %f &quot;</span>, avg );<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAverage</span><span class="hljs-params">(arr [5]<span class="hljs-type">int</span>, size <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float32</span> &#123;<br>   <span class="hljs-keyword">var</span> i,sum <span class="hljs-type">int</span><br>   <span class="hljs-keyword">var</span> avg <span class="hljs-type">float32</span>  <br><br>   <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; size;i++ &#123;<br>      sum += arr[i]<br>   &#125;<br><br>   avg = <span class="hljs-type">float32</span>(sum) / <span class="hljs-type">float32</span>(size)<br><br>   <span class="hljs-keyword">return</span> avg;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go语言Slice（切片）"><a href="#Go语言Slice（切片）" class="headerlink" title="Go语言Slice（切片）"></a>Go语言Slice（切片）</h1><p>Go 语言切片是对数组的抽象。</p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><p>切片是一个***<u>引用类型</u>***，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code></p><h2 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h2><p>可以声明一个未指定大小的数组来定义切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p><strong>切片不需要说明长度。</strong></p><p>或使用make()函数来创建切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">type</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>)<br><span class="hljs-comment">//或简写为</span><br>slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>)<br></code></pre></td></tr></table></figure><p>也可以指定容量，其中capacity为可选参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, length, capacity)<br></code></pre></td></tr></table></figure><p>这里len是数组的长度并且也是切片的初始长度。</p><h2 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">//直接初始化切片，[]表示是切片类型，&#123;1，2，3&#125;初始化值依次是`1,2,3`，其cap=len=3</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := arr[:]<br><span class="hljs-comment">//初始化切片 s，是数组 arr 的引用。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := arr[startIndex:endIndex]<br><span class="hljs-comment">//将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := arr[startIndex:]<br><span class="hljs-comment">//默认 endIndex 时将表示一直到arr的最后一个元素。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := arr[:endIndex]<br><span class="hljs-comment">//默认 startIndex 时将表示从 arr 的第一个元素开始。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := s[startIndex:endIndex]<br><span class="hljs-comment">//通过切片 s 初始化切片 s1。</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>)<br><span class="hljs-comment">//通过内置函数 make() 初始化切片s，[]int 标识为其元素类型为 int 的切片。</span><br></code></pre></td></tr></table></figure><h2 id="len-和cap-函数"><a href="#len-和cap-函数" class="headerlink" title="len()和cap()函数"></a>len()和cap()函数</h2><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><p><strong>切片的长度就是它所包含的元素的个数。</strong></p><p><strong>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</strong></p><h2 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h2><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> numbers []<span class="hljs-type">int</span><br><br>   printSlice(numbers)<br><br>   <span class="hljs-keyword">if</span>(numbers == <span class="hljs-literal">nil</span>)&#123;<br>      fmt.Printf(<span class="hljs-string">&quot;切片是空的&quot;</span>)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br><br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//len=0 cap=0 slice=[]</span><br><span class="hljs-comment">//切片是空的</span><br></code></pre></td></tr></table></figure><h2 id="append-和copy-函数"><a href="#append-和copy-函数" class="headerlink" title="append()和copy()函数"></a>append()和copy()函数</h2><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p><p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> numbers []<span class="hljs-type">int</span><br>   printSlice(numbers)<br><br>   <span class="hljs-comment">/* 允许追加空切片 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">0</span>)<br>   printSlice(numbers)<br><br>   <span class="hljs-comment">/* 向切片添加一个元素 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">1</span>)<br>   printSlice(numbers)<br><br>   <span class="hljs-comment">/* 同时添加多个元素 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>   printSlice(numbers)<br><br>   <span class="hljs-comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span><br>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)<br><br>   <span class="hljs-comment">/* 拷贝 numbers 的内容到 numbers1 */</span><br>   <span class="hljs-built_in">copy</span>(numbers1,numbers)<br>   printSlice(numbers1)  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-built_in">len</span>=<span class="hljs-number">0</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">0</span> slice=[]<br><span class="hljs-built_in">len</span>=<span class="hljs-number">1</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">1</span> slice=[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">len</span>=<span class="hljs-number">2</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">2</span> slice=[<span class="hljs-number">0</span> <span class="hljs-number">1</span>]<br><span class="hljs-built_in">len</span>=<span class="hljs-number">5</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">6</span> slice=[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br><span class="hljs-built_in">len</span>=<span class="hljs-number">5</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">12</span> slice=[<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>append合并切片的时候最后一个元素要加…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>&#125;<br>a = <span class="hljs-built_in">append</span>(a[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>:]...)<br><span class="hljs-comment">//删除第2个元素（32）</span><br><span class="hljs-comment">//...的作用是将切片展开，将元素当参数传入</span><br></code></pre></td></tr></table></figure><h1 id="Go语言sort排序"><a href="#Go语言sort排序" class="headerlink" title="Go语言sort排序"></a>Go语言sort排序</h1><p>对于int、float64和string数组或是切片的排序，go分别提供了sort.Ints()、sort.Float64s()和sort.Strings()函数，默认都是从小到大排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">intList := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;<br>floatList := []<span class="hljs-type">float64</span>&#123;<span class="hljs-number">4.2</span>,<span class="hljs-number">5.9</span>,<span class="hljs-number">12.4</span>,<span class="hljs-number">10.2</span>,<span class="hljs-number">50.7</span>,<span class="hljs-number">99.9</span>,<span class="hljs-number">31.4</span>,<span class="hljs-number">27.81828</span>,<span class="hljs-number">3.14</span>&#125;<br>stringList := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;<br><br>sort.Ints(intList)<br>sort.Float64s(floatList)<br>sort.Strings(stringList)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n%v\n%v\n&quot;</span>, intList, floatList, stringList)<br></code></pre></td></tr></table></figure><p>从大到小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Sort(sort.Reverse(sort.IntSlice(intList)))<br></code></pre></td></tr></table></figure><h1 id="Go语言Map（集合）"><a href="#Go语言Map（集合）" class="headerlink" title="Go语言Map（集合）"></a>Go语言Map（集合）</h1><p>Map 是一种无序的基于key-value的数据结构，Go语言中的map是***<u>引用类型</u>***，必须初始化才能使用。</p><p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p><h2 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h2><p>可以使用内建函数make也可以使用map关键字来定义Map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 声明变量，默认 map 是 nil */</span><br><span class="hljs-keyword">var</span> map_variable <span class="hljs-keyword">map</span>[key_data_type]value_data_type<br><br><span class="hljs-comment">/* 使用 make 函数 */</span><br>map_variable := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[key_data_type]value_data_type)<br></code></pre></td></tr></table></figure><p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> userinfo = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;20&quot;</span>,<br>    <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建/修改map类型的数据</span><br><span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>userinfo[<span class="hljs-string">&quot;username&quot;</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>userinfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-string">&quot;20&quot;</span><br></code></pre></td></tr></table></figure><h2 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete()函数"></a>delete()函数</h2><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。</p><p>实例：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">/* 创建map */</span><br>        countryCapitalMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;France&quot;</span>: <span class="hljs-string">&quot;Paris&quot;</span>, <span class="hljs-string">&quot;Italy&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>, <span class="hljs-string">&quot;Japan&quot;</span>: <span class="hljs-string">&quot;Tokyo&quot;</span>, <span class="hljs-string">&quot;India&quot;</span>: <span class="hljs-string">&quot;New delhi&quot;</span>&#125;<br>        fmt.Println(<span class="hljs-string">&quot;原始地图&quot;</span>)<br>        <span class="hljs-comment">/* 打印地图 */</span><br>        <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>                fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [ country ])<br>        &#125;<br>        <span class="hljs-comment">/*删除元素*/</span><br>    <span class="hljs-built_in">delete</span>(countryCapitalMap, <span class="hljs-string">&quot;France&quot;</span>)<br>        fmt.Println(<span class="hljs-string">&quot;法国条目被删除&quot;</span>)<br>        fmt.Println(<span class="hljs-string">&quot;删除元素后地图&quot;</span>)<br>        <span class="hljs-comment">/*打印地图*/</span><br>        <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>                fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [ country ])<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go语言函数"><a href="#Go语言函数" class="headerlink" title="Go语言函数"></a>Go语言函数</h1><p>Go语言中支持：函数、匿名函数和闭包</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>go语言函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span></span> [return_types] &#123;<br>   函数体<br>&#125;<br><br><span class="hljs-comment">//即</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> 函数名<span class="hljs-params">(参数)</span></span> (返回值) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>函数定义解析：</p><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><p><strong>在同一个包内，函数名不能重名</strong></p><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 函数返回两个数的最大值 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> result <span class="hljs-type">int</span><br><br>   <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>      result = num1<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = num2<br>   &#125;<br>   <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="函数参数的简写"><a href="#函数参数的简写" class="headerlink" title="函数参数的简写"></a>函数参数的简写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sub := x - y<br>    <span class="hljs-keyword">return</span> sub<br>&#125;<br><br><span class="hljs-comment">//简写后</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sub := x - y<br>    <span class="hljs-keyword">return</span> sub<br>&#125;<br><span class="hljs-comment">//相当于前面没有指定类型的参数，与其后面参数类型相同</span><br></code></pre></td></tr></table></figure><h3 id="函数的可变参数"><a href="#函数的可变参数" class="headerlink" title="函数的可变参数"></a>函数的可变参数</h3><p>可变参数是指函数的参数数量不固定，go语言中的可变参数通过在参数名后加…来表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySum</span><span class="hljs-params">(x ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v--%T\n&quot;</span>, x, x)<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> x &#123;<br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>固定参数与可变参数可以混合使用，但是可变参数必须写在固定参数后面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySum</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义交换值函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>   temp = *x    <span class="hljs-comment">/* 保持 x 地址上的值 */</span><br>   *x = *y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   *y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ul><li><code>return</code>关键字一次可以返回多个值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#123;<br>    sum := x + y<br>    sub := x - y<br>    <span class="hljs-keyword">return</span> sum, sub<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回值命名：函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (sum <span class="hljs-type">int</span>, sub <span class="hljs-type">int</span>)&#123; <span class="hljs-comment">// sum后的int也可以省略</span><br>    sum = x + y<br>    sub = x - y<br>    <span class="hljs-keyword">return</span> sum, sub<br>&#125;<br><br></code></pre></td></tr></table></figure><p>命名返回值会被视为定义在函数顶部的变量，并且在使用 return 语句返回时，不再必须在其后面指定参数名，也就是支持“裸”返回。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (str <span class="hljs-type">string</span>)&#123;<br>str = s<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(name(<span class="hljs-string">&quot;czh&quot;</span>)) <span class="hljs-comment">//czh</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在使用了命名返回值的情况下也可以返回其他变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (str <span class="hljs-type">string</span>)&#123;<br>str = s<br>str1 := <span class="hljs-string">&quot;200&quot;</span><br><span class="hljs-keyword">return</span> str1<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(name(<span class="hljs-string">&quot;czh&quot;</span>)) <span class="hljs-comment">//200</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数变量作用域"><a href="#函数变量作用域" class="headerlink" title="函数变量作用域"></a>函数变量作用域</h2><p>全局变量：全局变量是定义在函数外部的变量，它在程序整个运行周期内有效。</p><p>局部变量：局部变量是函数内部定义的变量，函数内定义的变量无法在该函数外使用。</p><h2 id="Go语言递归函数"><a href="#Go语言递归函数" class="headerlink" title="Go语言递归函数"></a>Go语言递归函数</h2><p>递归，就是在运行的过程中调用自己。</p><p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p><h2 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h2><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>可以使用type关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> calc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> <span class="hljs-comment">//没有花括号</span><br></code></pre></td></tr></table></figure><p>上面语句定义了一个calc类型，它是一种函数类型，这种函数接收两个int类型的参数并返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calc类型的函数，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cal <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x - y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><br><span class="hljs-keyword">var</span> c cal<br>c = add<br>fmt.Printf(<span class="hljs-string">&quot;c的类型：%T\n&quot;</span>, c)<span class="hljs-comment">//c的类型：main.cal</span><br>    fmt.Println(c(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<span class="hljs-comment">//15</span><br>    <br>    f := sub<br>fmt.Printf(<span class="hljs-string">&quot;f的类型：%T\n&quot;</span>, f)<span class="hljs-comment">//f的类型：func(int, int) int</span><br>    fmt.Println(f(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<span class="hljs-comment">//10</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//也可以自定义其他类型，类似于C中的#define</span><br><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><br><br></code></pre></td></tr></table></figure><h3 id="函数作为另一个函数的参数"><a href="#函数作为另一个函数的参数" class="headerlink" title="函数作为另一个函数的参数"></a>函数作为另一个函数的参数</h3><p>函数定义后可作为另外一个函数的参数传入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x - y<br>&#125;<br><br><span class="hljs-keyword">type</span> calcType <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>, cb calcType)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">return</span> cb(x, y)<br>&#125;<br><span class="hljs-comment">//或者</span><br><span class="hljs-comment">//func calc(x, y int, cb func(int, int) int) int&#123;</span><br><span class="hljs-comment">//    return cb(x, y)</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    s := calc(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, add)<br>    fmt.Println(s)<span class="hljs-comment">//15</span><br>    <br>    j := calc(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<span class="hljs-comment">//传入匿名函数</span><br>        <span class="hljs-keyword">return</span> x * y<br>    &#125;)<br>    fmt.Println(j)<span class="hljs-comment">//12</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* 声明函数变量 */</span><br>   getSquareRoot := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>      <span class="hljs-keyword">return</span> math.Sqrt(x)<br>   &#125;<br><br>   <span class="hljs-comment">/* 使用函数 */</span><br>   fmt.Println(getSquareRoot(<span class="hljs-number">9</span>))<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> calcType <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(o <span class="hljs-type">string</span>)</span></span> calcType&#123;<br>    <span class="hljs-keyword">switch</span> o &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>    <span class="hljs-keyword">return</span> add<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>        <span class="hljs-keyword">return</span> sub<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<span class="hljs-comment">//匿名函数</span><br>            <span class="hljs-keyword">return</span> x * y<br>        &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> a = do(<span class="hljs-string">&quot;+&quot;</span>)<br>    fmt.Println(a(<span class="hljs-number">12</span>, <span class="hljs-number">4</span>))<span class="hljs-comment">//16</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(参数)</span></span>(返回值)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//匿名函数 匿名自执行函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        fmt.Println(<span class="hljs-string">&quot;test...&quot;</span>)<br>    &#125;()<span class="hljs-comment">//加括号表示自执行</span><br>    <br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> x * y<br>    &#125;<br>    fmt.Println(fn(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<span class="hljs-comment">//6</span><br>    <br>    <span class="hljs-comment">//匿名自执行函数接收参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span>&#123;<br>        fmt.Println(x, y)<span class="hljs-comment">//10 20</span><br>    &#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包</p><ol><li>闭包是指有权访问另一个函数作用域中的变量的函数。</li><li>创建闭包的常见方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。</li></ol><p>全局变量特点：</p><ol><li>常驻内存</li><li>污染全局</li></ol><p>局部变量的特点：</p><ol><li>不常住内存</li><li>不污染全局</li></ol><p>闭包的特点：</p><ol><li>可以让一个变量常驻内存</li><li>可以让一个变量不污染全局</li></ol><p>闭包是匿名函数，可在动态编程中使用</p><p>闭包可以理解成“定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。或者说是函数和其引用环境的组合体。</p><p>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSequence</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>   i:=<span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>      i+=<span class="hljs-number">1</span><br>     <span class="hljs-keyword">return</span> i  <br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* nextNumber 为一个函数，函数 i 为 0 */</span><br>   nextNumber := getSequence()  <br><br>   <span class="hljs-comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br>   fmt.Println(nextNumber()) <span class="hljs-comment">//1</span><br>   fmt.Println(nextNumber()) <span class="hljs-comment">//2</span><br>   fmt.Println(nextNumber()) <span class="hljs-comment">//3</span><br>   <br>   <span class="hljs-comment">/* 创建新的函数 nextNumber1，并查看结果 */</span><br>   nextNumber1 := getSequence()  <br>   fmt.Println(nextNumber1()) <span class="hljs-comment">//1</span><br>   fmt.Println(nextNumber1()) <span class="hljs-comment">//2</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：由于闭包作用域返回的局部变量资源不会被立刻销毁回收，所以可能会占用更多的内存。过度使用闭包会导致性能下降，建议在非常有必要的时候才使用闭包。</strong></p><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的***<u>逆序</u>***进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。</p><p><strong>defer 在命名返回值和普通返回值的函数或方法中，返回的结果不一样。</strong></p><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><span class="hljs-comment">//0</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>a++<br>&#125;()<br><br><span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span> (a <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>a++<br>&#125;()<br><br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>fmt.Println(f2())<span class="hljs-comment">//0</span><br>fmt.Println(f3())<span class="hljs-comment">//1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>defer注册要延迟执行的函数时该函数所有的参数都需要确定其值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myCalc</span><span class="hljs-params">(index <span class="hljs-type">string</span>, a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ret := a + b<br>fmt.Println(index, a, b, ret)<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x := <span class="hljs-number">1</span><br>y := <span class="hljs-number">2</span><br><span class="hljs-keyword">defer</span> myCalc(<span class="hljs-string">&quot;AA&quot;</span>, x, myCalc(<span class="hljs-string">&quot;A&quot;</span>, x, y))<br>x = <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> myCalc(<span class="hljs-string">&quot;BB&quot;</span>, x, myCalc(<span class="hljs-string">&quot;B&quot;</span>, x, y))<br>y = <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注册顺序</span><br><span class="hljs-comment">defer myCalc(&quot;AA&quot;, x, myCalc(&quot;A&quot;, x, y))</span><br><span class="hljs-comment">defer myCalc(&quot;BB&quot;, x, myCalc(&quot;B&quot;, x, y))</span><br><span class="hljs-comment">执行顺序</span><br><span class="hljs-comment">defer myCalc(&quot;BB&quot;, x, myCalc(&quot;B&quot;, x, y))</span><br><span class="hljs-comment">defer myCalc(&quot;AA&quot;, x, myCalc(&quot;A&quot;, x, y))</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//1.myCalc(&quot;A&quot;, x, y) A 1 2 3</span><br><span class="hljs-comment">//2.myCalc(&quot;B&quot;, x, y) B 10 2 12</span><br><span class="hljs-comment">//3.myCalc(&quot;BB&quot;, x, myCalc(&quot;B&quot;, x, y)) BB 10 12 22</span><br><span class="hljs-comment">//4.myCalc(&quot;AA&quot;, x, myCalc(&quot;A&quot;, x, y)) AA 1 3 4</span><br></code></pre></td></tr></table></figure><h3 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h3><p>在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：<br><img src="/2023/01/27/Golang/a57c1d07a9eb6c1476f5faa2a8095fc8.png" alt="defer执行时机"></p><p><a href="https://blog.csdn.net/qq_36867807/article/details/116406954">Golang中defer的执行时机_清秋-的博客-CSDN博客_defer什么时候执行</a></p><p>（自己的理解：命名返回值的时候相当于已经决定好了返回的变量对应的地址，那么对该要返回的变量的修改都在此地址处进行修改，最后执行RET指令时返回该地址中的值，因此defer语句可以对返回值产生影响；而普通返回值则是在return的第一步时将返回值copy了一份到一个地址中，执行RET指令时就返回这个地址中的值，而defer语句中进行修改也只是修改原先变量地址中的值，因此不会对返回值产生影响）</p><h2 id="内置函数panic-x2F-recover"><a href="#内置函数panic-x2F-recover" class="headerlink" title="内置函数panic&#x2F;recover"></a>内置函数panic&#x2F;recover</h2><table><thead><tr><th>内置函数</th><th>介绍</th></tr></thead><tbody><tr><td>close</td><td>主要用来关闭channel</td></tr><tr><td>len</td><td>用来求长度，比如string、array、slice、map、channel</td></tr><tr><td>new</td><td>用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td>make</td><td>用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td>append</td><td>用来追加元素到数组、slice中</td></tr><tr><td>panic和recover</td><td>用来做错误处理</td></tr></tbody></table><p>Go语言中目前是没有异常机制，但是使用panic&#x2F;recover模式来处理错误。panic可以在任何地方引发，但recover只有在defer调用的函数中有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;fn1&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> err != any(<span class="hljs-literal">nil</span>) &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(any(<span class="hljs-string">&quot;抛出一个异常&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>fn1()<br>fn2()<br>fmt.Println(<span class="hljs-string">&quot;结束&quot;</span>)<br>&#125;<br><span class="hljs-comment">//fn1</span><br><span class="hljs-comment">//抛出一个异常</span><br><span class="hljs-comment">//结束</span><br></code></pre></td></tr></table></figure><p>recover之后程序会继续往下执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn1</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> err != any(<span class="hljs-literal">nil</span>) &#123;<br>fmt.Println(<span class="hljs-string">&quot;error:&quot;</span>, err)<br>&#125;<br>&#125;()<br>fmt.Println(a/b)<br><span class="hljs-keyword">return</span> a/b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>fmt.Println(fn1(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>))<br>fmt.Println(<span class="hljs-string">&quot;结束&quot;</span>)<br>fn1(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-comment">//error: runtime error: integer divide by zero</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//结束</span><br><span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><h1 id="Go语言time包及日期函数"><a href="#Go语言time包及日期函数" class="headerlink" title="Go语言time包及日期函数"></a>Go语言time包及日期函数</h1><h2 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h2><h2 id="time-Now-获取当前时间"><a href="#time-Now-获取当前时间" class="headerlink" title="time.Now()获取当前时间"></a>time.Now()获取当前时间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Printf(<span class="hljs-string">&quot;%v -- %T\n&quot;</span>, now, now)<span class="hljs-comment">//2023-01-04 20:12:50.677304 +0800 CST m=+0.003117301 -- time.Time</span><br><br>year := now.Year()<br>month := now.Month()<br>day := now.Day()<br>hour := now.Hour()<br>minute := now.Minute()<br>second := now.Second()<br><br>fmt.Printf(<span class="hljs-string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year,month,day,hour,minute,second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="now-Format格式化输出日期字符串"><a href="#now-Format格式化输出日期字符串" class="headerlink" title="now.Format格式化输出日期字符串"></a>now.Format格式化输出日期字符串</h2><p>时间类型有一个自带的方法Format进行格式化</p><p>需要注意的是Go语言中格式化时间模板不是常见的Y-m-d H:M:S</p><p>而是使用Go的诞生时间2006年1月2日15点04分（记忆口诀为2006 1 2 3 4）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><span class="hljs-comment">//2023-01-04</span><br>str := now.Format(<span class="hljs-string">&quot;2006-01-02 03:04:05&quot;</span>)<br>fmt.Println(str)<br>&#125;<br></code></pre></td></tr></table></figure><p>2006 年</p><p>01 月</p><p>02 日</p><p>03 时（12小时制） 15 时（24小时制）</p><p>04 分</p><p>05 秒</p><h2 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h2><p>获取秒时间戳</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>unix := now.Unix()<br>fmt.Println(unix)<br>&#125;<br></code></pre></td></tr></table></figure><p>获取纳秒时间戳</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>unix := now.UnixNano()<br>fmt.Println(unix)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间戳转换为日期字符（年-月-日-时-分-秒）"><a href="#时间戳转换为日期字符（年-月-日-时-分-秒）" class="headerlink" title="时间戳转换为日期字符（年-月-日 时:分:秒）"></a>时间戳转换为日期字符（年-月-日 时:分:秒）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unixTime := <span class="hljs-number">1672835458</span><br>timeObj := time.Unix(<span class="hljs-type">int64</span>(unixTime), <span class="hljs-number">0</span>)<span class="hljs-comment">//第一个参数写毫秒时间戳，第二个参数写纳秒时间戳，没有就写0</span><br><br>str1 := timeObj.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)<br>fmt.Println(str1)<span class="hljs-comment">//2023-01-04 20:30:58</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日期字符串转换成时间戳"><a href="#日期字符串转换成时间戳" class="headerlink" title="日期字符串转换成时间戳"></a>日期字符串转换成时间戳</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;2023-01-04 20:30:58&quot;</span><br><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span> <span class="hljs-comment">//模板</span><br>location, _ := time.ParseInLocation(tmp, str2, time.Local)<br>fmt.Println(location)<br>    fmt.Println(location.Unix())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p>time.Duration是time包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔，可表示的最长时间段大约为290年。</p><p>time包中定义的时间间隔类型的常量如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Nanosecond Duration = <span class="hljs-number">1</span><br>    Microsecond= <span class="hljs-number">1000</span> * Nanosecond<br>    Millisecond= <span class="hljs-number">1000</span> * Microsecond<br>    Second= <span class="hljs-number">1000</span> * Millisecond<br>    Minute= <span class="hljs-number">60</span> * Second<br>    Hour= <span class="hljs-number">60</span> * Minute<br>)<br></code></pre></td></tr></table></figure><h2 id="时间操作函数"><a href="#时间操作函数" class="headerlink" title="时间操作函数"></a>时间操作函数</h2><p>Add：时间+时间间隔</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Add(d Duration) Time<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//求1小时之后的时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    now := time.Now()<br>    later := now.Add(time.Hour)<br>    fmt.Println(later)<br>&#125;<br></code></pre></td></tr></table></figure><p>Sub：求两个时间的差值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Sub(u Time) Duration<br></code></pre></td></tr></table></figure><p>返回一个时间段t-u。如果结果超出了Duration可以表示的最大值&#x2F;最小值，将返回最大值&#x2F;最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。</p><p>Equal</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Equal(u Time) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t&#x3D;&#x3D;u不同，这种方法还会比较地点和时区信息。</p><p>Before</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Before(u Time) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>After</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> After(u Time) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>1.使用time.NewTicker(时间间隔)来设置定时器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ticker := time.NewTicker(time.Second)<br>n := <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> t := <span class="hljs-keyword">range</span> ticker.C &#123;<br>n--<br>fmt.Println(t)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>ticker.Stop()<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.time.Sleep(time.Second)来实现定时器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        time.Sleep(timme.Second)<br>        fmt.Println(<span class="hljs-string">&quot;我在定时执行任务&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h1><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span>  <br><br>   fmt.Printf(<span class="hljs-string">&quot;变量的地址: %x\n&quot;</span>, &amp;a  )<br>&#125;<br></code></pre></td></tr></table></figure><p>指针声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> var_name *<span class="hljs-keyword">var</span>-<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ip *<span class="hljs-type">int</span>        <span class="hljs-comment">/* 指向整型*/</span><br><span class="hljs-keyword">var</span> fp *<span class="hljs-type">float32</span>    <span class="hljs-comment">/* 指向浮点型 */</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span>= <span class="hljs-number">20</span>   <span class="hljs-comment">/* 声明实际变量 */</span><br>   <span class="hljs-keyword">var</span> ip *<span class="hljs-type">int</span>        <span class="hljs-comment">/* 声明指针变量 */</span><br><br>   ip = &amp;a  <span class="hljs-comment">/* 指针变量的存储地址 */</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )<br><br>   <span class="hljs-comment">/* 指针变量的存储地址 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;ip 变量储存的指针地址: %x\n&quot;</span>, ip )<br><br>   <span class="hljs-comment">/* 使用指针访问值 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go空指针"><a href="#Go空指针" class="headerlink" title="Go空指针"></a>Go空指针</h2><p>当一个指针被定义后没有分配到任何变量时，它的值为nil。</p><p>nil指针也称为空指针。</p><p>nil在概念上和其他语言的null、None、nil、NULL一样，都指代零值或空值。</p><h2 id="Go指针数组"><a href="#Go指针数组" class="headerlink" title="Go指针数组"></a>Go指针数组</h2><p>声明整型指针数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ptr [MAX]*<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> MAX <span class="hljs-type">int</span> = <span class="hljs-number">3</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;<br>   <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br>   <span class="hljs-keyword">var</span> ptr [MAX]*<span class="hljs-type">int</span>;<br><br>   <span class="hljs-keyword">for</span>  i = <span class="hljs-number">0</span>; i &lt; MAX; i++ &#123;<br>      ptr[i] = &amp;a[i] <span class="hljs-comment">/* 整数地址赋值给指针数组 */</span><br>   &#125;<br><br>   <span class="hljs-keyword">for</span>  i = <span class="hljs-number">0</span>; i &lt; MAX; i++ &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;a[%d] = %d\n&quot;</span>, i,*ptr[i] )<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go指向指针的指针"><a href="#Go指向指针的指针" class="headerlink" title="Go指向指针的指针"></a>Go指向指针的指针</h2><p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p><p>指向指针的指针变量声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ptr **<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>   <span class="hljs-keyword">var</span> ptr *<span class="hljs-type">int</span><br>   <span class="hljs-keyword">var</span> pptr **<span class="hljs-type">int</span><br>   a = <span class="hljs-number">3000</span><br>   <span class="hljs-comment">/* 指针 ptr 地址 */</span><br>   ptr = &amp;a<br>   <span class="hljs-comment">/* 指向指针 ptr 地址 */</span><br>   pptr = &amp;ptr<br>   <span class="hljs-comment">/* 获取 pptr 的值 */</span><br>   fmt.Printf(<span class="hljs-string">&quot;变量 a = %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;指针变量 *ptr = %d\n&quot;</span>, *ptr )<br>   fmt.Printf(<span class="hljs-string">&quot;指向指针的指针变量 **pptr = %d\n&quot;</span>, **pptr)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go向函数传递指针参数"><a href="#Go向函数传递指针参数" class="headerlink" title="Go向函数传递指针参数"></a>Go向函数传递指针参数</h2><p>Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。</p><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span>= <span class="hljs-number">200</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换前 a 的值 : %d\n&quot;</span>, a )<span class="hljs-comment">//100</span><br>   fmt.Printf(<span class="hljs-string">&quot;交换前 b 的值 : %d\n&quot;</span>, b )<span class="hljs-comment">//200</span><br><br>   <span class="hljs-comment">/* 调用函数用于交换值</span><br><span class="hljs-comment">   * &amp;a 指向 a 变量的地址</span><br><span class="hljs-comment">   * &amp;b 指向 b 变量的地址</span><br><span class="hljs-comment">   */</span><br>   swap(&amp;a, &amp;b);<br><br>   fmt.Printf(<span class="hljs-string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )<span class="hljs-comment">//200</span><br>   fmt.Printf(<span class="hljs-string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )<span class="hljs-comment">//100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>   temp = *x    <span class="hljs-comment">/* 保存 x 地址的值 */</span><br>   *x = *y      <span class="hljs-comment">/* 将 y 赋值给 x */</span><br>   *y = temp    <span class="hljs-comment">/* 将 temp 赋值给 y */</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="new和make函数"><a href="#new和make函数" class="headerlink" title="new和make函数"></a>new和make函数</h1><p>在Go语言中对于引用数据类型的变量，我们在使用的时候不仅要声名它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存就需要new和make。Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h3 id="new函数分配内存"><a href="#new函数分配内存" class="headerlink" title="new函数分配内存"></a>new函数分配内存</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">new</span><span class="hljs-params">(Type)</span></span> *Type<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>实际开发中new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值，例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    a := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>    b := <span class="hljs-built_in">new</span>(<span class="hljs-type">bool</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, a) <span class="hljs-comment">//*int</span><br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, b) <span class="hljs-comment">//*bool</span><br>    fmt.Println(*a)<span class="hljs-comment">//0</span><br>    fmt.Println(*b)<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> b *<span class="hljs-type">int</span><br>    b = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>    *b = <span class="hljs-number">100</span><br>    fmt.Println(*b) <span class="hljs-comment">//100</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h3><ol><li>二者都是用来做内存分配的</li><li>make只是用于slice、map以及channel的初始化，返回的还是这三个引用类型本身</li><li>new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol><h1 id="Go语言结构体"><a href="#Go语言结构体" class="headerlink" title="Go语言结构体"></a>Go语言结构体</h1><p>Golang中没有“类”的概念，Golang中的结构体和其他语言中的类有点相似。和其他面向对象语言中的类相比，Golang中的结构体具有更高的扩展性和灵活性。</p><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来自定义类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><br><span class="hljs-comment">//表示将myInt定义为int类型，通过type关键字的定义，myInt就是一种新的类型，它具有int的特性</span><br></code></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>Golang1.9版本以后新添加的功能</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一种类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TypeAlias = Type<br></code></pre></td></tr></table></figure><p>rune和byte就是类型别名，它们的底层定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">byte</span> = <span class="hljs-type">uint8</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">rune</span> = <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><span class="hljs-comment">//自定义类型</span><br><br><span class="hljs-keyword">type</span> myFloat = <span class="hljs-type">float64</span><span class="hljs-comment">//类型别名</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> a myInt = <span class="hljs-number">10</span><br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, a, a) <span class="hljs-comment">//10 main.myInt</span><br><br><span class="hljs-keyword">var</span> b myFloat = <span class="hljs-number">12.3</span><br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, b, b) <span class="hljs-comment">//12.3 float64</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> struct_variable_type <span class="hljs-keyword">struct</span> &#123;<br>   member definition<br>   member definition<br>   ...<br>   member definition<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结构体要求字段名称必须唯一</strong></p><p>结构体的字段类型可以是：基本数据类型、也可以是切片、Map以及结构体</p><p>如果结构体的字段类型是：指针，slice和map的零值都是nil，即还没有分配空间，如果需要使用这样的字段，需要先 make，才能使用。</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>第一种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;<br><span class="hljs-comment">//或</span><br>variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Books <span class="hljs-keyword">struct</span> &#123;<br>   title <span class="hljs-type">string</span><br>   author <span class="hljs-type">string</span><br>   subject <span class="hljs-type">string</span><br>   book_id <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-comment">// 创建一个新的结构体</span><br>    fmt.Println(Books&#123;<span class="hljs-string">&quot;Go 语言&quot;</span>, <span class="hljs-string">&quot;www.runoob.com&quot;</span>, <span class="hljs-string">&quot;Go 语言教程&quot;</span>, <span class="hljs-number">6495407</span>&#125;)<br><br>    <span class="hljs-comment">// 也可以使用 key =&gt; value 格式</span><br>    fmt.Println(Books&#123;title: <span class="hljs-string">&quot;Go 语言&quot;</span>, author: <span class="hljs-string">&quot;www.runoob.com&quot;</span>, subject: <span class="hljs-string">&quot;Go 语言教程&quot;</span>, book_id: <span class="hljs-number">6495407</span>&#125;)<br><br>    <span class="hljs-comment">// 忽略的字段为 0 或 空</span><br>   fmt.Println(Books&#123;title: <span class="hljs-string">&quot;Go 语言&quot;</span>, author: <span class="hljs-string">&quot;www.runoob.com&quot;</span>&#125;)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//&#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;</span><br><span class="hljs-comment">//&#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;</span><br><span class="hljs-comment">//&#123;Go 语言 www.runoob.com  0&#125;</span><br></code></pre></td></tr></table></figure><p>第二种方法：</p><p>可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-type">string</span><br>age <span class="hljs-type">int</span><br>sex <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> p1 Person<br>p1.name = <span class="hljs-string">&quot;张三&quot;</span><br>p1.sex = <span class="hljs-string">&quot;男&quot;</span><br>p1.age = <span class="hljs-number">20</span><br>fmt.Printf(<span class="hljs-string">&quot;值：%#v 类型：%T\n&quot;</span>, p1, p1)<br><br><span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">new</span>(Person)<br>p2.name = <span class="hljs-string">&quot;张三&quot;</span><br>p2.age = <span class="hljs-number">20</span><br>p2.sex = <span class="hljs-string">&quot;男&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;值：%#v 类型：%T\n&quot;</span>, *p2, p2)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>*<em>注意：在Golang中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。p2.name &#x3D; “张三” 其实底层是(<em>p2).name &#x3D; “张三”</em></em></p><p>其他初始化方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    p3 := &amp;Person&#123;<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;男&quot;</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%#v %T\n&quot;</span>, p3, p3)<span class="hljs-comment">//&amp;main.Person&#123;name:&quot;王五&quot;, age:20, sex:&quot;男&quot;&#125; *main.Person</span><br><br>p4 := Person&#123;<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;男&quot;</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%#v %T\n&quot;</span>, p4, p4)<span class="hljs-comment">//main.Person&#123;name:&quot;王五&quot;, age:20, sex:&quot;男&quot;&#125; main.Person</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h2><p>如果要访问结构体成员，需要使用点号 <code>.</code> 操作符，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">结构体.成员名<br></code></pre></td></tr></table></figure><h2 id="结构体方法和接收者"><a href="#结构体方法和接收者" class="headerlink" title="结构体方法和接收者"></a>结构体方法和接收者</h2><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p><p>在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接收者的函数。接收者的概念就类似于其他语言中的this或者self。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) [返回参数]&#123;<br>   <span class="hljs-comment">/* 函数体*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为p，Connector类型的接收者变量应该命名为c等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义结构体 */</span><br><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>  radius <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> c1 Circle<br>  c1.radius = <span class="hljs-number">10.00</span><br>  fmt.Println(<span class="hljs-string">&quot;圆的面积 = &quot;</span>, c1.getArea())<br>&#125;<br><br><span class="hljs-comment">//该 method 属于 Circle 类型对象中的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Circle)</span></span> getArea() <span class="hljs-type">float64</span> &#123;<br>  <span class="hljs-comment">//c.radius 即为 Circle 类型对象中的属性</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * c.radius * c.radius<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要定义一个方法修改结构体变量内的值，那么该方法的接收者类型需要为<strong>结构体指针类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-type">string</span><br>age <span class="hljs-type">int</span><br>sex <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> setInfo(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>) &#123;<br>p.name = name<br>p.age = age<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    p5 := <span class="hljs-built_in">new</span>(Person)<br>p5.setInfo(<span class="hljs-string">&quot;czh&quot;</span>, <span class="hljs-number">23</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%#v %T\n&quot;</span>, p5, p5)<br>    <br>    <span class="hljs-keyword">var</span> p6 = Person&#123;name: <span class="hljs-string">&quot;abc&quot;</span>, age: <span class="hljs-number">1</span>, sex: <span class="hljs-string">&quot;男&quot;</span>&#125;<br>p6.setInfo(<span class="hljs-string">&quot;czh&quot;</span>, <span class="hljs-number">23</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%#v %T\n&quot;</span>, p6, p6)<span class="hljs-comment">//也可</span><br>&#125;<br><span class="hljs-comment">//只要方法的接收者类型是指针类型，那么通过结构体指针变量还是结构体变量调用该方法都可以</span><br></code></pre></td></tr></table></figure><h2 id="给任意类型添加方法"><a href="#给任意类型添加方法" class="headerlink" title="给任意类型添加方法"></a>给任意类型添加方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myInt)</span></span> SayHello()&#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。（<strong>定义普通结构体的时候不建议这样写，一般在嵌套结构体中才会使用</strong>）</p><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能定义一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">string</span><br>    <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    p1 := Person&#123;<br>        <span class="hljs-string">&quot;张三&quot;</span>,<br>        <span class="hljs-number">20</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age <span class="hljs-type">int</span><br>Hobby []<span class="hljs-type">string</span><br>map1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span><br>Password <span class="hljs-type">string</span><br><span class="hljs-comment">//Address Address //表示User结构体嵌套Address结构体</span><br>Address<span class="hljs-comment">//嵌套匿名结构体</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Phone <span class="hljs-type">string</span><br>City <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br><span class="hljs-keyword">var</span> u User<br>u.Username = <span class="hljs-string">&quot;czh&quot;</span><br>u.Password = <span class="hljs-string">&quot;123456&quot;</span><br>u.Address.Name = <span class="hljs-string">&quot;张三&quot;</span><br>u.Address.Phone = <span class="hljs-string">&quot;123456789&quot;</span><br>u.Address.City = <span class="hljs-string">&quot;北京&quot;</span><br><br>u.City = <span class="hljs-string">&quot;上海&quot;</span><span class="hljs-comment">//User中没有City字段，因此也可以直接通过u修改City的值，如果User中有City字段则此代码会修改User中的City</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, u)<br>&#125;<br></code></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><p>关于嵌套结构体的字段命名冲突：</p><p>如果父结构体中有多个子匿名结构体，子匿名结构体中有字段冲突则会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Username <span class="hljs-type">string</span><br>Password <span class="hljs-type">string</span><br>Address<br>Email<br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Phone <span class="hljs-type">string</span><br>City <span class="hljs-type">string</span><br>AddTime <span class="hljs-type">string</span> <span class="hljs-comment">// </span><br>&#125;<br><br><span class="hljs-keyword">type</span> Email <span class="hljs-keyword">struct</span> &#123;<br>Account <span class="hljs-type">string</span><br>AddTime <span class="hljs-type">string</span> <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vaar u User<br>    <span class="hljs-comment">//u.AddTime = &quot;2023-01-05&quot; //报错</span><br>    u.Address.AddTime = <span class="hljs-string">&quot;2023-01-05&quot;</span><br>    u.Email.AddTime = <span class="hljs-string">&quot;2023-01-05&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体继承"><a href="#结构体继承" class="headerlink" title="结构体继承"></a>结构体继承</h2><p>Go语言中使用结构体也可实现其他编程语言中的继承，即通过结构体嵌套。</p><p>一个结构体中可以嵌套包含另一个结构体或结构体指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//父结构体</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Animal)</span></span> run()&#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v 在运动\n&quot;</span>, a.Name)<br>&#125;<br><br><span class="hljs-comment">//子结构体</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-type">int</span><br>Animal<span class="hljs-comment">//结构体嵌套</span><br>    <span class="hljs-comment">// *Animal//也可使用结构体指针，但是在初始化值时需要传地址</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> wang()  &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v 在汪汪\n&quot;</span>, d.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> d = Dog&#123;<br>Age: <span class="hljs-number">20</span>,<br>        Animal: Animal&#123;<span class="hljs-comment">//如果是*Animal类型则为 Animal: &amp;Animal&#123;&#125;</span><br>Name: <span class="hljs-string">&quot;修勾&quot;</span>,<br>&#125;,<br>&#125;<br>d.run()<span class="hljs-comment">//修勾 在运动</span><br>d.wang()<span class="hljs-comment">//修勾 在汪汪</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体和Json相互转换、序列化和反序列化"><a href="#结构体和Json相互转换、序列化和反序列化" class="headerlink" title="结构体和Json相互转换、序列化和反序列化"></a>结构体和Json相互转换、序列化和反序列化</h2><p>Golang JSON序列化是指把结构体数据转换成JSON格式的字符串，Golang JSON的反序列化是指把JSON数据转换成Golang中的结构体对象。</p><p>Golang中的序列化和反序列化主要通过“encoding&#x2F;json”包中的json.Marshal()和json.Unmarshal()</p><p>要将结构体与json进行转换那么字段首字母必须大写，即公有属性，否则不能被json包访问，就会被忽略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>ID <span class="hljs-type">int</span><br>Gender <span class="hljs-type">string</span><br>Name <span class="hljs-type">string</span><br>Sno <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> s1 = Stu&#123;<br>ID: <span class="hljs-number">12</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>Name: <span class="hljs-string">&quot;李四&quot;</span>,<br>Sno: <span class="hljs-string">&quot;s001&quot;</span>,<br>&#125;<br><br>jsonByte, _ := json.Marshal(s1)<br>jsonStr := <span class="hljs-type">string</span>(jsonByte)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, jsonStr)<br>    <span class="hljs-comment">//&#123;&quot;ID&quot;:12,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;李四&quot;,&quot;Sno&quot;:&quot;s001&quot;&#125;</span><br>    <br>    str := <span class="hljs-string">`&#123;&quot;ID&quot;:12,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;李四&quot;,&quot;Sno&quot;:&quot;s001&quot;&#125;`</span><br><span class="hljs-keyword">var</span> s2 Stu<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;s2)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, s2)<br>    <span class="hljs-comment">//main.Stu&#123;ID:12, Gender:&quot;男&quot;, Name:&quot;李四&quot;, Sno:&quot;s001&quot;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要把json串中的key首字母小写，如ID修改为id，则需要使用到结构体标签。</p><h2 id="结构体标签Tag"><a href="#结构体标签Tag" class="headerlink" title="结构体标签Tag"></a>结构体标签Tag</h2><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取存出来。Tag在结构体字段的后方定义，由一对<code>反引号</code>包裹起来，具体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span><br></code></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。健与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><p><strong>注意事项</strong>：为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如：不要在key和value之间添加空格。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>ID <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>Gender <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;gender&quot;`</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Sno <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sno&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> s1 = Stu&#123;<br>ID: <span class="hljs-number">12</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>Name: <span class="hljs-string">&quot;李四&quot;</span>,<br>Sno: <span class="hljs-string">&quot;s001&quot;</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, s1)<br><br>jsonByte, _ := json.Marshal(s1)<br>jsonStr := <span class="hljs-type">string</span>(jsonByte)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, jsonStr)<br>    <span class="hljs-comment">//&#123;&quot;id&quot;:12,&quot;gender&quot;:&quot;男&quot;,&quot;name&quot;:&quot;李四&quot;,&quot;sno&quot;:&quot;s001&quot;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>项目中常用</p><h2 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h2><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Books <span class="hljs-keyword">struct</span> &#123;<br>   title <span class="hljs-type">string</span><br>   author <span class="hljs-type">string</span><br>   subject <span class="hljs-type">string</span><br>   book_id <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> Book1 Books        <span class="hljs-comment">/* 声明 Book1 为 Books 类型 */</span><br>   <span class="hljs-keyword">var</span> Book2 Books        <span class="hljs-comment">/* 声明 Book2 为 Books 类型 */</span><br><br>   <span class="hljs-comment">/* book 1 描述 */</span><br>   Book1.title = <span class="hljs-string">&quot;Go 语言&quot;</span><br>   Book1.author = <span class="hljs-string">&quot;www.runoob.com&quot;</span><br>   Book1.subject = <span class="hljs-string">&quot;Go 语言教程&quot;</span><br>   Book1.book_id = <span class="hljs-number">6495407</span><br><br>   <span class="hljs-comment">/* book 2 描述 */</span><br>   Book2.title = <span class="hljs-string">&quot;Python 教程&quot;</span><br>   Book2.author = <span class="hljs-string">&quot;www.runoob.com&quot;</span><br>   Book2.subject = <span class="hljs-string">&quot;Python 语言教程&quot;</span><br>   Book2.book_id = <span class="hljs-number">6495700</span><br><br>   <span class="hljs-comment">/* 打印 Book1 信息 */</span><br>   printBook(Book1)<br><br>   <span class="hljs-comment">/* 打印 Book2 信息 */</span><br>   printBook(Book2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printBook</span><span class="hljs-params">( book Books )</span></span> &#123;<br>   fmt.Printf( <span class="hljs-string">&quot;Book title : %s\n&quot;</span>, book.title)<br>   fmt.Printf( <span class="hljs-string">&quot;Book author : %s\n&quot;</span>, book.author)<br>   fmt.Printf( <span class="hljs-string">&quot;Book subject : %s\n&quot;</span>, book.subject)<br>   fmt.Printf( <span class="hljs-string">&quot;Book book_id : %d\n&quot;</span>, book.book_id)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>可以定义指向结构体的指针类似于其他指针变量，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> struct_pointer *Books<br></code></pre></td></tr></table></figure><p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">struct_pointer = &amp;Book1<br></code></pre></td></tr></table></figure><p>使用结构体指针访问结构体成员，使用 “.” 操作符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">struct_pointer.title<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Books <span class="hljs-keyword">struct</span> &#123;<br>   title <span class="hljs-type">string</span><br>   author <span class="hljs-type">string</span><br>   subject <span class="hljs-type">string</span><br>   book_id <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> Book1 Books        <span class="hljs-comment">/* 声明 Book1 为 Books 类型 */</span><br>   <span class="hljs-keyword">var</span> Book2 Books        <span class="hljs-comment">/* 声明 Book2 为 Books 类型 */</span><br><br>   <span class="hljs-comment">/* book 1 描述 */</span><br>   Book1.title = <span class="hljs-string">&quot;Go 语言&quot;</span><br>   Book1.author = <span class="hljs-string">&quot;www.runoob.com&quot;</span><br>   Book1.subject = <span class="hljs-string">&quot;Go 语言教程&quot;</span><br>   Book1.book_id = <span class="hljs-number">6495407</span><br><br>   <span class="hljs-comment">/* book 2 描述 */</span><br>   Book2.title = <span class="hljs-string">&quot;Python 教程&quot;</span><br>   Book2.author = <span class="hljs-string">&quot;www.runoob.com&quot;</span><br>   Book2.subject = <span class="hljs-string">&quot;Python 语言教程&quot;</span><br>   Book2.book_id = <span class="hljs-number">6495700</span><br><br>   <span class="hljs-comment">/* 打印 Book1 信息 */</span><br>   printBook(&amp;Book1)<br><br>   <span class="hljs-comment">/* 打印 Book2 信息 */</span><br>   printBook(&amp;Book2)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printBook</span><span class="hljs-params">( book *Books )</span></span> &#123;<br>   fmt.Printf( <span class="hljs-string">&quot;Book title : %s\n&quot;</span>, book.title)<br>   fmt.Printf( <span class="hljs-string">&quot;Book author : %s\n&quot;</span>, book.author)<br>   fmt.Printf( <span class="hljs-string">&quot;Book subject : %s\n&quot;</span>, book.subject)<br>   fmt.Printf( <span class="hljs-string">&quot;Book book_id : %d\n&quot;</span>, book.book_id)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go中的go-mod以及Golang包详解"><a href="#Go中的go-mod以及Golang包详解" class="headerlink" title="Go中的go mod以及Golang包详解"></a>Go中的go mod以及Golang包详解</h1><h2 id="Golang中包的介绍和定义"><a href="#Golang中包的介绍和定义" class="headerlink" title="Golang中包的介绍和定义"></a>Golang中包的介绍和定义</h2><p>包（package）是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、strings、sort、errors、time、encoding&#x2F;josn、os、io等。</p><p>Golang中的包可以分为三种：1.系统内置包。2.自定义包。3.第三方包。</p><p>系统内置包：Golang语言给我们提供的内置包，引入后可以直接使用，如fmt、strconv、strings、sort、errors、time、encoding&#x2F;json、os、io等</p><p>自定义包：开发者自己写的包</p><p>第三方包：属于自定义包的一种，需要安装到本地后才可以使用，如“github.com&#x2F;shopspring&#x2F;decimal”包解决float精度丢失问题。</p><h2 id="Golang包管理工具"><a href="#Golang包管理工具" class="headerlink" title="Golang包管理工具"></a>Golang包管理工具</h2><p>在Golang1.11版本之前如果我们要自定义包的话必须把项目放在GOPATH目录。Go1.11版本之后无需手动配置环境变量，使用go mod管理项目，也不需要非得把项目放到GOPATH指定目录下，你可以在你磁盘的任何位置新建一个项目，Go1.13以后可以彻底不要GOPATH了。</p><h2 id="go-mod-init初始化项目"><a href="#go-mod-init初始化项目" class="headerlink" title="go mod init初始化项目"></a>go mod init初始化项目</h2><p>实际项目开发中我们首先要在我们项目目录中用go mod命令生成一个go.mod文件管理我们项目的依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod init 项目名<br></code></pre></td></tr></table></figure><h2 id="Golang中自定义包"><a href="#Golang中自定义包" class="headerlink" title="Golang中自定义包"></a>Golang中自定义包</h2><p>包（package）是多个Go源码的集合，一个包可以简单理解为一个存放多个.go文件的文件夹。该文件夹下面的所有go文件都要在代码的第一行写如下代码，声明该文件归属的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> 包名<br><span class="hljs-comment">//必须放在第一行</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样，包名不能包含 - 符号。</li><li>包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。</li></ul><h2 id="自定义包名"><a href="#自定义包名" class="headerlink" title="自定义包名"></a>自定义包名</h2><p>在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。把别名写在导入的包名前面即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> T <span class="hljs-string">&quot;awesomeProject/tools&quot;</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">import</span> (<br>T <span class="hljs-string">&quot;awesomeProject/tools&quot;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h2><p>如果只希望导入包，而不使用包内的数据时，可以使用匿名导入包。具体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;包的路径&quot;</span><br></code></pre></td></tr></table></figure><p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</p><h2 id="Golang中的init-初始化函数"><a href="#Golang中的init-初始化函数" class="headerlink" title="Golang中的init()初始化函数"></a>Golang中的init()初始化函数</h2><h3 id="init-函数介绍"><a href="#init-函数介绍" class="headerlink" title="init()函数介绍"></a>init()函数介绍</h3><p>在go语言程序执行时导入包语句会自动触发包内部init()函数的调用。需要注意的是：init()函数没有参数也没有返回值。init()函数在程序运行时自动被调用执行，不能在代码中主动调用它。</p><p>包初始化执行的顺序如下图所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">int8</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><span class="hljs-comment">//全局声明 -&gt; init() -&gt; main()</span><br></code></pre></td></tr></table></figure><h3 id="init-函数执行顺序"><a href="#init-函数执行顺序" class="headerlink" title="init()函数执行顺序"></a>init()函数执行顺序</h3><p>Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p><p>在运行时，被最后导入的包会最先初始化并调用其init()函数，如下图所示：</p><p><img src="/2023/01/27/Golang/init%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="init函数执行顺序"></p><h2 id="Golang中使用第三方包"><a href="#Golang中使用第三方包" class="headerlink" title="Golang中使用第三方包"></a>Golang中使用第三方包</h2><p>我们可以在<a href="https://pkg.go.dev/%E6%9F%A5%E6%89%BE%E5%B8%B8%E8%A7%81%E7%9A%84golang%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85">https://pkg.go.dev/查找常见的golang第三方包</a></p><ol><li><p>找到我们需要下载安装的第三方包的地址</p></li><li><p>安装这个包</p></li></ol><ul><li>第一种方法：go get 包名称 （全局）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/shopspring/decimal<br></code></pre></td></tr></table></figure><ul><li>第二种方法：go mod download （全局），依赖包会自动下载到$GOPATH&#x2F;pkg&#x2F;mod，多个项目可以共享缓存的mod，注意使用go mod download的时候首先需要在你的项目里面引入第三方包。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod download<br></code></pre></td></tr></table></figure><ul><li>第三种方法：go mod vendor 将依赖复制到当前项目的vendor下（本项目）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod vendor<br></code></pre></td></tr></table></figure><p>​注意：使用go mod vendor 的时候首先需要在你到项目里面引入第三方包。</p><ol start="3"><li>看文档使用包</li></ol><p>也可以直接使用import导入，运行时会自动下载到GOPATH</p><h1 id="Go语言范围（Range）"><a href="#Go语言范围（Range）" class="headerlink" title="Go语言范围（Range）"></a>Go语言范围（Range）</h1><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p><p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><p>for 循环的 range 格式可以省略 key 和 value，如下实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">float32</span>)<br>    map1[<span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span><br>    map1[<span class="hljs-number">2</span>] = <span class="hljs-number">2.0</span><br>    map1[<span class="hljs-number">3</span>] = <span class="hljs-number">3.0</span><br>    map1[<span class="hljs-number">4</span>] = <span class="hljs-number">4.0</span><br>   <br>    <span class="hljs-comment">// 读取 key 和 value</span><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map1 &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;key is: %d - value is: %f\n&quot;</span>, key, value)<br>    &#125;<br><br>    <span class="hljs-comment">// 读取 key</span><br>    <span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> map1 &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;key is: %d\n&quot;</span>, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 读取 value</span><br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> map1 &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;value is: %f\n&quot;</span>, value)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出：</span><br>key is: <span class="hljs-number">4</span> - value is: <span class="hljs-number">4.000000</span><br>key is: <span class="hljs-number">1</span> - value is: <span class="hljs-number">1.000000</span><br>key is: <span class="hljs-number">2</span> - value is: <span class="hljs-number">2.000000</span><br>key is: <span class="hljs-number">3</span> - value is: <span class="hljs-number">3.000000</span><br>key is: <span class="hljs-number">1</span><br>key is: <span class="hljs-number">2</span><br>key is: <span class="hljs-number">3</span><br>key is: <span class="hljs-number">4</span><br>value is: <span class="hljs-number">1.000000</span><br>value is: <span class="hljs-number">2.000000</span><br>value is: <span class="hljs-number">3.000000</span><br>value is: <span class="hljs-number">4.000000</span><br></code></pre></td></tr></table></figure><h1 id="Go语言接口（interface）"><a href="#Go语言接口（interface）" class="headerlink" title="Go语言接口（interface）"></a>Go语言接口（interface）</h1><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>Golang中的接口是一种抽象数据类型，Golang中接口定义了对象的行为规范，只定义规范不实现。接口中定义的规范由具体的对象来实现。</p><p>通俗的讲，接口就是一个标准，它是对一个对象的行为和规范进行约定。</p><h2 id="Golang接口的定义"><a href="#Golang接口的定义" class="headerlink" title="Golang接口的定义"></a>Golang接口的定义</h2><p>​在Golang中接口（interface）是一种类型，一种抽象类型。接口（interface）是一组函数method的集合，Golang中的接口不能包含任何变量。</p><p>​在Golang中接口中的所有方法都没有方法体，接口定义了一个对象的行为规范，只定义规范不实现。接口体现了程序设计的多态和高内聚低耦合的思想。</p><p>​Golang中的接口也是一种数据类型，不需要显示实现。只需要一个变量含有接口类型中的所有方法，那么这个变量就实现了这个接口。</p><p>Golang中每个接口由数个方法组成，接口的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 接口名 <span class="hljs-keyword">interface</span>&#123;<br>    方法名<span class="hljs-number">1</span>(参数列表<span class="hljs-number">1</span>) 返回值列表<span class="hljs-number">1</span><br>    方法名<span class="hljs-number">2</span>(参数列表<span class="hljs-number">2</span>) 返回值列表<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以忽略。</li></ul><p>如果接口里面有方法的话，必须要通过结构体或者通过自定义类型实现这个接口。</p><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义接口 */</span><br><span class="hljs-keyword">type</span> interface_name <span class="hljs-keyword">interface</span> &#123;<br>   method_name1 [return_type]<br>   method_name2 [return_type]<br>   method_name3 [return_type]<br>   ...<br>   method_namen [return_type]<br>&#125;<br><br><span class="hljs-comment">/* 定义结构体 */</span><br><span class="hljs-keyword">type</span> struct_name <span class="hljs-keyword">struct</span> &#123;<br>   <span class="hljs-comment">/* variables */</span><br>&#125;<br><br><span class="hljs-comment">/* 实现接口方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span></span> method_name1() [return_type] &#123;<br>   <span class="hljs-comment">/* 方法实现 */</span><br>&#125;<br>...<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span></span> method_namen() [return_type] &#123;<br>   <span class="hljs-comment">/* 方法实现*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Usber <span class="hljs-keyword">interface</span> &#123;<br>start()<br>stop()<br>&#125;<br><br><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Phone)</span></span> start() &#123;<br>fmt.Println(p.Name, <span class="hljs-string">&quot;启动&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Phone)</span></span> stop()  &#123;<br>fmt.Println(p.Name, <span class="hljs-string">&quot;关机&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Camera <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Camera)</span></span> start() &#123;<br>fmt.Println(<span class="hljs-string">&quot;相机启动&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Camera)</span></span> stop()  &#123;<br>fmt.Println(<span class="hljs-string">&quot;相机关机&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> p = Phone&#123;<br>Name: <span class="hljs-string">&quot;华为手机&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 Usber <span class="hljs-comment">//golang中接口就是一个数据类型</span><br>p1 = p<span class="hljs-comment">//表示手机实现Usb接口</span><br>p1.start()<br><br>c := Camera&#123;&#125;<br><span class="hljs-keyword">var</span> c1 Usber = c<span class="hljs-comment">//表示相机实现了Usb接口</span><br>c1.start()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>Golang中的接口可以不定义任何方法，没有定义任何方法的接口就是空接口。<strong>空接口表示没有任何约束，因此任何类型变量都可以实现空接口。</strong></p><p>空接口在实际项目中用的是非常多的，用空接口可以表示任意数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;&#125;<span class="hljs-comment">//空接口 表示没有任何约束，任意类型都可以实现空接口</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a A<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;你好golang&quot;</span><br>a = str<span class="hljs-comment">//让字符串实现A接口</span><br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, a, a)<span class="hljs-comment">//你好golang string</span><br><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span><br>a = num<br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, a, a)<span class="hljs-comment">//20 int</span><br><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>a = flag<br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, a, a)<span class="hljs-comment">//true bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>golang中空接口也可以直接当作类型使用，可以表示任意类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> b <span class="hljs-keyword">interface</span>&#123;&#125;<br>b = <span class="hljs-string">&quot;你好golang&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, b, b) <span class="hljs-comment">//你好golang string</span><br>b = <span class="hljs-literal">true</span><br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, b, b) <span class="hljs-comment">//true bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h3><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v %T\n&quot;</span>, a, a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    show(<span class="hljs-number">20</span>)<span class="hljs-comment">//20 int</span><br>show(<span class="hljs-string">&quot;你好golang&quot;</span>)<span class="hljs-comment">//你好golang string</span><br>show([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;)<span class="hljs-comment">//[1 2 3 4] []int</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map的值实现空接口"><a href="#map的值实现空接口" class="headerlink" title="map的值实现空接口"></a>map的值实现空接口</h3><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>m1[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;czh&quot;</span><br>m1[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">23</span><br>m1[<span class="hljs-string">&quot;married&quot;</span>] = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v %v, %T\n&quot;</span>, k, v, v)<br>&#125;<br>&#125;<br><span class="hljs-comment">//name czh, string</span><br><span class="hljs-comment">//age 23, int</span><br><span class="hljs-comment">//married false, bool</span><br></code></pre></td></tr></table></figure><h3 id="slice的值实现空接口"><a href="#slice的值实现空接口" class="headerlink" title="slice的值实现空接口"></a>slice的值实现空接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> s1 = []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;你好&quot;</span>, <span class="hljs-literal">true</span>&#125;<br>fmt.Println(s1)<span class="hljs-comment">//[1 2 你好 true]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。</p><p>如果我们想要判断空接口中值的类型，那么这个时候就可以使用类型断言，其语法格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x.(T)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示类型为interface{}的变量（不一定是空接口，也可以是非空接口）</li><li>T：表示断言x可能是的类型</li></ul><p>该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个参数是一个布尔值，为true则表示断言成功，为false则表示断言失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br>a = <span class="hljs-number">20</span><br>v, ok := a.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;a就是一个string类型，值是：&quot;</span>, v)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;断言失败, %v %T\n&quot;</span>, v, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以使用x.(type)判断一个变量的类型，这个语句只能用在switch语句里面</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br>    <span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        fmt.Println(<span class="hljs-string">&quot;int类型&quot;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        fmt.Println(<span class="hljs-string">&quot;string类型&quot;</span>)<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>        fmt.Println(<span class="hljs-string">&quot;bool类型&quot;</span>)<br>        <span class="hljs-keyword">default</span>:<br>        fmt.Println(<span class="hljs-string">&quot;类型错误&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体接收者和指针接收者实现接口的区别"><a href="#结构体接收者和指针接收者实现接口的区别" class="headerlink" title="结构体接收者和指针接收者实现接口的区别"></a>结构体接收者和指针接收者实现接口的区别</h2><p>值接收者：</p><ul><li>如果结构体中的方法是值接收者，那么实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量，如下所示：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Usber <span class="hljs-keyword">interface</span> &#123;<br>start()<br>stop()<br>&#125;<br><br><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Phone)</span></span> start() &#123;<br>fmt.Println(p.Name, <span class="hljs-string">&quot;启动&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Phone)</span></span> stop()  &#123;<br>fmt.Println(p.Name, <span class="hljs-string">&quot;关机&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><br><span class="hljs-keyword">var</span> p1 = Phone&#123;<br>Name: <span class="hljs-string">&quot;hw&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> p2 Usber = p1<span class="hljs-comment">//结构体变量可以赋值给接口变量</span><br>p2.start()<br><br><span class="hljs-keyword">var</span> p3 = &amp;Phone&#123;<br>Name: <span class="hljs-string">&quot;mi&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> p4 Usber = p3 <span class="hljs-comment">//结构体指针变量可以赋值给接口变量</span><br>p4.start()<br><br>&#125;<br></code></pre></td></tr></table></figure><p>指针接收者：</p><ul><li>如果结构体中的方法是指针接收者，那么实例化后的结构体只有结构体指针类型可以赋值给接口变量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Usber <span class="hljs-keyword">interface</span> &#123;<br>start()<br>stop()<br>&#125;<br><br><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Phone)</span></span> start() &#123;<span class="hljs-comment">//修改为指针接收者</span><br>fmt.Println(p.Name, <span class="hljs-string">&quot;启动&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Phone)</span></span> stop()  &#123;<br>fmt.Println(p.Name, <span class="hljs-string">&quot;关机&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><br><span class="hljs-keyword">var</span> p1 = Phone&#123;<br>Name: <span class="hljs-string">&quot;hw&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">//var p2 Usber = p1 //会报错</span><br><span class="hljs-comment">//p2.start()</span><br>    <br>    <span class="hljs-keyword">var</span> p3 = &amp;Phone&#123;<br>Name: <span class="hljs-string">&quot;mi&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> p4 Usber = p3<br>p4.start()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animaler <span class="hljs-keyword">interface</span> &#123;<br>SetName(<span class="hljs-type">string</span>)<br>GetName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Dog1 <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog1)</span></span> SetName(name <span class="hljs-type">string</span>)  &#123;<br>d.Name = name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog1)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> d.Name<br>&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span></span> SetName(name <span class="hljs-type">string</span>)  &#123;<br>c.Name = name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> c.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//Dog实现Animal的接口</span><br>d := &amp;Dog1&#123;Name: <span class="hljs-string">&quot;d&quot;</span>&#125;<br><span class="hljs-keyword">var</span> a Animaler = d<br>fmt.Println(a.GetName())<br>a.SetName(<span class="hljs-string">&quot;dd&quot;</span>)<br>fmt.Println(a.GetName())<br><br>c := &amp;Cat&#123;Name: <span class="hljs-string">&quot;c&quot;</span>&#125;<br>a = c<br>fmt.Println(a.GetName())<br>a.SetName(<span class="hljs-string">&quot;cc&quot;</span>)<br>fmt.Println(a.GetName())<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个结构体实现多个接口"><a href="#一个结构体实现多个接口" class="headerlink" title="一个结构体实现多个接口"></a>一个结构体实现多个接口</h2><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animaler1 <span class="hljs-keyword">interface</span> &#123;<br>SetName(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Animaler2 <span class="hljs-keyword">interface</span> &#123;<br>GetName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Dog1 <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog1)</span></span> SetName(name <span class="hljs-type">string</span>)  &#123;<br>d.Name = name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog1)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> d.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := &amp;Dog1&#123;Name: <span class="hljs-string">&quot;d&quot;</span>&#125;<br><span class="hljs-keyword">var</span> d1 Animaler1 = d<span class="hljs-comment">//表示让Dog实现Animaler1接口</span><br><span class="hljs-keyword">var</span> d2 Animaler2 = d<span class="hljs-comment">//表示让Dog实现Animaler2接口</span><br>d1.SetName(<span class="hljs-string">&quot;dd&quot;</span>)<br>fmt.Println(d2.GetName())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口与接口间可以通过嵌套创造出新的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AInterface <span class="hljs-keyword">interface</span> &#123;<br>SetName(<span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> BInterface <span class="hljs-keyword">interface</span> &#123;<br>GetName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Animaler <span class="hljs-keyword">interface</span> &#123;<br>AInterface<br>BInterface<br>&#125;<br></code></pre></td></tr></table></figure><p>实现Animaler接口需要实现内部接口的所有方法</p><h2 id="Golang中空接口和类型断言使用细节"><a href="#Golang中空接口和类型断言使用细节" class="headerlink" title="Golang中空接口和类型断言使用细节"></a>Golang中空接口和类型断言使用细节</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>userinfo[<span class="hljs-string">&quot;username&quot;</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>userinfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">20</span><br>userinfo[<span class="hljs-string">&quot;hobby&quot;</span>] = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;睡觉&quot;</span>, <span class="hljs-string">&quot;吃饭&quot;</span>&#125;<br>fmt.Println(userinfo[<span class="hljs-string">&quot;username&quot;</span>])<br><span class="hljs-comment">//fmt.Println(userinfo[&quot;hobby&quot;][0]) //报错</span><br>    <span class="hljs-comment">//空接口类型不支持索引</span><br>    <br>    <span class="hljs-comment">//可以通过类型断言获取</span><br>    hobby, ok := userinfo[<span class="hljs-string">&quot;hobby&quot;</span>].([]<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(hobby[<span class="hljs-number">0</span>])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go错误处理"><a href="#Go错误处理" class="headerlink" title="Go错误处理"></a>Go错误处理</h1><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p><p>error类型是一个接口类型，这是它的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以在编码中通过实现 error 接口类型来生成错误信息。</p><p>函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(f <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;math: square root of negative number&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> math.Sqrt(f), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Go并发"><a href="#Go并发" class="headerlink" title="Go并发"></a>Go并发</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发：多个线程同时竞争一个位置，竞争到的才可以执行，每个时间段只有一个线程在执行。</p><p>并行：多个线程可以同时执行，每个时间段可以有多个线程同时执行。</p><p>通俗地讲：多线程程序在单核CPU上面运行就是<strong>并发</strong>，多线程程序在多核CPU上运行就是<strong>并行</strong>，如果线程数大于CPU核数，则多线程程序在多个CPU上面运行既有并行又有并发。</p><h2 id="Golang中的协程（goroutine）以及主线程"><a href="#Golang中的协程（goroutine）以及主线程" class="headerlink" title="Golang中的协程（goroutine）以及主线程"></a>Golang中的协程（goroutine）以及主线程</h2><p><strong>golang中的主线程</strong>：在一个Golang程序的主线程上可以起<strong>多个协程</strong>。Golang中多协程可以实现并行或者并发。</p><p><strong>协程</strong>：可以理解为用户级线程，这是对内核透明的，也就是系统并不知道协程的存在，是完全由用户自己的程序进行调度的。Golang的一大特色就是从语言层面原生支持协程，在函数或者方法前面加go关键字就可以创建一个协程。可以说Golang中的协程就是goroutine。</p><p><strong>多协程和多线程</strong>：Golang中每个goroutine（协程）默认占用内存远比Java、C的线程少。OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB左右），一个goroutine（协程）占用内存非常小，只有2KB左右，多协程切换调度开销方面远比线程要少。</p><p>Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p><p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p><p>goroutine 语法格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> 函数名(参数列表)<br><span class="hljs-comment">//例如</span><br><span class="hljs-keyword">go</span> f(x,y,z)<br></code></pre></td></tr></table></figure><p>Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">say</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>                time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>                fmt.Println(s)<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">go</span> say(<span class="hljs-string">&quot;world&quot;</span>)<br>        say(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：主协程代码执行完毕会直接退出程序，不会等子协程执行结束</p><p>sync.WaitGroup可以实现主线程等待协程执行完毕。</p><p>举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;1 -- 你好golang-&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;<br>wg.Done() <span class="hljs-comment">//协程计数器减1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printHello2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;2 -- 你好golang-&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">//协程计数器加1</span><br><span class="hljs-keyword">go</span> printHello1()<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> printHello2()<br><br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;主线程退出&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>统计200000内素数举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1协程 统计 1-50000</span><br><span class="hljs-comment">2协程 统计 50001-100000</span><br><span class="hljs-comment">3协程 统计 100001-150000</span><br><span class="hljs-comment">4协程 统计 150001-200000</span><br><span class="hljs-comment">(n-1)*50000 + 1, n*50000</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//输出素数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">suShu</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>start := time.Now().Unix()<br><span class="hljs-keyword">for</span> num := (n - <span class="hljs-number">1</span>) * <span class="hljs-number">50000</span> + <span class="hljs-number">1</span>; num &lt; n * <span class="hljs-number">50000</span>; num++ &#123;<br>        <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; num; i++ &#123;<br><span class="hljs-keyword">if</span> num%i == <span class="hljs-number">0</span> &#123;<br>flag = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> flag &#123;<br><span class="hljs-comment">//fmt.Println(num, &quot;是素数&quot;)</span><br>&#125;<br>&#125;<br>&#125;<br>end := time.Now().Unix()<br>fmt.Println(end - start, <span class="hljs-string">&quot;s&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now().Unix()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> suShu(i)<br>&#125;<br>wg.Wait()<br>end := time.Now().Unix()<br>fmt.Printf(<span class="hljs-string">&quot;程序执行完成共耗时 %v s&quot;</span>, end - start)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：单协程执行耗时4s，4协程执行耗时1s</p><h2 id="设置Golang并行运行的时候占用的cpu数量"><a href="#设置Golang并行运行的时候占用的cpu数量" class="headerlink" title="设置Golang并行运行的时候占用的cpu数量"></a>设置Golang并行运行的时候占用的cpu数量</h2><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上。</p><p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。可以通过runtime.NumCPU()获取当前计算机上的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><h2 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h2><p>通道是Go语言在语言级别上提供的goroutine间的通讯方式，我们可以使用channel在多个goroutine之间传递消息。如果说goroutine是Go程序并发的执行体，，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>Go语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循<strong>先入先出（First In First Out）</strong>的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><p>channel是一种类型，一种<strong>引用类型</strong></p><h3 id="声明channel"><a href="#声明channel" class="headerlink" title="声明channel"></a>声明channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量 <span class="hljs-keyword">chan</span> 元素类型<br><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><span class="hljs-comment">//声明一个传递整型的通道</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><span class="hljs-comment">//声明一个传递布尔类型的通道</span><br><span class="hljs-keyword">var</span> ch3 <span class="hljs-keyword">chan</span> []<span class="hljs-type">int</span><span class="hljs-comment">//声明一个传递int切片类型的通道</span><br></code></pre></td></tr></table></figure><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>声明的通道需要使用make函数初始化之后才能使用。</p><p>创建channel的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> 元素类型, 容量)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建一个能存储10个int类型数据的通道</span><br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 <code>&lt;-</code> 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- v    <span class="hljs-comment">// 把 v 发送到通道 ch</span><br>v := &lt;-ch  <span class="hljs-comment">// 从 ch 接收数据</span><br>           <span class="hljs-comment">// 并把值赋给 v</span><br>&lt;-ch<span class="hljs-comment">//从ch中接收值，忽略结果</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>        sum := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>                sum += v<br>        &#125;<br>        c &lt;- sum <span class="hljs-comment">// 把 sum 发送到通道 c</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;<br><br>        c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>        <span class="hljs-keyword">go</span> sum(s[:<span class="hljs-built_in">len</span>(s)/<span class="hljs-number">2</span>], c)<br>        <span class="hljs-keyword">go</span> sum(s[<span class="hljs-built_in">len</span>(s)/<span class="hljs-number">2</span>:], c)<br>        x, y := &lt;-c, &lt;-c <span class="hljs-comment">// 从通道 c 中接收</span><br><br>        fmt.Println(x, y, x+y) <span class="hljs-comment">// -5 17 12</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p><p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p><p><strong>注意</strong>：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 这里我们定义了一个可以存储整数类型的带缓冲通道</span><br>        <span class="hljs-comment">// 缓冲区大小为2</span><br>        ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span><br>        <span class="hljs-comment">// 而不用立刻需要去同步读取数据</span><br>        ch &lt;- <span class="hljs-number">1</span><br>        ch &lt;- <span class="hljs-number">2</span><br><br>        <span class="hljs-comment">// 获取这两个数据</span><br>        fmt.Println(&lt;-ch)<span class="hljs-comment">//1</span><br>        fmt.Println(&lt;-ch)<span class="hljs-comment">//2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go遍历通道与关闭通道"><a href="#Go遍历通道与关闭通道" class="headerlink" title="Go遍历通道与关闭通道"></a>Go遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 <strong>close()</strong> 函数来关闭。关闭通道的操作只由发送方执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>        x, y := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>                c &lt;- x<br>                x, y = y, x+y<br>        &#125;<br>        <span class="hljs-built_in">close</span>(c)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">go</span> fibonacci(<span class="hljs-built_in">cap</span>(c), c)<br>        <span class="hljs-comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span><br>        <span class="hljs-comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span><br>        <span class="hljs-comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span><br>        <span class="hljs-comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br>                fmt.Println(i)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>goroutine与channel结合使用案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//写数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fun1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ch &lt;- i<br>fmt.Printf(<span class="hljs-string">&quot;【写入】数据%v成功\n&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;<br><br><span class="hljs-comment">//读数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fun2</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Printf(<span class="hljs-string">&quot;【读取】数据%v成功\n&quot;</span>, v)<br>time.Sleep(time.Millisecond * <span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> fun1(ch)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> fun2(ch)<br><br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;退出...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h2><p>Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 就是只能用于写入或者只能用于读取数据。当然 channel 本身必然是同时支持读写的，否则根本没法用。</p><p>假如一个 channel 真的只能读取数据，那么它肯定只会是空的，因为你没机会往里面写数据。同理，如果一个 channel 只允许写入数据，即使写进去了，也没有丝毫意义，因为没有办法读取到里面的数据。所谓的单向 channel 概念，其实只是对 channel 的一种使用限制。</p><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 通道实例 <span class="hljs-keyword">chan</span>&lt;- 元素类型    <span class="hljs-comment">// 只能写入数据的通道</span><br><span class="hljs-keyword">var</span> 通道实例 &lt;-<span class="hljs-keyword">chan</span> 元素类型    <span class="hljs-comment">// 只能读取数据的通道</span><br><br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">//声明通道为只写</span><br>ch2 := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">//声明通道为只读</span><br></code></pre></td></tr></table></figure><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。这个时候就可以用到golang中给我们提供的select多路复用。</p><p>通常情况通道在接收数据时，如果没有数据可以接收将会发生阻塞。</p><p>select 是 Go 中的一个控制结构，类似于 switch 语句。</p><p>select 语句只能用于通道操作，每个 case 必须是一个通道操作，要么是发送要么是接收。</p><p>select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。</p><p>如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码。</p><p>go语言中select语句的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> &lt;- channel1:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> value := &lt;- channel2:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> channel3 &lt;- value:<br>    <span class="hljs-comment">// 执行的代码</span><br><br>    <span class="hljs-comment">// 你可以定义任意数量的 case</span><br><br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 所有通道都没有准备好，执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下描述了 select 语句的语法：</p><ul><li><p>每个 case 都必须是一个通道</p></li><li><p>所有 channel 表达式都会被求值</p></li><li><p>所有被发送的表达式都会被求值</p></li><li><p>如果任意某个通道可以进行，它就执行，其他被忽略。</p></li><li><p>如果有多个 case 都可以运行，select 会随机公平地选出一个执行，其他不会执行。</p><p>否则：</p><ol><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通道可以运行；Go 不会重新对 channel 或值进行求值。</li></ol></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>intChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>intChan &lt;- i<br>&#125;<br><span class="hljs-comment">//close(intChan)//无需关闭，关闭会导致死循环</span><br><br>stringChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>stringChan &lt;- <span class="hljs-string">&quot;hello_&quot;</span> + strconv.FormatInt(<span class="hljs-type">int64</span>(i), <span class="hljs-number">10</span>)<br>&#125;<br><br><span class="hljs-comment">//使用select来获取channel里面的数据的时候不需要关闭channel</span><br>Loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-intChan:<br>fmt.Printf(<span class="hljs-string">&quot;从 intChan 读取的数据%d\n&quot;</span>, v)<br><span class="hljs-keyword">case</span> v := &lt;-stringChan:<br>fmt.Printf(<span class="hljs-string">&quot;从 stringChan 读取的数据%s\n&quot;</span>, v)<br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;数据获取完毕\n&quot;</span>)<br><span class="hljs-keyword">break</span> Loop <span class="hljs-comment">//使用goto退出也可</span><br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;程序执行完毕&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用select来获取channel里面的数据的时候不需要关闭channel</strong></p><h2 id="goroutine-Recover解决协程中出现的panic"><a href="#goroutine-Recover解决协程中出现的panic" class="headerlink" title="goroutine Recover解决协程中出现的panic"></a>goroutine Recover解决协程中出现的panic</h2><p>通常一个协程报错会导致其他协程停止执行</p><p>实现一个协程报错不影响其他协程执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>time.Sleep(time.Millisecond * <span class="hljs-number">50</span>)<br>fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != any(<span class="hljs-literal">nil</span>) &#123;<br>fmt.Println(<span class="hljs-string">&quot;test()发生错误&quot;</span>, err)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">var</span> myMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span><br><br>myMap[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;golang&quot;</span><span class="hljs-comment">//error</span><br>fmt.Printf(<span class="hljs-string">&quot;这行代码不会执行\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> sayHello()<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> test2()<br><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是传统并发编程中对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前的共享资源，Unlook进行解锁。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>Go中的读写锁由结构体类型sync.RWMutex表示。</p><h1 id="Go-reflect（反射）"><a href="#Go-reflect（反射）" class="headerlink" title="Go reflect（反射）"></a>Go reflect（反射）</h1><h2 id="反射引言"><a href="#反射引言" class="headerlink" title="反射引言"></a>反射引言</h2><p>有时需要写一个函数，这个函数有能力统一处理各种值类型，而这些类型可能无法共享同一个接口，也可能布局未知，也有可能这个类型在我们设计函数时还不存在，这个时候我们就可以用到反射。</p><ol><li>空接口可以存储任意类型的变量，那么如何知道这个空接口保存数据的类型是是什么？<ol><li>可以使用断言</li><li>可以使用反射，也就是在程序运行时动态地获取一个变量的类型信息和值信息。</li></ol></li></ol><h2 id="反射的基本介绍"><a href="#反射的基本介绍" class="headerlink" title="反射的基本介绍"></a>反射的基本介绍</h2><p>反射是指在程序运行期间对程序本身进行访问和修改的能力。正常情况程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><h3 id="Go可以实现的功能："><a href="#Go可以实现的功能：" class="headerlink" title="Go可以实现的功能："></a>Go可以实现的功能：</h3><ol><li>反射可以在程序运行期间动态获取变量的各种信息，比如变量的类型、类别</li><li>如果是结构体，通过反射还可以获得结构体本身的信息，比如结构体的字段、结构体的方法。</li><li>通过反射，可以修改变量的值，可以调用关联的方法。</li></ol><h3 id="Go语言中的变量是分为两部分的："><a href="#Go语言中的变量是分为两部分的：" class="headerlink" title="Go语言中的变量是分为两部分的："></a>Go语言中的变量是分为两部分的：</h3><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><p>在Go语言的反射机制中，任何接口值都是一个<strong>具体类型</strong>和<strong>具体类型的值</strong>两部分组成的。</p><p>在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个重要函数来获取任意对象的Value和Type。</p><h2 id="reflect-TypeOf-获取任意值的类型对象"><a href="#reflect-TypeOf-获取任意值的类型对象" class="headerlink" title="reflect.TypeOf()获取任意值的类型对象"></a>reflect.TypeOf()获取任意值的类型对象</h2><p>在Go语言中，使用reflect.TypeOf()函数可以接受任意interface{}参数，可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息</p><h3 id="type-Name和type-Kind"><a href="#type-Name和type-Kind" class="headerlink" title="type Name和type Kind"></a>type Name和type Kind</h3><p><strong>在反射中关于类型还划分为两种：</strong>类型（type）和种类（kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<strong>种类</strong>（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的种类时，就会用到种类（Kind）。</p><p>数组、切片、Map、指针类型的变量，它们的.Name()都是返回空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt2 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> Person2 <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectFn</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;<br>v := reflect.TypeOf(x)<br><br>fmt.Printf(<span class="hljs-string">&quot;类型:%v 类型名称:%v 类型种类:%v\n&quot;</span>, v, v.Name(), v.Kind())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>a := <span class="hljs-number">10</span><br>b := <span class="hljs-number">23.4</span><br>c := <span class="hljs-literal">true</span><br>d := <span class="hljs-string">&quot;你好go&quot;</span><br>reflectFn(a)<span class="hljs-comment">//int</span><br>reflectFn(b)<span class="hljs-comment">//float64</span><br>reflectFn(c)<span class="hljs-comment">//bool</span><br>reflectFn(d)<span class="hljs-comment">//string</span><br><br><span class="hljs-keyword">var</span> e myInt2 = <span class="hljs-number">34</span><br><span class="hljs-keyword">var</span> f = Person2&#123;<br>Name: <span class="hljs-string">&quot;张三&quot;</span>,<br>Age:  <span class="hljs-number">20</span>,<br>&#125;<br>reflectFn(e)<span class="hljs-comment">//main.myint</span><br>reflectFn(f)<span class="hljs-comment">//main.Person</span><br><br><span class="hljs-keyword">var</span> h = <span class="hljs-number">25</span><br>reflectFn(&amp;h)<br>    <br>    <span class="hljs-keyword">var</span> i = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> j = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>&#125;<br>reflectFn(i)<br>reflectFn(j)<br>&#125;<br><span class="hljs-comment">//类型:int 类型名称:int 类型种类:int</span><br><span class="hljs-comment">//类型:float64 类型名称:float64 类型种类:float64</span><br><span class="hljs-comment">//类型:bool 类型名称:bool 类型种类:bool</span><br><span class="hljs-comment">//类型:string 类型名称:string 类型种类:string</span><br><span class="hljs-comment">//类型:main.myInt2 类型名称:myInt2 类型种类:int</span><br><span class="hljs-comment">//类型:main.Person2 类型名称:Person2 类型种类:struct</span><br><span class="hljs-comment">//类型:*int 类型名称: 类型种类:ptr</span><br><span class="hljs-comment">//类型:[3]int 类型名称: 类型种类:array</span><br><span class="hljs-comment">//类型:[]int 类型名称: 类型种类:slice</span><br></code></pre></td></tr></table></figure><p>种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Kind <span class="hljs-type">uint</span><br><span class="hljs-keyword">const</span> (<br>    Invalid Kind = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// 非法类型</span><br>    Bool                 <span class="hljs-comment">// 布尔型</span><br>    Int                  <span class="hljs-comment">// 有符号整型</span><br>    Int8                 <span class="hljs-comment">// 有符号8位整型</span><br>    Int16                <span class="hljs-comment">// 有符号16位整型</span><br>    Int32                <span class="hljs-comment">// 有符号32位整型</span><br>    Int64                <span class="hljs-comment">// 有符号64位整型</span><br>    Uint                 <span class="hljs-comment">// 无符号整型</span><br>    Uint8                <span class="hljs-comment">// 无符号8位整型</span><br>    Uint16               <span class="hljs-comment">// 无符号16位整型</span><br>    Uint32               <span class="hljs-comment">// 无符号32位整型</span><br>    Uint64               <span class="hljs-comment">// 无符号64位整型</span><br>    Uintptr              <span class="hljs-comment">// 指针</span><br>    Float32              <span class="hljs-comment">// 单精度浮点数</span><br>    Float64              <span class="hljs-comment">// 双精度浮点数</span><br>    Complex64            <span class="hljs-comment">// 64位复数类型</span><br>    Complex128           <span class="hljs-comment">// 128位复数类型</span><br>    Array                <span class="hljs-comment">// 数组</span><br>    Chan                 <span class="hljs-comment">// 通道</span><br>    Func                 <span class="hljs-comment">// 函数</span><br>    Interface            <span class="hljs-comment">// 接口</span><br>    Map                  <span class="hljs-comment">// 映射</span><br>    Ptr                  <span class="hljs-comment">// 指针</span><br>    Slice                <span class="hljs-comment">// 切片</span><br>    String               <span class="hljs-comment">// 字符串</span><br>    Struct               <span class="hljs-comment">// 结构体</span><br>    UnsafePointer        <span class="hljs-comment">// 底层指针</span><br>)<br></code></pre></td></tr></table></figure><h2 id="reflect-ValueOf"><a href="#reflect-ValueOf" class="headerlink" title="reflect.ValueOf()"></a>reflect.ValueOf()</h2><p>reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以相互转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;<br>v := reflect.ValueOf(x)<br>fmt.Println(v)<br><br><span class="hljs-keyword">var</span> n = v.Int() + <span class="hljs-number">12</span><span class="hljs-comment">//v.Int()获取原始值</span><br>fmt.Println(n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">23</span><br>reflectValue(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>reflect.Value类型提供的获取原始值的方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Interface() interface{}</td><td>将以interface{}类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td>Int() int64</td><td>将值以int类型返回，所有的有符号整型均可以此方式返回</td></tr><tr><td>Uint() uint64</td><td>将值以uint类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td>Float() float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td>Bool() bool</td><td>将值以bool类型返回</td></tr><tr><td>Bytes() []bytes</td><td>将值以字节数组[]bytes类型返回</td></tr><tr><td>String() string</td><td>将值以此字符串类型返回</td></tr></tbody></table><h2 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h2><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectValue1</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br>v := reflect.ValueOf(x)<br>fmt.Println(v.Kind())<br>fmt.Println(v.Elem().Kind())<br><span class="hljs-keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;<br>v.Elem().SetInt(<span class="hljs-number">120</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v.Elem().Kind() == reflect.String &#123;<br>v.Elem().SetString(<span class="hljs-string">&quot;你好Go&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int64</span> = <span class="hljs-number">100</span><br>reflectValue1(&amp;a)<br>fmt.Println(a)<br><br><span class="hljs-keyword">var</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;你好golang&quot;</span><br>reflectValue1(&amp;b)<br>fmt.Println(b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h2><h3 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h3><p>任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。</p><p>reflect.Type中与获取结构体成员相关的方法如下表所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) StructField</td><td>根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的信息</td></tr></tbody></table><h3 id="获取结构体属性名称、类型和值等信息-x2F-修改属性值"><a href="#获取结构体属性名称、类型和值等信息-x2F-修改属性值" class="headerlink" title="获取结构体属性名称、类型和值等信息&#x2F;修改属性值"></a>获取结构体属性名称、类型和值等信息&#x2F;修改属性值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Students <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;age&quot;`</span><br>Score <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;score&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Students)</span></span>GetInfo() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> str = fmt.Sprintf(<span class="hljs-string">&quot;姓名:%v 年龄:%v 成绩:%v\n&quot;</span>, s.Name, s.Age, s.Score)<br><span class="hljs-keyword">return</span> str<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Students)</span></span>SetInfo(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>, score <span class="hljs-type">int</span>)  &#123;<br>s.Name = name<br>s.Age = age<br>s.Score = score<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printStructField</span><span class="hljs-params">(s <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;<br><br><span class="hljs-comment">//判断参数是不是结构体类型</span><br>t := reflect.TypeOf(s)<br>v := reflect.ValueOf(s)<br><span class="hljs-keyword">if</span> t.Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Struct &#123;<br>fmt.Println(<span class="hljs-string">&quot;传入的参数不是结构体&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">//1.通过类型变量里面的Field可以获取结构体的字段</span><br>field0 := t.Elem().Field(<span class="hljs-number">0</span>)<span class="hljs-comment">//参数传的结构体指针用这个</span><br><span class="hljs-comment">//field0 := t.Field(0)//参数传的结构体变量用这个</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v, %T\n&quot;</span>, field0, field0)<br>fmt.Println(<span class="hljs-string">&quot;字段名称：&quot;</span>, field0.Name)<br>fmt.Println(<span class="hljs-string">&quot;字段类型：&quot;</span>, field0.Type)<br>fmt.Println(<span class="hljs-string">&quot;字段Tag：&quot;</span>, field0.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br><br><span class="hljs-comment">//2.通过类型变量里面的FieldByName可以获取结构体的字段</span><br>field1, ok := t.Elem().FieldByName(<span class="hljs-string">&quot;Age&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;字段名称：&quot;</span>, field1.Name)<br>fmt.Println(<span class="hljs-string">&quot;字段类型：&quot;</span>, field1.Type)<br>fmt.Println(<span class="hljs-string">&quot;字段Tag：&quot;</span>, field1.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">//3.通过类型变量里面的NumField获取该结构体有几个字段</span><br>fmt.Println(<span class="hljs-string">&quot;结构体有 &quot;</span>, t.Elem().NumField(), <span class="hljs-string">&quot; 个属性&quot;</span>)<br><br><span class="hljs-comment">//4.获取结构体属性对应的值</span><br>fmt.Println(v.Elem().FieldByName(<span class="hljs-string">&quot;Name&quot;</span>))<br><br>fmt.Println(<span class="hljs-string">&quot;-------------&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.Elem().NumField(); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;属性名称：%v 属性值：%v 属性类型：%v 属性Tag：%v\n&quot;</span>, t.Elem().Field(i).Name, v.Elem().Field(i), t.Elem().Field(i).Type, t.Elem().Field(i).Tag)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>stu1 := Students&#123;<br>Name:  <span class="hljs-string">&quot;小明&quot;</span>,<br>Age:   <span class="hljs-number">15</span>,<br>Score: <span class="hljs-number">98</span>,<br>&#125;<br>printStructField(&amp;stu1)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取结构体方法并调用"><a href="#获取结构体方法并调用" class="headerlink" title="获取结构体方法并调用"></a>获取结构体方法并调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printStructFn</span><span class="hljs-params">(s <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;<br><br>t := reflect.TypeOf(s)<br>v := reflect.ValueOf(s)<br><span class="hljs-keyword">if</span> t.Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Struct &#123;<br>fmt.Println(<span class="hljs-string">&quot;传入的参数不是结构体&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">//1.通过类型变量里面的Method可以获取结构体的方法</span><br>method0 := t.Method(<span class="hljs-number">0</span>)<span class="hljs-comment">//和结构体方法的顺序没有关系，与结构体方法的ASCII有关系</span><br>fmt.Println(method0.Name)<br>fmt.Println(method0.Type)<br><br>method1, ok := t.MethodByName(<span class="hljs-string">&quot;GetInfo&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(method1.Name)<br>fmt.Println(method1.Type)<br>&#125;<br><br><span class="hljs-comment">//2.通过类型变量获取这个结构体有多少个方法</span><br>fmt.Println(<span class="hljs-string">&quot;方法数量：&quot;</span>, t.NumMethod())<br><br><span class="hljs-comment">//3.通过《值变量》执行方法（注意需要使用值变量，并且要注意参数） v.Method(0).call(nil)</span><br>info := v.MethodByName(<span class="hljs-string">&quot;GetInfo&quot;</span>).Call(<span class="hljs-literal">nil</span>)<br>fmt.Println(info)<br><br><span class="hljs-comment">//4.执行方法传入参数（注意需要使用《值变量》，并且要注意参数，接收的参数是[]reflect.Value的切片）</span><br><span class="hljs-keyword">var</span> params []reflect.Value<br>params = <span class="hljs-built_in">append</span>(params, reflect.ValueOf(<span class="hljs-string">&quot;李四&quot;</span>))<br>params = <span class="hljs-built_in">append</span>(params, reflect.ValueOf(<span class="hljs-number">20</span>))<br>params = <span class="hljs-built_in">append</span>(params, reflect.ValueOf(<span class="hljs-number">99</span>))<br><br>v.MethodByName(<span class="hljs-string">&quot;SetInfo&quot;</span>).Call(params)<br>info = v.MethodByName(<span class="hljs-string">&quot;GetInfo&quot;</span>).Call(<span class="hljs-literal">nil</span>)<br>fmt.Println(info)<br><br>&#125;<br><br><span class="hljs-comment">//反射修改结构体值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectChangeStruct</span><span class="hljs-params">(s <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br>t := reflect.TypeOf(s)<br>v := reflect.ValueOf(s)<br><span class="hljs-keyword">if</span> t.Kind() != reflect.Ptr &#123;<br>fmt.Println(<span class="hljs-string">&quot;传入的不是指针类型&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.Elem().Kind() != reflect.Struct &#123;<br>fmt.Println(<span class="hljs-string">&quot;传入的不是结构体指针类型&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>v.Elem().FieldByName(<span class="hljs-string">&quot;Name&quot;</span>).SetString(<span class="hljs-string">&quot;czh&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stu1 := Students&#123;<br>Name:  <span class="hljs-string">&quot;小明&quot;</span>,<br>Age:   <span class="hljs-number">15</span>,<br>Score: <span class="hljs-number">98</span>,<br>&#125;<br>printStructFn(&amp;stu1)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不要乱用反射"><a href="#不要乱用反射" class="headerlink" title="不要乱用反射"></a>不要乱用反射</h2><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码，但是反射不应该被滥用，原因：</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic。</li><li>大量使用反射的代码通常难以理解。</li></ol><h1 id="Golang文件和目录操作"><a href="#Golang文件和目录操作" class="headerlink" title="Golang文件和目录操作"></a>Golang文件和目录操作</h1><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>方法一：</p><ol><li><p><em><strong><u>只读方式打开文件</u></strong></em> file, err :&#x3D; os.Open()</p></li><li><p>读取文件 file.Read()</p></li><li><p>关闭文件流 defer file.Close()</p></li></ol><p>方法二：bufio读取文件</p><ol><li>只读方式打开文件 file, err :&#x3D; os.Open()</li><li>创建reader对象 reader :&#x3D; bufio.NewReader(file)</li><li>ReadString读取文件 line, err :&#x3D; reader.ReadString(‘\n’)</li><li>关闭文件流  defer file.Close()</li></ol><p>方法三：ioutil读取文件，打开关闭文件的方法它都封装好了只需要一句话就可以读取</p><p>ioutil.ReadFile(“.&#x2F;main.go”)</p><p>（ioutil从1.16起被废弃，改为os.ReadFile()）</p><p>方法一实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//方法一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//1.打开文件</span><br>file, err := os.Open(<span class="hljs-string">&quot;./file.go&quot;</span>)<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">//2.读取文件内容</span><br><span class="hljs-keyword">var</span> strSlice []<span class="hljs-type">byte</span><br><span class="hljs-keyword">var</span> tempSlice = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">128</span>)<br><span class="hljs-keyword">for</span> &#123;<br>n, err := file.Read(tempSlice)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取完毕&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取失败&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;读取到了%v个字节\n&quot;</span>, n)<br>strSlice = <span class="hljs-built_in">append</span>(strSlice, tempSlice[:n]...)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(strSlice))<br><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.Open(<span class="hljs-string">&quot;./file.go&quot;</span>)<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">//bufio</span><br><span class="hljs-keyword">var</span> fileStr <span class="hljs-type">string</span><br>reader := bufio.NewReader(file)<br><span class="hljs-keyword">for</span> &#123;<br>line, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-comment">//fileStr += line</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fileStr += line<br>&#125;<br><br>fmt.Println(fileStr)<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span> &#123;<br>byteStr, err := os.ReadFile(<span class="hljs-string">&quot;./file.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(byteStr))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>方法一：</p><ol><li>打开文件 file, err :&#x3D; os.OpenFile(“.&#x2F;file.go”, “os.O_CREATE|os.O_RDWR”, 0666)</li><li>写入文件<ul><li>file.Write([]byte(str))&#x2F;&#x2F;写入字节切片数据</li><li>file.WriteString(“直接写入字符串数据”)    &#x2F;&#x2F;直接写入字符串数据</li></ul></li><li>关闭文件流 file.Close</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OpenFile</span><span class="hljs-params">(name <span class="hljs-type">string</span>, flag <span class="hljs-type">int</span>, perm FileMode)</span></span> (*File, <span class="hljs-type">error</span>)&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>name:要打开的文件名</li><li>flag:打开的文件的模式</li></ul><p>模式有以下几种：</p><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td>os.O_WRONLY</td><td>只写</td></tr><tr><td>os.O_CREATE</td><td>创建文件</td></tr><tr><td>os.O_RDONLY</td><td>只读</td></tr><tr><td>os.O_RDWR</td><td>读写</td></tr><tr><td>os.O_TRUNC</td><td>清空</td></tr><tr><td>os.O_APPEND</td><td>追加</td></tr></tbody></table><p>perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><p>方法二：bufio写入文件</p><ol><li><p>打开文件 file, err :&#x3D; os.OpenFile(“.&#x2F;file.go”, os.O_CREATE|os.O_RDWR, 0666)</p></li><li><p>创建writer对象 writer :&#x3D; bufio.NewWriter(file)</p></li><li><p>将数据先写入缓存 writer.WriteString(“你好golang\r\n”)</p></li><li><p>将缓存中的内容写入文件 writer.Flush()</p></li><li><p>关闭文件流 file.Close()</p></li></ol><p>方法三：ioutil写入文件（无法追加数据）</p><p>str :&#x3D; “hello golang”</p><p>err :&#x3D; ioutil.WriteFile(“.&#x2F;test.txt”, []byte(str), 0666)</p><p>（ioutil从1.16起被废弃，改为os.WriteFile()）</p><p>方法一实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method11</span><span class="hljs-params">()</span></span>  &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;./test.txt&quot;</span>, os.O_CREATE|os.O_RDWR|os.O_APPEND, <span class="hljs-number">0666</span>)<br><br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>file.WriteString(<span class="hljs-string">&quot;直接写入字符串&quot;</span>+ strconv.FormatInt(<span class="hljs-type">int64</span>(i), <span class="hljs-number">10</span>) +<span class="hljs-string">&quot;\r\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;通过file.Write()直接写入&quot;</span><br>file.Write([]<span class="hljs-type">byte</span>(str))<br><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method22</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;./test.txt&quot;</span>, os.O_CREATE|os.O_RDWR|os.O_APPEND, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">defer</span> file.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>writer := bufio.NewWriter(file)<br>writer.WriteString(<span class="hljs-string">&quot;通过bufio写入\r\n&quot;</span>)<br>writer.Flush()<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method33</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello golang&quot;</span><br>err := os.WriteFile(<span class="hljs-string">&quot;./test.txt&quot;</span>, []<span class="hljs-type">byte</span>(str), <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">err := os.Rename(<span class="hljs-string">&quot;./test.txt&quot;</span>, <span class="hljs-string">&quot;./test1.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p>只能同盘操作</p><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p>方法一：os.ReadFile()方法先读出来，再用os.WriteFile()写入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">input, err := os.ReadFile(srcFileName)<br>err = os.WriteFile(dstFileName, input, <span class="hljs-number">0644</span>)<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">source,_ := os.Open(srcFileName)<br>destination,_ := os.OpenFile(dstFileName, os.O_CREATE|os.O_WRONLY, <span class="hljs-number">0666</span>)<br><br>n, err := source.Read(buf)<br>destination.Write(buf[:n])<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CopyFile</span><span class="hljs-params">(srcFile <span class="hljs-type">string</span>, dstFile <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>sFile, err1 := os.Open(srcFile)<br>    <span class="hljs-keyword">defer</span> sFile.Close()<br>dFile, err2 := os.OpenFile(dstFile, os.O_CREATE|os.O_RDWR|os.O_APPEND, <span class="hljs-number">0666</span>)<br>    <span class="hljs-keyword">defer</span> dFile.Close()<br><span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err1<br>&#125;<br><span class="hljs-keyword">if</span> err2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err2<br>&#125;<br><span class="hljs-keyword">var</span> tempSlice = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">128</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">//读取数据</span><br>n, e1 := sFile.Read(tempSlice)<br><span class="hljs-keyword">if</span> e1 == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> e1 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> e1<br>&#125;<br><br><span class="hljs-comment">//写入数据</span><br><span class="hljs-keyword">if</span> _, e2 := dFile.Write(tempSlice[:n]); e2 != <span class="hljs-literal">nil</span>&#123;<br><span class="hljs-keyword">return</span> e2<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>err := CopyFile(<span class="hljs-string">&quot;./test.txt&quot;</span>, <span class="hljs-string">&quot;./test2.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;拷贝完成\n&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;拷贝错误 err=%v\n&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">err := os.Mkdir(<span class="hljs-string">&quot;./abc&quot;</span>, <span class="hljs-number">0666</span>)<span class="hljs-comment">//已经存在不进行操作，不存在则创建文件夹</span><br><br>err := os.MkdirAll(<span class="hljs-string">&quot;dir1/dir2/dir3&quot;</span>, <span class="hljs-number">0666</span>)<br></code></pre></td></tr></table></figure><h2 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Remove(<span class="hljs-string">&quot;abc/d/e/f&quot;</span>)<span class="hljs-comment">//可以删除目录也可删除文件</span><br>os.RemoveAll(<span class="hljs-string">&quot;/abc&quot;</span>)<span class="hljs-comment">//删除abc下所有目录和文件</span><br></code></pre></td></tr></table></figure><h1 id="格式化输出字符串"><a href="#格式化输出字符串" class="headerlink" title="格式化输出字符串"></a>格式化输出字符串</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 打印结构体</span><br>p := point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v</span><br><span class="hljs-string">&quot;</span>, p) <span class="hljs-comment">//输出结果为 &#123;1 2&#125;</span><br><br><span class="hljs-comment">// 如果值是一个结构体，%+v 变体将包括结构体的字段名。</span><br>fmt.Printf(<span class="hljs-string">&quot;%+v</span><br><span class="hljs-string">&quot;</span>, p) <span class="hljs-comment">//输出结果为 &#123;x:1 y:2&#125;</span><br><br><span class="hljs-comment">// %#v 变体打印值的 Go 语法表示，即将生成该值的源代码片段。</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v</span><br><span class="hljs-string">&quot;</span>, p) <span class="hljs-comment">//输出结果为 main.point&#123;x:1, y:2&#125;</span><br><br><span class="hljs-comment">// 打印类型</span><br>fmt.Printf(<span class="hljs-string">&quot;%T</span><br><span class="hljs-string">&quot;</span>, p) <span class="hljs-comment">//输出结果为 main.point</span><br><br><span class="hljs-comment">// 打印布尔值</span><br>fmt.Printf(<span class="hljs-string">&quot;%t</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">//输出结果为 true</span><br><br><span class="hljs-comment">// 打印整数。</span><br>fmt.Printf(<span class="hljs-string">&quot;%d</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">123</span>) <span class="hljs-comment">//输出结果为 123</span><br><br><span class="hljs-comment">// 打印二进制</span><br>fmt.Printf(<span class="hljs-string">&quot;%b</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">14</span>) <span class="hljs-comment">//输出结果为 1110</span><br><br><span class="hljs-comment">// 打印字符</span><br>fmt.Printf(<span class="hljs-string">&quot;%c</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">33</span>) <span class="hljs-comment">//输出结果为 ！</span><br><br><span class="hljs-comment">// 打印 16 进制</span><br>fmt.Printf(<span class="hljs-string">&quot;%x</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">456</span>) <span class="hljs-comment">//输出结果为 1c8</span><br><br><span class="hljs-comment">// 打印浮点数</span><br>fmt.Printf(<span class="hljs-string">&quot;%f</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">78.9</span>) <span class="hljs-comment">//输出结果为 78.900000</span><br><span class="hljs-comment">// 指数型</span><br>fmt.Printf(<span class="hljs-string">&quot;%e</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">123400000.0</span>) <span class="hljs-comment">//输出结果为 1.234000e+08</span><br>fmt.Printf(<span class="hljs-string">&quot;%E</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">123400000.0</span>) <span class="hljs-comment">//输出结果为 1.234000E+08</span><br><br><span class="hljs-comment">// 字符串</span><br>fmt.Printf(<span class="hljs-string">&quot;%s</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-string">&quot;&quot;</span><span class="hljs-type">string</span><span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">//输出结果为 &quot;string&quot;</span><br><span class="hljs-comment">// 双引号字符串.</span><br>fmt.Printf(<span class="hljs-string">&quot;%q</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-string">&quot;&quot;</span><span class="hljs-type">string</span><span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">//输出结果为 &quot;&quot;string&quot;&quot;</span><br><br><span class="hljs-comment">// 每个字符用两位 16 进制表示。</span><br>fmt.Printf(<span class="hljs-string">&quot;%x</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-string">&quot;hex this&quot;</span>) <span class="hljs-comment">//输出结果为 6865782074686973</span><br><br><span class="hljs-comment">// 打印指针`.</span><br>fmt.Printf(<span class="hljs-string">&quot;%p</span><br><span class="hljs-string">&quot;</span>, &amp;p) <span class="hljs-comment">//输出结果为 0xc00001c08</span><br><br><span class="hljs-comment">// 字符宽度</span><br>fmt.Printf(<span class="hljs-string">&quot;|%6d|%6d|</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">345</span>) <span class="hljs-comment">//输出结果为 |    12|   345|</span><br><br><span class="hljs-comment">//字符精度</span><br>fmt.Printf(<span class="hljs-string">&quot;|%6.2f|%6.2f|</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">3.45</span>) <span class="hljs-comment">//输出结果为 |  1.20|  3.45|</span><br><br><span class="hljs-comment">// 左对齐</span><br>fmt.Printf(<span class="hljs-string">&quot;|%-6.2f|%-6.2f|</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">3.45</span>) <span class="hljs-comment">//输出结果为 |1.20  |3.45  |</span><br><br><span class="hljs-comment">//同样可以控制字符的宽度</span><br>fmt.Printf(<span class="hljs-string">&quot;|%6s|%6s|</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment">//输出结果为 |   foo|     b|</span><br><br><span class="hljs-comment">// 同样字符左对齐.</span><br>fmt.Printf(<span class="hljs-string">&quot;|%-6s|%-6s|</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment">//输出结果为 |foo   |b     |</span><br><br><span class="hljs-comment">// 合并</span><br>s := fmt.Sprintf(<span class="hljs-string">&quot;a %s&quot;</span>, <span class="hljs-string">&quot;string&quot;</span>) <span class="hljs-comment">//输出结果为 a string</span><br>fmt.Println(s) <span class="hljs-comment">//输出结果为</span><br><span class="hljs-comment">// 同样的效果</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;an %s</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>) <span class="hljs-comment">//输出结果为 an error</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="值类型：基本数据类型、数组、结构体"><a href="#值类型：基本数据类型、数组、结构体" class="headerlink" title="值类型：基本数据类型、数组、结构体"></a>值类型：基本数据类型、数组、结构体</h1><h1 id="引用类型：Slice、Map、interface、channel、指针"><a href="#引用类型：Slice、Map、interface、channel、指针" class="headerlink" title="引用类型：Slice、Map、interface、channel、指针"></a>引用类型：Slice、Map、interface、channel、指针</h1><p>函数调用时，Slice、Map、interface、channel默认使用引用传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">arr1 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>arr2 := arr1<br>arr1[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span><br>fmt.Printf(<span class="hljs-string">&quot;arr1:%v, arr2:%v\n&quot;</span>, arr1, arr2)<br><br>slice1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>slice2 := slice1<br>slice1[<span class="hljs-number">0</span>] = <span class="hljs-number">11</span><br>fmt.Printf(<span class="hljs-string">&quot;slice1:%v, slice2:%v\n&quot;</span>, slice1, slice2)<br><br><span class="hljs-comment">//arr1:[11 2 3], arr2:[1 2 3]</span><br><span class="hljs-comment">//slice1:[11 2 3], slice2:[11 2 3]</span><br></code></pre></td></tr></table></figure><h1 id="Go语言中每种类型对应的零值"><a href="#Go语言中每种类型对应的零值" class="headerlink" title="Go语言中每种类型对应的零值"></a>Go语言中每种类型对应的零值</h1><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">bool</span> -&gt;</span> <span class="hljs-literal">false</span><br><span class="hljs-function"><span class="hljs-title">numbers</span> -&gt;</span> <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">string</span> -&gt;</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-function"><span class="hljs-title">pointers</span> -&gt;</span> <span class="hljs-literal">nil</span><br><span class="hljs-function"><span class="hljs-title">slices</span> -&gt;</span> <span class="hljs-literal">nil</span><br><span class="hljs-function"><span class="hljs-title">maps</span> -&gt;</span> <span class="hljs-literal">nil</span><br><span class="hljs-function"><span class="hljs-title">channels</span> -&gt;</span> <span class="hljs-literal">nil</span><br><span class="hljs-function"><span class="hljs-title">functions</span> -&gt;</span> <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h1 id="Go是nil却不等于nil的情况"><a href="#Go是nil却不等于nil的情况" class="headerlink" title="Go是nil却不等于nil的情况"></a>Go是nil却不等于nil的情况</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">//结构体指针</span><br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-comment">//函数指针</span><br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><span class="hljs-comment">//未初始化的map</span><br><br><span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;var a *struct&#123;&#125; is nil&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;var f func() is nil&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;var m map[string]string is nil&quot;</span>)<br>&#125;<br><br>ifList := []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;a, f, m, <span class="hljs-literal">nil</span>&#125;<br><span class="hljs-keyword">for</span> _,item := <span class="hljs-keyword">range</span> ifList &#123;<br><span class="hljs-keyword">if</span> item != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(item, <span class="hljs-string">&quot;is not nil&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(item, <span class="hljs-string">&quot;is nil&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//var a *struct&#123;&#125; is nil</span><br><span class="hljs-comment">//var f func() is nil</span><br><span class="hljs-comment">//var m map[string]string is nil</span><br><span class="hljs-comment">//&lt;nil&gt; is not nil</span><br><span class="hljs-comment">//&lt;nil&gt; is not nil</span><br><span class="hljs-comment">//map[] is not nil</span><br><span class="hljs-comment">//&lt;nil&gt; is nil</span><br></code></pre></td></tr></table></figure><p>原因：有两种interface，一种数据结构的interface（空接口切片的那个），一种关键字定义的interface</p><p>数据结构的interface的本质是eface，另一种接口本质为iface，都是一个结构体包含一个类型字段和一个数据字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//runtime2.go</span><br><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>tab  *itab<br>data unsafe.Pointer<br>&#125;<br><br><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;<br>_type *_type<br>data  unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>对于代码中的空接口类型切片中的元素，有type而没有data，只有当两个字段都是nil的时候才会判断为nil</p><h2 id="在空接口类型的切片中判断元素是否为nil的方法："><a href="#在空接口类型的切片中判断元素是否为nil的方法：" class="headerlink" title="在空接口类型的切片中判断元素是否为nil的方法："></a>在空接口类型的切片中判断元素是否为nil的方法：</h2><p>方法一：通过反射中的IsNil()方法判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reflect.ValueOf(item).IsNil() &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：通过类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> v,ok := item.(*<span class="hljs-keyword">struct</span>&#123;&#125;); ok &amp;&amp; v == <span class="hljs-literal">nil</span> <span class="hljs-comment">//item此时是空接口类型</span><br><br><span class="hljs-keyword">if</span> v,ok := item.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>); ok &amp;&amp; v == <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">if</span> v,ok := item.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>); ok &amp;&amp; v == <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h1 id="Go中的类型比如：channel（通道）、complex（复数类型）、func（函数）均不能进行序列化"><a href="#Go中的类型比如：channel（通道）、complex（复数类型）、func（函数）均不能进行序列化" class="headerlink" title="Go中的类型比如：channel（通道）、complex（复数类型）、func（函数）均不能进行序列化"></a>Go中的类型比如：channel（通道）、complex（复数类型）、func（函数）均不能进行序列化</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud Alibaba</title>
    <link href="/2022/09/29/SpringCloud%20Alibaba/"/>
    <url>/2022/09/29/SpringCloud%20Alibaba/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h1><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本说明 · alibaba&#x2F;spring-cloud-alibaba Wiki · GitHub</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--spring cloud 2021.0.1--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--Spring cloud alibaba 2021.0.1.0--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery">Nacos discovery · alibaba&#x2F;spring-cloud-alibaba Wiki · GitHub</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下载客户端</p><p>默认集群模式（单机需要进行修改）：编辑nacos\bin\startup.cmd，将<code>set MODE=&quot;cluster&quot;</code>改为<code>set MODE=&quot;standalone&quot;</code></p><p>可在<code>nacos\conf\application.properties</code>中添加数据源</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">17221273</span><br></code></pre></td></tr></table></figure><p>账号密码默认：nacos</p><p>集群部署：</p><p>使用nginx进行反向代理，编辑nginx.conf文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs conf">upstream nacoscluster &#123;<br>server 127.0.0.1:8848;<br>server 127.0.0.1:8849;<br>server 127.0.0.1:8850;<br>&#125;<br>server &#123;<br>listen 8847;#nginx服务监听的端口<br>server_name localhost;<br><br>location /nacos/&#123;#/nacos值的是路径前缀，localhost:8847/nacos<br>proxy_pass http://nacoscluster/nacos/;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要修改启动模式为cluster，或使用命令<code> -m -standalone</code></p><p>添加<code>cluster.conf</code>文件写入其他nacos的地址</p><p>将项目中nacos注册的地址<code>spring.clou.nacos.server-addr</code>修改为nginx监听的地址</p><h2 id="负载均衡Ribbon"><a href="#负载均衡Ribbon" class="headerlink" title="负载均衡Ribbon"></a>负载均衡Ribbon</h2><h2 id="负载均衡LoadBalancer"><a href="#负载均衡LoadBalancer" class="headerlink" title="负载均衡LoadBalancer"></a>负载均衡LoadBalancer</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Firstlucky77/article/details/124969555">微服务生态组件之Spring Cloud LoadBalancer详解和源码分析_Firstlucky77的博客-CSDN博客_spring.cloud.loadbalancer</a></p><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置类上使用<code>@EnableFeignClients</code>开启openfeign</p><h3 id="OpenFeign各种问题"><a href="#OpenFeign各种问题" class="headerlink" title="OpenFeign各种问题"></a>OpenFeign各种问题</h3><p><a href="https://blog.csdn.net/weixin_62421895/article/details/126481931">(1条消息) 谈谈Spring Cloud OpenFeign远程调用性能优化_java熬夜党的博客-CSDN博客</a></p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>全局配置：</p><p>使用<code>@Configuration</code>会将配置的作用所有的服务提供方</p><p>局部配置：</p><p>1.通过配置类：如果针对某一个服务进行配置，就不要加@Configuration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-comment">//Logger是feign包下的</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-meta">@FeignClient(name = &quot;service-bravo&quot;, configuration = FeignConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BravoFeign</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/bravo-test/getBravoTestString&quot;)</span><br>    String <span class="hljs-title function_">getBravoTestString</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>2.通过配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>    <span class="hljs-comment">#服务名</span><br>      <span class="hljs-attr">service-alpha:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span><br></code></pre></td></tr></table></figure><h3 id="契约配置"><a href="#契约配置" class="headerlink" title="契约配置"></a>契约配置</h3><p>老版本springcloud使用的是feign，netflix停更后springcloud改用openFeign且支持了springmvc注解，契约配置是对老版本SpringCloud使用的feign的注解的兼容</p><p>注意：修改契约配置后，feign接口不再支持springmvc的注解，需要使用feign原生的注解</p><h3 id="超时时间配置"><a href="#超时时间配置" class="headerlink" title="超时时间配置"></a>超时时间配置</h3><p>全局配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Request.Options <span class="hljs-title function_">options</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Options(<span class="hljs-number">5</span>, TimeUnit.SECONDS,<span class="hljs-number">3</span>, TimeUnit.SECONDS, <span class="hljs-literal">true</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>yaml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">service-alpha:</span> <span class="hljs-comment">#服务名</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span><br>        <span class="hljs-comment">#连接超时时间，默认2秒</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">5000</span><br><span class="hljs-comment">#        请求超时时间，默认5秒</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RequestInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> &#123;<br><br>        <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">servletRequestAttributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> servletRequestAttributes.getRequest();<br>        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();<br>        <span class="hljs-keyword">while</span> (headerNames.hasMoreElements())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> headerNames.nextElement();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">header</span> <span class="hljs-operator">=</span> request.getHeader(s);<br>            System.out.println(<span class="hljs-string">&quot;[header] key:&quot;</span> + s + <span class="hljs-string">&quot;, value:&quot;</span> + header);<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;feign拦截器：&#123;&#125;&quot;</span>, requestTemplate.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置中心Nacos-config"><a href="#配置中心Nacos-config" class="headerlink" title="配置中心Nacos-config"></a>配置中心Nacos-config</h2><p>权限功能的开启需要在nacos配置文件中配置<code>nacos.core.auth.enabled=true</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-cloud-dependencies 2020.0.0 版本不在默认加载bootstrap 文件，如果需要加载bootstrap 文件需要手动添加依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置一旦修改非properties格式的配置，需要在bootstrap.yaml中设置<code>file-extension</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#bootstrap.yaml</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-alpha</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">public</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br></code></pre></td></tr></table></figure><p>注意：<code>spring.application.name=service-alpha</code>必须写在<code>bootstrap.properties</code>中才能动态感知配置的变化，写在<code>application.properties</code>中无法感知。</p><p>使用<code>@Value</code>获取的配置信息无法动态感知，需要配合使用<code>@RefreshScope</code></p><h2 id="服务限流-熔断-降级sentinel"><a href="#服务限流-熔断-降级sentinel" class="headerlink" title="服务限流\熔断\降级sentinel"></a>服务限流\熔断\降级sentinel</h2><p><a href="https://sentinelguard.io/zh-cn/docs/annotation-support.html">annotation-support (sentinelguard.io)</a></p><h3 id="SentinelResource-value-x3D-””-blockHandler-x3D-””"><a href="#SentinelResource-value-x3D-””-blockHandler-x3D-””" class="headerlink" title="@SentinelResource(value&#x3D;””, blockHandler&#x3D;””)"></a>@SentinelResource(value&#x3D;””, blockHandler&#x3D;””)</h3><h4 id="value："><a href="#value：" class="headerlink" title="value："></a>value：</h4><ul><li>资源名称，必需项（不能为空）</li></ul><h4 id="entryType："><a href="#entryType：" class="headerlink" title="entryType："></a>entryType：</h4><ul><li>entry 类型，可选项（默认为 <code>EntryType.OUT</code>），作用：标记流量的方向，指明是出口流量，还是入口流量；取值 IN&#x2F;OUT ,默认是OUT。</li></ul><h4 id="blockHandler-x2F-blockHandlerClass"><a href="#blockHandler-x2F-blockHandlerClass" class="headerlink" title="blockHandler&#x2F;blockHandlerClass"></a>blockHandler&#x2F;blockHandlerClass</h4><ul><li>blockHandler 函数访问范围需要是 <code>public</code></li><li><strong>返回类型需要与原方法相匹配</strong>，<strong>参数类型需要和原方法相匹配并且最后加一个额外的参数</strong>，类型为 <code>BlockException</code>。</li><li>blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>blockHandlerClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul><h4 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h4><p>可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要和原函数一致，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li><li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul><p>dashboard去github上下载jar包</p><p>启动使用命令<code>java -jar sentinel-dashboard-1.8.3.jar</code></p><p>可以加入参数<code>-Dserver.port=8858</code>等</p><p>整合SpringCloudAlibaba</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>统一异常处理实现<code>BlockExceptionHandler</code>接口</p><p>使用了@SentinelResource注解的方法不会走统一异常处理接口，需要自行指定blockhandler</p><h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><h4 id="直接"><a href="#直接" class="headerlink" title="直接"></a>直接</h4><p>对所填的资源直接进行流控</p><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p><code>关联资源</code>达到<code>单机阈值</code>触发资源名所填资源的流控</p><h4 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h4><p>资源名所填资源达到<code>单机阈值</code>后对<code>入口资源</code>进行流控</p><p><strong>使用链路流控模式需要进行以下配置</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.cloud.sentinel.web-context-unify</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>指的是流量到达单机阈值后，剩余的流量被直接拒绝</p><h4 id="Warm-Up（预热）"><a href="#Warm-Up（预热）" class="headerlink" title="Warm Up（预热）"></a>Warm Up（预热）</h4><p>即预热\冷启动方式，可以设置一个预热时长。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过“冷启动”让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p><p>冷加载因子：codeFactor默认是3，即请求QPS从threshold&#x2F;3开始，经预热时长逐渐升至设定的QPS阈值。</p><h4 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h4><p>可以设置超时时间，达到单机阈值后，进行排队</p><h3 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h3><h4 id="慢调用比例-SLOW-REQUEST-RATIO"><a href="#慢调用比例-SLOW-REQUEST-RATIO" class="headerlink" title="慢调用比例(SLOW_REQUEST_RATIO)"></a>慢调用比例(SLOW_REQUEST_RATIO)</h4><p>选择以慢调用比例作为阈值，需要设置允许的慢调用RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT则会再次被熔断。</p><h4 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h4><h4 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h4><h3 id="整合Openfeign"><a href="#整合Openfeign" class="headerlink" title="整合Openfeign"></a>整合Openfeign</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">feign.sentinel.enabled</span>: <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>写一个类实现feign接口，@FeignClient注解写上fallback的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;service-bravo&quot;, configuration = FeignConfig.class, fallback = BravoFeignFallback.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BravoFeign</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/bravo-test/getBravoTestString&quot;)</span><br>    String <span class="hljs-title function_">getBravoTestString</span><span class="hljs-params">()</span>;<br><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BravoFeignFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BravoFeign</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBravoTestString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;BravoFeign invoke method getBravoTestString fallback&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="热点参数流控"><a href="#热点参数流控" class="headerlink" title="热点参数流控"></a>热点参数流控</h3><p>dashboard配置热点参数流控中的资源名必须是@SentinelResource(value&#x3D;”资源名”)中配置的资源名， 热点规则必须配合使用@SentinelResource注解</p><h3 id="系统保护规则"><a href="#系统保护规则" class="headerlink" title="系统保护规则"></a>系统保护规则</h3><p>全局规则</p><p>Load自适应（仅对Linux&#x2F;Unix-like机器生效）</p><p>CPU usage（1.5.0+版本）：当系统CPU使用率超过阈值即触发系统保护（取值范围0.0-1.0），比较灵敏。</p><p>平均RT：当单台机器上所有入口流量的平均RT达到阈值即触发系统保护，单位是毫秒。</p><p>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p><p>入口QPS：当单台机器上所有入口流量的QPS达到阈值即触发系统保护。</p><h3 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h3><p>Sentinel规则的推送有三种模式：</p><table><thead><tr><th>推送模式</th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>原始模式</td><td>API将规则推送至客户端并直接更新到内存中，扩展写数据源(WritableDataSource)</td><td>简单，无任何依赖</td><td>不保证一致性；规则保存在内存中，重启即消失，严重不建议用于生产环境。</td></tr><tr><td>Pull模式</td><td>扩展写数据源(WritableDataSource)，客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是RDBMS、文件等</td><td>简单，无任何依赖；规则持久化</td><td>不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。</td></tr><tr><td>Push模式</td><td>扩展读数据源(ReadableDataSource)，规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用Nacos、Zookeeper等配置中心。这种方式有更好的实时性和一致性保证。生产环境下一般采用Push模式的数据源。</td><td>规则持久化；一致性；快速</td><td>引入第三方依赖</td></tr></tbody></table><p>Push模式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在nacos中新建配置json格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/alpha-test/getTestString&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;controlBehavior&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;grade&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;limitApp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;strategy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">如何使用 · alibaba&#x2F;Sentinel Wiki · GitHub</a></p><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">cloud:</span><br><span class="hljs-attr">sentinel:</span><br><span class="hljs-attr">datasource:</span><br><span class="hljs-attr">flow-rule:</span> <span class="hljs-comment">#flow-rule为自定义名字</span><br><span class="hljs-attr">nacos:</span><br><span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br><span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br><span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br><span class="hljs-attr">dataId:</span> <span class="hljs-string">order-sentinel-flow-rule</span><br><span class="hljs-attr">ruleType:</span> <span class="hljs-string">flow</span> <span class="hljs-comment">#从RuleType类中查看的类型</span><br></code></pre></td></tr></table></figure><h2 id="分布式事务Seata"><a href="#分布式事务Seata" class="headerlink" title="分布式事务Seata"></a>分布式事务Seata</h2><p>Seata是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata为用户提供了AT、TCC、SAGA和XA事务模式，为用户打造一站式的分布式解决方案。AT模式是阿里首推的模式，阿里云上有商用版本的GTS（Globle Transaction Service全局事务服务）</p><p>官网：<a href="https://seata.io/zh-cn/">Seata</a></p><h3 id="Seata的三大角色"><a href="#Seata的三大角色" class="headerlink" title="Seata的三大角色"></a>Seata的三大角色</h3><p>TC(Transaction Coordinator)- 事务协调者</p><ul><li>维护全局和分支事务的状态，驱动全局事务提交或回滚</li></ul><p>TM(Transaction Manager)- 事务管理器</p><ul><li>定义全局事务范围：开始全局事务、提交或回滚全局事务。</li></ul><p>RM(Resource Manager)- 资源管理器</p><ul><li>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>其中TC为单独部署的Server服务端，TM和RM为嵌入到应用中的Client客户端。</p><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>AT模式是一种无侵入的分布式事务解决方案。</p><p>阿里seata框架实现了该模式。</p><p>在AT模式下，用户只需关注自己的“业务SQL”，用户的“业务SQL”作为一阶段，Seata框架会自动生成事务的二阶段提交和回滚操作。</p><p>AT模式如何做到对业务的无侵入：</p><ul><li>一阶段</li></ul><p>在一阶段，Seata会拦截“业务SQL”，首先解析SQL语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p><ul><li>二阶段提交</li></ul><p>二阶段如果是提交的话，因为“业务SQL”在一阶段已经提交至数据库，所以Seata框架只需要将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p><ul><li>二阶段回滚</li></ul><p>二阶段如果是回滚的话，Seata就需要回滚一阶段已经执行的“业务SQL”，还原业务数据。回滚的方式便是用“before image”还原业务数据；但在还原之前要首先要校验脏写，对比“数据库当前业务数据”和“after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</p><h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h3><p>1.侵入性比较强，并且得自己实现相关事务控制逻辑</p><p>2.整个过程基本没有锁，性能更高</p><p>TCC模式需要用户根据自己的业务场景实现Try、Confirm和Cancel三个操作；事务发起方在一阶段执行Try方式，在二阶段提交执行confirm方法，二阶段回滚执行cancel方法。</p><h3 id="Seata快速开始"><a href="#Seata快速开始" class="headerlink" title="Seata快速开始"></a>Seata快速开始</h3><p>Seatac Server（TC）环境搭建</p><p>Server端存储模式（store.mode）支持三种：</p><ul><li>file：单机模式，全局事务会话信息内存中读写并持久化本地文件root.data，性能较高（默认）</li><li>db：(mysql5.7+)高可用模式，全局事务会话信息通过db共享，相应性能差些<ul><li>打开conf&#x2F;file.conf</li><li>修改mode&#x3D;”db”</li><li>修改数据库连接信息（url&#x2F;username&#x2F;password）</li><li>创建数据库seata</li><li>新建表：可以去seata提供的资源信息中下载：<ul><li><a href="https://github.com/seata/seata/tree/master/script">seata&#x2F;script at master · seata&#x2F;seata · GitHub</a></li></ul></li></ul></li><li>redis：Seata-Server1.3及以上版本支持，性能较高，存在事务信息丢失的风险，需提前配置适合当前场景的redis持久化配置</li></ul><p>资源目录</p><ul><li>client：存放client端sql脚本，参数配置</li><li>config-center：各个配置中心参数导入脚本，config.txt（包含server和client，原名nacos-config.sh）为通用参数文件</li><li>server：server端数据库脚本及各个容器配置</li></ul><h3 id="db存储模式-Nacos（注册-amp-配置中心）部署（高可用）"><a href="#db存储模式-Nacos（注册-amp-配置中心）部署（高可用）" class="headerlink" title="db存储模式+Nacos（注册&amp;配置中心）部署（高可用）"></a>db存储模式+Nacos（注册&amp;配置中心）部署（高可用）</h3><ol><li>修改conf&#x2F;registry.conf中注册中心和配置中心 <code>type</code>和nacos相关配置（config也可以使用本地文件）</li><li><a href="https://github.com/seata/seata/tree/master/script">seata&#x2F;script at master · seata&#x2F;seata · GitHub</a>下载config-center中的文件，修改<code>config.txt</code>中的相关配置：修改<code>store.mode=DB</code>及修改<code>store.db</code>相关配置。</li><li>执行nacos&#x2F;nacos-config.sh（可以使用git-bash.exe，需要设置参数如-u username和-w password）将<code>config.txt</code>中的配置注册到配置中心，执行后应该会产生4个失败，分别是config.txt中4个未配置的参数，不影响单机使用（seata1.4.2版本不需要）。</li><li>启动seata，执行seata解压目录中bin&#x2F;seata-server.bat</li></ol><p>seata支持的启动参数</p><table><thead><tr><th>参数</th><th>全写</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>-h</td><td>–host</td><td>指定在注册中心注册的IP</td><td>不指定时获取当前的IP，外部访问部署在云环境和容器中的server建议指定</td></tr><tr><td>-p</td><td>–port</td><td>指定server启动的端口</td><td>默认为8091</td></tr><tr><td>-m</td><td>–storeMode</td><td>事务日志存储方式</td><td>支持file，db，redis，默认为file，redis需seata-server1.3版本以上</td></tr><tr><td>-n</td><td>–serverNode</td><td>用于指定seata-server节点ID</td><td>如1，2，3…，默认为1</td></tr><tr><td>-e</td><td>–seataEnv</td><td>指定seata-server运行环境</td><td>如dev，test等，服务启动时会使用registry-dev.conf这样的配置</td></tr></tbody></table><h3 id="Seata-Client快速开始"><a href="#Seata-Client快速开始" class="headerlink" title="Seata Client快速开始"></a>Seata Client快速开始</h3><p>第一步：添加pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步：各微服务对应数据库中添加undo_log表</p><p><a href="https://github.com/seata/seata/tree/master/script">seata&#x2F;script at master · seata&#x2F;seata · GitHub</a></p><p>&#x2F;client&#x2F;at&#x2F;db&#x2F;mysql.sql</p><p>第三步：Client端加入对应的配置中心</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>      <span class="hljs-attr">application:</span> <span class="hljs-string">seata-server</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">group:</span> <span class="hljs-string">SEATA_GROUP</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>      <span class="hljs-attr">group :</span> <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">&quot;nacos&quot;</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">&quot;nacos&quot;</span><br></code></pre></td></tr></table></figure><p>第四步：修改seata解压目录中 registry.conf，配置nacos作为registry.type和config.type，并修改配置中心相关配置。</p><p>第五步：为seata新建库表</p><p>第六步：启动seata</p><h2 id="网关gateway"><a href="#网关gateway" class="headerlink" title="网关gateway"></a>网关gateway</h2><p>前端直接访问微服务会存在诸多的问题：</p><ul><li>每个业务都会需要鉴权、限流、权限校验、跨域等逻辑，可以将这些逻辑抽离出来统一放到一个地方做</li><li>如果业务量比较简单的话，这种方式前期不会有什么问题，但随着业务越来越复杂，比如淘宝、亚马逊打开一个页面可能会涉及到数百个微服务协同工作，如果每一个微服务都分配一个域名的话，一方面客户端代码会很难维护，涉及到数百个域名，另一方面是连接数瓶颈，想象一下你打开一个APP，通过抓包发现涉及到了数百个远程调用，这在移动端下会显得非常低效。</li><li>服务拆分麻烦</li></ul><p>所谓的API网关，就是指系统的统一入口，它封装了应用程序的内部结构，为客户端提供统一的服务，一些与业务本身功能无关的公共逻辑可以在这里实现，比如认证、鉴权、监控、路由转发等等。</p><h3 id="Spring-Cloud-Gateway功能特性"><a href="#Spring-Cloud-Gateway功能特性" class="headerlink" title="Spring Cloud Gateway功能特性"></a>Spring Cloud Gateway功能特性</h3><ul><li>基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；</li><li>动态路由：能够匹配任何请求属性；</li><li>支持路径重写；</li><li>集成Spring Cloud服务发现功能（Nacos、Eruka）；</li><li>可集成流控降级功能（Sentinel、Hystrix）；</li><li>可以对路由指定易于编写的Predicate（断言）和Filter（过滤器）；</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>路由（route）</li></ul><p>路由是网关中最基础的部分，路由信息包括一个ID、一个目的URL、一组断言工厂、一组Filter组成。如果断言为真，则说明请求的URL和配置的路由匹配。</p><ul><li>断言（predicate）</li></ul><p>Java8中的断言函数，SpringCloud Gateway中的断言函数类型是Spring5.0框架中的ServerWebExchange。断言函数允许开发者去定义匹配的Http request中的任何信息，比如请求头和参数等。</p><ul><li>过滤器（Filter）</li></ul><p>SpringCloud Gateway中的Filter分为Gateway Filter和Global Filter。Filter可以对请求和响应进行处理。</p><h3 id="SpringCloud-Gateway快速开始"><a href="#SpringCloud-Gateway快速开始" class="headerlink" title="SpringCloud Gateway快速开始"></a>SpringCloud Gateway快速开始</h3><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment">#数组路由[路由 就是指定当前请求满足什么条件的时候转到哪个微服务]</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">gateway</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-alpha</span>   <span class="hljs-comment">#请求要转发到的地址[http://127.0.0.1:8001]，或从注册中心获取服务</span><br>          <span class="hljs-attr">order:</span> <span class="hljs-number">1</span>    <span class="hljs-comment">#路由的级别，数字越小级别越高</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言（就是路由转发要满足的条件），当请求路径满足Path指定的规则时，才进行路由转发</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/service-alpha/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span> <span class="hljs-comment">#转发之前去掉第一层路径</span><br></code></pre></td></tr></table></figure><p>注意：需要引入openfeign依赖才能在uri处使用负载均衡进行服务调用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br><span class="hljs-comment">#      routes: #数组路由[路由 就是指定当前请求满足什么条件的时候转到哪个微服务]</span><br><span class="hljs-comment">#        - id: gateway</span><br><span class="hljs-comment">#          uri: lb://service-alpha   #请求要转发到的地址[http://127.0.0.1:8001]，或从注册中心获取服务</span><br><span class="hljs-comment">#          order: 1    #路由的级别，数字越小级别越高</span><br><span class="hljs-comment">#          predicates: #断言（就是路由转发要满足的条件），当请求路径满足Path指定的规则时，才进行路由转发</span><br><span class="hljs-comment">#            - Path=/service-alpha/**</span><br><span class="hljs-comment">#          filters:</span><br><span class="hljs-comment">#            - StripPrefix=1 #转发之前去掉第一层路径</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>使用<code>spring.cloud.gateway.discovery.locator.enabled=true</code>会自动根据路径中的第一层路径寻找服务，且会自动去掉此路径（虽然简单但不太常用，不直观）</p><h3 id="路由断言工厂（Route-Predicate-Factories）配置"><a href="#路由断言工厂（Route-Predicate-Factories）配置" class="headerlink" title="路由断言工厂（Route Predicate Factories）配置"></a>路由断言工厂（Route Predicate Factories）配置</h3><p>作用：当请求gateway的时候，使用断言对请求进行匹配，如果匹配成功就路由转发，如果匹配失败就返回404.</p><p>SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p><ul><li>基于DateTime类型的断言工厂</li></ul><p>此类型的断言根据时间做判断，主要有三个：</p><p>AfterRoutePredicateFactory：接收一个日期参数，判断请求日期是否晚于指定日期</p><p>BeforeRoutePredicateFactory：接收一个日期参数，判断请求日期是否早于指定日期</p><p>BetweenRoutePredicateFactory：接收两个日期参数，判断请求日期是否在指定时间段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">predicates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">After=2022-09-25T18:02:59.789+08:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure><ul><li>基于远程地址的断言工厂</li></ul><p>RemoteAddrRoutePredicateFactory：接收一个ip地址段，判断请求主机地址是否在地址段中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">predicates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">RemoteAddr=192.167.1.1/24</span><br></code></pre></td></tr></table></figure><ul><li>基于Cookie的断言工厂</li></ul><p>CookieRoutePredicateFactory：接收两个参数，cookie名字和一个正则表达式，判断请求cookie是否具有给定名称且值与正则表达式匹配。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=chocolate,ch.</span><br></code></pre></td></tr></table></figure><ul><li>基于Header的断言工厂</li></ul><p>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。判断请求Header是否具有给定名称且值与正则表达式匹配。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">Header=X-Request-Id,</span> <span class="hljs-string">\d+</span><br></code></pre></td></tr></table></figure><ul><li>基于Host的断言工程</li></ul><p>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">Host=**.testhost.org</span><br></code></pre></td></tr></table></figure><ul><li>基于Method请求方法的断言工厂</li></ul><p>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定类型匹配。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">Method=GET</span><br></code></pre></td></tr></table></figure><ul><li>基于Path请求路径的断言工厂</li></ul><p>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">Path=/foo/&#123;segment&#125;</span><br></code></pre></td></tr></table></figure><ul><li>基于Query请求参数的断言工厂</li></ul><p>QueryRoutePredicateFactory：接收两个参数，请求param和正则表达式，判断请求参数是否具有给定名称且值与正则表达式匹配。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">-Query=bar,</span> <span class="hljs-string">ba.</span><br></code></pre></td></tr></table></figure><ul><li>基于路由权重的断言工厂</li></ul><p>WeightRoutePredicateFactory：接收一个[组名，权重]，然后对于同一个组内的路由按照权重转发。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span><br><span class="hljs-string">-id:</span> <span class="hljs-string">weight_route1</span><br> <span class="hljs-attr">uri:</span> <span class="hljs-string">host1</span><br>     <span class="hljs-attr">predicates:</span><br>     <span class="hljs-string">-Path=/product/**</span><br>     <span class="hljs-string">-Weight=group3,1</span><br>     <span class="hljs-string">-id:</span> <span class="hljs-string">weight_route2</span><br> <span class="hljs-attr">uri:</span> <span class="hljs-string">host2</span><br>     <span class="hljs-attr">predicates:</span><br>     <span class="hljs-string">-Path=/product/**</span><br>     <span class="hljs-string">-Weight=group3,9</span><br></code></pre></td></tr></table></figure><h3 id="自定义断言工厂"><a href="#自定义断言工厂" class="headerlink" title="自定义断言工厂"></a>自定义断言工厂</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.1/reference/html/">Spring Cloud Gateway</a></p><p>自定义路由断言工厂需要继承<code>AbstractRoutePredicateFactory</code>类，重写apply方法的逻辑。在apply方法中可以通过exchange.getRequest()拿到ServletHttpRequest对象，从而可以获取到请求的参数、请求方式、请求头等信息。</p><ol><li><p>必须为spring组件</p></li><li><p>类命名必须加上RoutePredicateFactory作为结尾。</p></li><li><p>必须继承<code>AbstractRoutePredicateFactory</code></p></li><li><p>必须声明静态内部类，声明属性来接收配置文件中对应的断言的信息</p></li></ol><p>参考官方的写法</p><h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.1/reference/html/#gatewayfilter-factories">Spring Cloud Gateway</a></p><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p>针对所有路由请求，一旦定义就会投入使用</p><p>写一个类实现<code>GlobalFilter</code>接口</p><h3 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h3><p>配置文件方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">globalcors:</span><br>        <span class="hljs-attr">cors-configurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span> <span class="hljs-comment">#允许跨域访问的资源</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment">#跨域允许来源</span><br>            <span class="hljs-attr">allowedMethods:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">GET</span><br></code></pre></td></tr></table></figure><h3 id="整合Sentinel流控降级"><a href="#整合Sentinel流控降级" class="headerlink" title="整合Sentinel流控降级"></a>整合Sentinel流控降级</h3><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sentinel:</span><br><span class="hljs-attr">transport:</span><br><span class="hljs-attr">dashboard:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8080</span><br></code></pre></td></tr></table></figure><h2 id="链路追踪SkyWalking"><a href="#链路追踪SkyWalking" class="headerlink" title="链路追踪SkyWalking"></a>链路追踪SkyWalking</h2><p>skywalking8.7.0之后的版本，agent的相关代码被抽离出skywalking当中，需要自行下载agent。</p><p>执行startup.cmd启动skywalking客户端</p><p>启动成功后会启动两个服务，一个是skywalking-oap-server，一个是skywalking-web-ui</p><p>skywalking-oap-server服务启动后会暴露11800 和 12800 两个端口，分别为收集监控数据的端口11800和接受前端请求的端口12800，修改端口可以修改config&#x2F;applicaiton.yml<br><a href="https://blog.csdn.net/u012267926/article/details/119793247">https://blog.csdn.net/u012267926/article/details/119793247</a></p><p>skywalking-web-ui服务会占用 8080 端口， 修改端口可以修改webapp&#x2F;webapp.yml</p><p>windows的idea中在VM  options中添加以下参数后启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#skywalking-agent.jar的磁盘路径</span><br>-javaagent:D:\programming\apache-skywalking-java-agent-8.10.0\skywalking-agent\skywalking-agent.jar<br><span class="hljs-comment">#在skywalking上显示的服务名</span><br><span class="hljs-attribute">-DSW_AGENT_NAME</span>=service-gateway<br><span class="hljs-comment">#skywalking的collector服务的ip和端口</span><br><span class="hljs-attribute">-DSW_AGENT_COLLECTOR_BACKEND_SERVICES</span>=127.0.0.1:11800<br></code></pre></td></tr></table></figure><p>linux命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">java -javaagent:/user/skywalking-agent.jar <span class="hljs-attribute">-DSW_AGENT_NAME</span>=gateway <span class="hljs-attribute">-DSW_AGENT_COLLECTOR_BACKEND_SERVICES</span>=127.0.0.1:11800 -jar service-gateway.jar<br></code></pre></td></tr></table></figure><h3 id="在拓扑图中显示gateway服务"><a href="#在拓扑图中显示gateway服务" class="headerlink" title="在拓扑图中显示gateway服务"></a>在拓扑图中显示gateway服务</h3><p>需要从&#x2F;skywalking-agent&#x2F;optional-plugins中复制一份<code>apm-spring-cloud-gateway</code>插件到&#x2F;skywalking-agent&#x2F;plugins中</p><h3 id="使用MySQL持久化"><a href="#使用MySQL持久化" class="headerlink" title="使用MySQL持久化"></a>使用MySQL持久化</h3><p>修改config&#x2F;application.yml，将<code>storage.selector</code>的h2修改为mysql，并修改MySQL配置</p><p>建好数据库后skywalking启动时会自动把表建好</p><p><strong>注意：oap服务依赖中没有mysql驱动，需要自行复制一份mysql驱动放到&#x2F;oap-libs目录中</strong></p><h3 id="自定义链路追踪"><a href="#自定义链路追踪" class="headerlink" title="自定义链路追踪"></a>自定义链路追踪</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.skywalking<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apm-toolkit-trace<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在业务方法上添加<code>@Trace</code>注解</p><p>记录方法参数和返回值使用<code>@Tag</code>&#x2F;<code>@Tags</code>注解（需要配合<code>@Trace</code>），给一个key（自定义），需要记录返回值则对应key的value&#x3D;”returnedObj”，若需要记录参数则value&#x3D;”arg[0]”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Tags(&#123;@Tag(key=&quot;param&quot;, value=&quot;arg[0]&quot;),</span><br><span class="hljs-meta">       @Tag(key=&quot;returnVal&quot;, value=&quot;returnedObj&quot;)&#125;)</span><br></code></pre></td></tr></table></figure><p><strong>返回的是一个对象的话需要重写该对象的toString方法，否则显示的返回值为该对象的地址</strong></p><h3 id="集成日志框架"><a href="#集成日志框架" class="headerlink" title="集成日志框架"></a>集成日志框架</h3><p><a href="https://blog.csdn.net/Blueeyedboy521/article/details/126509520"> SpringCloud链路追踪SkyWalking-第六章-日志采集_Blueeyedboy521的博客-CSDN博客_skywalking采集业务日志</a></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.skywalking<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apm-toolkit-logback-1.x<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>logback配置文件中<appender><encoder><layout class=....TraceIdPatternLogbackLayut>,layout指定SkyWalking中的Layout，可以在<pattern>中使用%tid输出trace_id</li></ol><p>如果需要使用skywalking记录所有项目的日志可以在logback配置中加入以下配置按需打印</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;grpc-log&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%tid] [%thread] %-5level %logger&#123;36&#125; -%msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ</title>
    <link href="/2022/08/15/RocketMQ/"/>
    <url>/2022/08/15/RocketMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><p>消息队列</p><p>常见的消息中间件：</p><p>Kafka, ActiveMQ, RabbitMQ, RocketMQ</p><h1 id="第1章-RocketMQ概述"><a href="#第1章-RocketMQ概述" class="headerlink" title="第1章 RocketMQ概述"></a>第1章 RocketMQ概述</h1><h2 id="一、MQ概述"><a href="#一、MQ概述" class="headerlink" title="一、MQ概述"></a>一、MQ概述</h2><h3 id="1、MQ简介"><a href="#1、MQ简介" class="headerlink" title="1、MQ简介"></a>1、MQ简介</h3><p>MQ，Message Queue，是一种提供消息队列服务的中间件，是一套提供了消息生产、存储、消费过程API的软件系统。</p><h3 id="2、MQ用途"><a href="#2、MQ用途" class="headerlink" title="2、MQ用途"></a>2、MQ用途</h3><p><strong>限流削峰</strong></p><p>MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮。</p><p><strong>异步解耦</strong></p><p>上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统的耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性的做法就是在这两层间添加一个MQ层。</p><p><strong>数据收集</strong></p><p>分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。</p><h3 id="3、常见MQ产品"><a href="#3、常见MQ产品" class="headerlink" title="3、常见MQ产品"></a>3、常见MQ产品</h3><p><strong>ActiveMQ</strong></p><p>ActiveMQ是使用Java语言开发的一款MQ产品。早期很多公司与项目中都在使用。但现在的社区活跃度已经很低。现在的项目中已经很少使用了。</p><p><strong>RabbitMQ</strong></p><p>RabbitMQ是使用ErLang语言开发的一款MQ产品。其吞吐量较Kafka与RocketMQ要低，且由于其不是Java语言开发，所以企业内部对其实现定制化开发难度较大。</p><p><strong>Kafka</strong></p><p>Kafka是使用Scala&#x2F;Java语言开发的一款MQ产品。其最大的特点就是高吞吐量，常用于大数据领域的实时计算、日志采集等场景。其没有遵循任何常见的MQ协议，而是使用自研协议。</p><p><strong>RocketMQ</strong></p><p>RocketMQ是使用Java语言开发的一款MQ产品。经过数年阿里双11的考验，性能与稳定性非常高。其没有遵循任何常见的MQ协议，而是使用自研协议。对于Spring Cloud Alibaba，其支持RabbitMQ、Kafka，但提倡使用RocketMQ。</p><p><strong>对比</strong></p><table><thead><tr><th>关键词</th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>开发语言</td><td>Java</td><td>Erlang</td><td>Java</td><td>Java</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>十万级</td><td>十万级</td></tr><tr><td>Topic</td><td>-</td><td>-</td><td>百级Topic时会影响系统吞吐量</td><td>千级Topic时会影响系统吞吐量</td></tr><tr><td>社区活跃度</td><td>低</td><td>高</td><td>高</td><td>高</td></tr></tbody></table><h3 id="4、MQ常见协议"><a href="#4、MQ常见协议" class="headerlink" title="4、MQ常见协议"></a>4、MQ常见协议</h3><p>一般情况下MQ的实现要遵循一些常规性协议。常见的协议如下：</p><p><strong>JMS</strong></p><p>JMS，Java Messaging Service ，是Java平台上有关MOM（Message Oriented Middleware，面向消息的中间件）的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。</p><p><strong>STOMP</strong></p><p>STOMP，Streaming Text Orientated Message Protocol，是一种MOM设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理进行交互。ActiveMQ是该协议的典型实现，RabbitMQ通过插件可以支持该协议。</p><p><strong>AMQP</strong></p><p>AMQP，Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准，是一种MOM设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同开发语言等条件的限制。RabbitMQ是该协议的典型表现。</p><p><strong>MQTT</strong></p><p>MQTT，Message Queuing Telemetry Transport，是IBM开发的一个即时通讯协议，是一种二进制协议，主要用于服务器和低功耗IoT（物联网）设备间的通信。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当作传感器和致动器的通信协议。RabbitMQ通过插件可以支持该协议。</p><h2 id="二、RocketMQ概述"><a href="#二、RocketMQ概述" class="headerlink" title="二、RocketMQ概述"></a>二、RocketMQ概述</h2><h3 id="1、RocketMQ简介"><a href="#1、RocketMQ简介" class="headerlink" title="1、RocketMQ简介"></a>1、RocketMQ简介</h3><p>RocketMQ是一个统一消息引擎、轻量级数据处理平台。</p><p>RocketMQ是一款阿里巴巴开源的消息中间件。2016年11月28日，阿里巴巴向Apache软件基金会捐赠RocketMQ，成为Apache孵化项目。2017年9月25日，Apache宣布RocketMQ孵化成为Apache顶级项目（TLP），成为国内首个互联网中间件在Apache上的顶级项目。</p><p>官网地址：<a href="http://rocketmq.apache.org/">Apache RocketMQ</a></p><h3 id="2、RocketMQ发展历程"><a href="#2、RocketMQ发展历程" class="headerlink" title="2、RocketMQ发展历程"></a>2、RocketMQ发展历程</h3><p><img src="/2022/08/15/RocketMQ/150632_USCe_2720166.png" alt="RocketMQ发展历程"></p><p>2007年，阿里开始五彩石项目，Notify作为项目中交易核心消息流转系统，应运而生。Notify系统是RocketMQ的雏形。</p><p>2010年，B2B大规模使用ActiveMQ作为阿里的消息内核。阿里急需一个具有海量堆积能力的消息系统。</p><p>2011年初，Kafka开源，淘宝中间件团队在对Kafka进行了深入研究后，开发了一款新的MQ，MetaQ。</p><p>2012年，MetaQ发展到了v3.0版本，在它基础上进行了进一步的抽象，形成了RocketMQ，然后就将其进行了开源。</p><p>2015年，阿里在RocketMQ的基础上，又推出了一款针对阿里云上用户的消息系统AliwareMQ。</p><p>2016年11月28日，阿里巴巴向Apache软件基金会捐赠RocketMQ，成为Apache孵化项目。</p><p>2017年9月25日，Apache宣布RocketMQ孵化成为Apache顶级项目（TLP），成为国内首个互联网中间件在Apache上的顶级项目。</p><h1 id="第2章-RocketMQ的安装与启动"><a href="#第2章-RocketMQ的安装与启动" class="headerlink" title="第2章 RocketMQ的安装与启动"></a>第2章 RocketMQ的安装与启动</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-消息（Message）"><a href="#1-消息（Message）" class="headerlink" title="1 消息（Message）"></a>1 消息（Message）</h3><p>消息是指，消息系统所传输的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p><h3 id="2-主题（Topic）"><a href="#2-主题（Topic）" class="headerlink" title="2 主题（Topic）"></a>2 主题（Topic）</h3><p>Topic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p><p>topic:message 1:n</p><p>message:topic 1:1</p><p>一个生产者可以同时发送多种Topic消息；而一个消费者只能对某种特定的Topic感兴趣，即只可以订阅和消费一种Topic的消息。</p><p>producer:topic 1:n</p><p>consumer:topic 1:1</p><h3 id="3-标签（Tag）"><a href="#3-标签（Tag）" class="headerlink" title="3 标签（Tag）"></a>3 标签（Tag）</h3><p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h3 id="4-队列（Queue）"><a href="#4-队列（Queue）" class="headerlink" title="4 队列（Queue）"></a>4 队列（Queue）</h3><p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区（Partition）。</p><p><font color="#FF0000">一个Topic的Queue中的消息只能被一个消费组中的一个消费者消费。</font></p><p>其他参考资料中还会看到一个概念：分片（Sharding)。分片不同于分区。在RocketMQ中，分片指的是存放相应Topic的Broker的数量。每个分片中会创建出相应数量的分区，即Queue，每个Queue的大小都是相同的。（不是官方概念）</p><p><img src="/2022/08/15/RocketMQ/20170616154817226.png" alt="Topic,Topic分片和Queue"></p><h3 id="5-消息标识（MessageId-x2F-Key）"><a href="#5-消息标识（MessageId-x2F-Key）" class="headerlink" title="5 消息标识（MessageId&#x2F;Key）"></a>5 消息标识（MessageId&#x2F;Key）</h3><p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId），当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p><ul><li><p>msgId：由producer端生成，其生成规则为：</p><p>producerIp + 进程pid + MessageClientIDSetter类的classLoader的hashCode + 当前时间 + AutomicInteger自增计数器</p></li><li><p>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset</p></li><li><p>key：由用户指定的业务相关的唯一标识。</p></li></ul><h2 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h2><p><img src="/2022/08/15/RocketMQ/RocketMQ%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="RocketMQ系统架构"></p><p>RocketMQ架构上主要由四部分构成：</p><h3 id="1-Producer"><a href="#1-Producer" class="headerlink" title="1 Producer"></a>1 Producer</h3><p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p><p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p><h3 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2 Consumer"></a>2 Consumer</h3><p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。</p><p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现<strong>负载均衡</strong>（将一个Topic中的不同的Queue平均分配给同一个Consumer Group中的不同Consumer，并不是将消息负载均衡）和<strong>容错</strong>（一个Consumer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。</p><p>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的Consumer将不能消费消息。</p><p>一个Topic类型的消息可以被多个消费者组同时消费。</p><h3 id="3-Name-Server"><a href="#3-Name-Server" class="headerlink" title="3 Name Server"></a>3 Name Server</h3><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。</p><p>RocketMQ的思想来自于Kafka，而Kafka是依赖了Zookeeper的，所以，在RocketMQ的早期版本，即在MetaQ v1.0与v2.0版本中，也是依赖于Zookeeper的。从MetaQ v3.0，即RocketMQ开始去掉了Zookeeper依赖，使用了自己的NameServer。</p><p>主要包括两个功能：</p><ul><li>Broker管理：接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测机制，检查Broker是否还存活。</li><li>路由信息管理：每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列信息。Producer和Consumer通过NameServer可以获取整个Broker集群的路由信息，从而进行消息的投递和消费。</li></ul><h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各个节点间是无差异的，各节点间互相不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在NameServer内部维护着一个Broker列表，用来动态存储Broker的信息。</p><blockquote><p>注意，这是与其它像zk、Eureka、Nacos等注册中心不同的地方。</p><p>这种NameServer的无状态方式的优缺点：</p><p>优点：NameServer集群搭建简单。</p><p>缺点：对于Broker，必须明确指出所有NameServer地址，否则未指出的将不会去注册，也正因为如此，NameServer并不能随便扩容。若Broker不重新配置，新增的NameServer对于Broker来说是不可见的，其不会向这个NameServer进行注册。</p></blockquote><p>Broker节点为了证明自己是活着的，为了维护与NameServer间的长连接，会将最新的信息以心跳包的方式上报给NameServer，每30秒发送一次心跳。心跳包中包含BrokerId、Broker地址(IP+Port)、Broker名称、Broker所属集群名称等等。NameServer在接收到心跳包后，会更新心跳的时间戳，记录这个Broker的最新存活时间。</p><h4 id="路由剔除"><a href="#路由剔除" class="headerlink" title="路由剔除"></a>路由剔除</h4><p>由于Broker关机、宕机或网络抖动等原因，NameServer没有收到Broker的心跳，NameServer可能会将其从Broker列表中剔除。</p><p>NameServer中有一个定时任务，每隔10秒就会扫描一次Broker表，查看每一个Broker的最新心跳时间戳距离当前时间是否超过120秒，如果超过，则会判定Broker失效，然后将其从Broker列表中剔除。</p><h4 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h4><p>RocketMQ的路由发现采用的是Pull模型。当Topic路由信息出现变化时，NameServer不会主动推送给客户端，而是客户端定时拉取最新的路由。默认客户端每30秒会拉取一次最新的路由。</p><blockquote><p>扩展：</p><p>（1）Push模型：推送模型，其实时性较好，是一个“发布-订阅”模型，需要维护一个长连接，而长连接的维护是需要资源成本的。该模型适合的场景：</p><ul><li>实时性较高</li><li>Client数量不多，Server数据变化较频繁</li></ul><p>（2）Pull模型：拉取模型。存在的问题：实时性较差。</p><p>（3）Long Polling模型：长轮询模型。利用以上两种模型的优势。</p></blockquote><h4 id="客户端NameServer选择策略"><a href="#客户端NameServer选择策略" class="headerlink" title="客户端NameServer选择策略"></a>客户端NameServer选择策略</h4><blockquote><p>这里的客户端指的是Producer和Consumer</p></blockquote><p>客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点呢？客户端首先会产生一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节点。</p><h3 id="4-Broker"><a href="#4-Broker" class="headerlink" title="4 Broker"></a>4 Broker</h3><h4 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。</p><h4 id="模块构成"><a href="#模块构成" class="headerlink" title="模块构成"></a>模块构成</h4><p><img src="/2022/08/15/RocketMQ/image-20211206191332201.png" alt="模块构成"></p><p>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。</p><p>Client Manager：客户端管理器。负责接收、解析客户端（Producer&#x2F;Consumer）请求，管理客户端。例如，维护Consumer的Topic订阅信息。</p><p>Store Service：存储服务。提供方便简单的API接口，处理<strong>消息存储到物理硬盘</strong>和<strong>消息查询</strong>功能。</p><p>HA Service：高可用服务，提供Master Broker和Slave Broker之间的数据同步功能。</p><p>Index Service：索引服务。根据特定的Message Key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。</p><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p>为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同Topic的不同Queue。不过，这里有一个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。</p><p>Broker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请求，Slave负责对Master中的数据进行备份，当Master挂掉，Slave会自动切换为Master去工作。一个Master可以包含多个Slave，但一个Slave只能隶属一个Master。Master与Slave的对应关系是通过指定相同的BrokerName、不同的BrokerId来确定的。BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p><h3 id="5-工作流程"><a href="#5-工作流程" class="headerlink" title="5 工作流程"></a>5 工作流程</h3><h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><p>1）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。</p><p>2）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每30秒向NameServer定时发送心跳。</p><p>3）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消息时自动创建Topic。</p><p>4）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取路由信息，即当前发送的Topic的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由信息后，Producer会首先将路由信息缓存到本地，再每30秒从NameServer更新一次路由信息。</p><p>5）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费其中的消息。Consumer在获取到路由信息后，同样也会每30秒从NameServer更新一次路由信息。不过不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。</p><h4 id="Topic的创建模式"><a href="#Topic的创建模式" class="headerlink" title="Topic的创建模式"></a>Topic的创建模式</h4><p>手动创建Topic是，有两种模式：</p><ul><li>集群模式：该模式下创建的Topic在该集群中，所有Broker中的Queue数量是相同的。</li><li>Broker模式：该模式下创建的Topic在该集群中，每个Broker中的Queue数量可以不同。</li></ul><p>自动创建Topic时，默认采用的是Broker模式，会为每个Broker默认创建4个Queue。</p><h4 id="读-x2F-写队列"><a href="#读-x2F-写队列" class="headerlink" title="读&#x2F;写队列"></a>读&#x2F;写队列</h4><p>从物理上来讲，读&#x2F;写队列是同一个队列。所以，不存在读&#x2F;写队列数据同步问题。读&#x2F;写队列是逻辑上进行区分的概念。一般情况下，读&#x2F;写队列是相同的。</p><p>例如，创建Topic时设置的写队列数量为8，读队列数量为4，此时系统会创建8个Queue，分别是0-7。Producer会将消息写入到这8个队列，但Consumer只会消费0-3这4个队列中的消息，4-7中的消息不会被消费到。</p><p>写队列为4，读队列为8，也会创建8个Queue。Producer会将消息写入到0-3这4个队列，Consumer会消费0-7这8个队列中的消息，但是4-7中是没有消息的。</p><p>也就是说，当读&#x2F;写队列数量设置不同时，总是有问题的，那么为什么这样设计？</p><p>目的是为了方便Topic的Queue的缩容。</p><p>pem用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写。</p><h2 id="三、单机安装与启动"><a href="#三、单机安装与启动" class="headerlink" title="三、单机安装与启动"></a>三、单机安装与启动</h2><p><a href="https://rocketmq.apache.org/docs/quick-start/">Quick Start - Apache RocketMQ</a></p><h2 id="四、控制台的安装与启动（dashboard）"><a href="#四、控制台的安装与启动（dashboard）" class="headerlink" title="四、控制台的安装与启动（dashboard）"></a>四、控制台的安装与启动（dashboard）</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><h3 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2.修改配置"></a>2.修改配置</h3><h3 id="3-添加依赖"><a href="#3-添加依赖" class="headerlink" title="3.添加依赖"></a>3.添加依赖</h3><h3 id="4-打包"><a href="#4-打包" class="headerlink" title="4.打包"></a>4.打包</h3><h3 id="5-启动"><a href="#5-启动" class="headerlink" title="5.启动"></a>5.启动</h3><h3 id="6-访问"><a href="#6-访问" class="headerlink" title="6.访问"></a>6.访问</h3><h2 id="五、集群搭建理论"><a href="#五、集群搭建理论" class="headerlink" title="五、集群搭建理论"></a>五、集群搭建理论</h2><p>p27</p><h3 id="1-数据复制与刷盘策略"><a href="#1-数据复制与刷盘策略" class="headerlink" title="1.数据复制与刷盘策略"></a>1.数据复制与刷盘策略</h3><h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：</p><ul><li>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</li><li>异步复制：消息写入master后，master会立即向producer返回成功ACK，无需等待slave同步数据成功</li></ul><blockquote><p>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量</p></blockquote><h4 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h4><p>刷盘策略指的是broker中消息落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘：</p><ul><li>同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。</li><li>异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</li></ul><blockquote><p>异步刷盘策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量</p></blockquote><h3 id="2-Broker集群模式"><a href="#2-Broker集群模式" class="headerlink" title="2.Broker集群模式"></a>2.Broker集群模式</h3><p>根据Broker集群中各个节点间关系的不同，Broker集群可以分为以下几类：</p><h4 id="单Master"><a href="#单Master" class="headerlink" title="单Master"></a>单Master</h4><p>只有一个broker。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p><h4 id="多Master"><a href="#多Master" class="headerlink" title="多Master"></a>多Master</h4><p>broker集群仅由多个master构成，不存在Slave。同一台Topic的各个Queue会分布在各个master节点上。</p><ul><li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高。</li><li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。</li></ul><blockquote><p>以上优点的前提是，这些master都配置了RAID磁盘阵列。如果没有配置，一旦出现某Master宕机，则会发生大量消息丢失的情况。</p></blockquote><h4 id="多Master多Slave模式-异步复制"><a href="#多Master多Slave模式-异步复制" class="headerlink" title="多Master多Slave模式-异步复制"></a>多Master多Slave模式-异步复制</h4><p>broker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换。</p><p>异步复制即前面<strong>复制策略</strong>中的<strong>异步复制策略</strong>，即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。</p><p>该模式的最大特点之一是，当master宕机后slave能够自动切换为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</p><h4 id="多Master多Slave模式-同步双写"><a href="#多Master多Slave模式-同步双写" class="headerlink" title="多Master多Slave模式-同步双写"></a>多Master多Slave模式-同步双写</h4><p>该模式是多Master多Slave模式的同步复制实现。所谓同步双写，指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK，也即双写。</p><p>该模式与异步复制模式相比，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的RT略高，从而导致性能要略低（大约低10%）。</p><p>该模式存在一个大问题：对于目前的版本，Master宕机后，Slave不能自动切换到Master。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。</p><blockquote><p>1)RAID磁盘阵列的效率要高于Master-Slave集群。因为RAID是硬件支持的。也正因如此，RAID阵列的搭建成本较高。</p><p>2）多Master+RAID阵列，与多Master多Slave集群的区别是什么？</p><ul><li>多Master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅。但其执行效率要远高于多Master多Slave集群。</li><li>多Master多Slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于多Master+RAID阵列。</li></ul></blockquote><p>p31 51s</p><h2 id="六、磁盘阵列RAID（补充）"><a href="#六、磁盘阵列RAID（补充）" class="headerlink" title="六、磁盘阵列RAID（补充）"></a>六、磁盘阵列RAID（补充）</h2><h2 id="七、集群搭建实践"><a href="#七、集群搭建实践" class="headerlink" title="七、集群搭建实践"></a>七、集群搭建实践</h2><h2 id="八、mqadmin命令"><a href="#八、mqadmin命令" class="headerlink" title="八、mqadmin命令"></a>八、mqadmin命令</h2><h1 id="第3章-RocketMQ工作原理"><a href="#第3章-RocketMQ工作原理" class="headerlink" title="第3章 RocketMQ工作原理"></a>第3章 RocketMQ工作原理</h1><p><img src="/2022/08/15/RocketMQ/image-20211229175925307.png" alt="RocketMQ工作原理"></p><h2 id="一、消息的生产"><a href="#一、消息的生产" class="headerlink" title="一、消息的生产"></a>一、消息的生产</h2><h3 id="1-消息的生产过程"><a href="#1-消息的生产过程" class="headerlink" title="1.消息的生产过程"></a>1.消息的生产过程</h3><p>Producer可以将消息写入到某Broker中的某Queue中，其经历了如下过程：</p><ul><li>Producer发送消息前，会先向NameServer发出获取消息Topic的路由信息的请求</li><li>NameServer返回该Topic的路由表及Broker列表</li><li>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</li><li>Producer对消息做一些特殊处理，例如，消息本身超过4M，则会对其进行压缩</li><li>Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue</li></ul><blockquote><p>路由表：实际是一个Map，key为topic名称，value是一个QueueData实例列表。QueueData并不是一个Queue对应一个QueueData，而是一个Broker中该Topic的所有Queue对应一个QueueData。即，只要涉及到该Topic的Broker，一个Broker对应一个QueueData。QueueData中包含brokerName。简单来说，路由表的key为Topic名称，value则为所有涉及该Topic的BrokerName列表。</p><p>Broker列表：其实际也是一个Map。key为brokerName，value为BrokerData。一套brokerName名称相同的Master-Slave小集群对应一个BrokerData。BrokerData中包含brokerName及一个map。该map的key为brokerId，value为该broker对应的地址。brokerId为0表示该broker为Master，非0表示Slave。</p></blockquote><h3 id="2-Queue选择算法"><a href="#2-Queue选择算法" class="headerlink" title="2.Queue选择算法"></a>2.Queue选择算法</h3><p>对于无序消息，其Queue选择算法也称为消息投递算法，常见的有两种：</p><h4 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h4><p>默认选择算法。该算法保证了每个Queue中可以均匀地获取到消息。</p><blockquote><p>该算法存在一个问题：由于某些原因，在某些Broker上的Queue可能投递延迟较严重。从而导致Producer的缓存队列中出现较大的消息积压，影响消息的投递性能。</p></blockquote><h4 id="最小投递延迟算法"><a href="#最小投递延迟算法" class="headerlink" title="最小投递延迟算法"></a>最小投递延迟算法</h4><p>该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的Queue。如果延迟相同，则采用轮询算法投递</p><blockquote><p>该算法也存在一个问题：消息在Queue上的分配不均匀。投递延迟小的Queue其可能会存在大量的消息。而对该Queue的消费者压力会增大，降低消息的消费能力，可能会导致MQ中消息的堆积。</p></blockquote><h2 id="二、消息的存储"><a href="#二、消息的存储" class="headerlink" title="二、消息的存储"></a>二、消息的存储</h2><p>RocketMQ中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录<code>%USERPROFILE%，即C:\Users\CZH</code>下的store目录中。</p><ul><li><p>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失，如果broker异常退出，则文件会一直存在，在启动时会走其他流程进行文件修复等。</p></li><li><p>checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳。</p></li><li><p>commitlog：存放消息实体，所有topic的消息都会通过追加的方式往commitlog文件中写入，单文件大小默认为1G，文件名为起始偏移量，长度为20位，左边补零。</p></li><li><p>config：存放topic和订阅组的配置信息，以及消费进度等。</p></li><li><p>consumequeue：存放消息消费队列，只有写入到这里的数据，才能够被消费者消费，每个topic都会在此目录下创建一个同名目录，每个队列会建立对应的索引文件，用于加快消息的检索和节省磁盘空间，里面存放了消息的关键信息，如commitog文件中的偏移量、消息长度、tag的hashcode值等。</p></li><li><p>index：存放消息索引文件，只有写入到这里的数据，才能够通过key或者msgId等进行查询。</p></li><li><p>lock：运行期间使用到的全局资源锁，在consumer进行rebalance的时候。</p></li></ul><p>1.commitlog文件</p><p>p43</p><h2 id="三、indexFile"><a href="#三、indexFile" class="headerlink" title="三、indexFile"></a>三、indexFile</h2><h2 id="四、消息的消费"><a href="#四、消息的消费" class="headerlink" title="四、消息的消费"></a>四、消息的消费</h2><p>消费者从Broker中获取消息的方式有两种：pull拉取方式和push推动方式。消费者组对于消息消费的模式又分为两种：集群消费Clustering和广播消费Broadcasting。</p><h3 id="1-获取消费类型"><a href="#1-获取消费类型" class="headerlink" title="1.获取消费类型"></a>1.获取消费类型</h3><h4 id="拉取式消费"><a href="#拉取式消费" class="headerlink" title="拉取式消费"></a>拉取式消费</h4><p>Consumer主动从Broker中拉取消息，主动权由Consumer控制。一旦获取了批量消息，就会启动消费过程。不过，该消息的实时性较弱，即Broekr中有了新的消息时消费者并不能及时发现并消费。</p><blockquote><p>拉取时间间隔由用户指定，所以在设置该间隔时需要注意平衡：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差。</p></blockquote><h4 id="推送式消费"><a href="#推送式消费" class="headerlink" title="推送式消费"></a>推送式消费</h4><p>该模式下Broker收到数据后会主动推送给Consumer。该消费模式一般实时性较高。</p><p>该消费类型是典型的<code>发布-订阅</code>模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息，而这些都是基于Consumer与Broker间的长连接的，长连接的维护是需要消耗系统资源的。</p><p>对比</p><ul><li>pull：需要应用去实现对关联Queue的遍历，实时性差；但便于应用控制消息的拉取。</li><li>push：封装了对关联Queue的遍历，实时性强，但会占用较多的系统资源。</li></ul><h3 id="2-消费模式"><a href="#2-消费模式" class="headerlink" title="2.消费模式"></a>2.消费模式</h3><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收同一个Topic的全量的消息。即每条消息都会被发送到Consumer Group中的<code>每个</code>Consumer。</p><h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><p>集群消费模式下,相同Consumer Group的每个Consumer实例<code>平均分摊</code>同一个Topic的消息。即每条消息只会被发送到Consumer Group中的<code>某个</code>Consumer。</p><h4 id="消息进度保存"><a href="#消息进度保存" class="headerlink" title="消息进度保存"></a>消息进度保存</h4><ul><li>广播模式：消息进度保存在consumer端。因为广播模式下consumer group中每个consumer都会消费所有消息，但它们的消费进度是不同的，所以consumer各自保存各自的消费进度。</li><li>集群模式：消费进度保存在Broker中。consumer group中的所有consumer共同消费同一个Topic中的消息，同一条消息只会被消费一次。消费进度会参与到消费的负载均衡中，故消费进度是需要共享的。</li></ul><h3 id="3-Rebalance机制"><a href="#3-Rebalance机制" class="headerlink" title="3.Rebalance机制"></a>3.Rebalance机制</h3><p>Rebalance机制讨论的前提是<code>集群消费模式</code></p><h4 id="什么是Rebalance"><a href="#什么是Rebalance" class="headerlink" title="什么是Rebalance"></a>什么是Rebalance</h4><p>Rebalance即再均衡，指的是将一个Topic下的多个Queue在同一个Consumer Group中的多个Consumer间进行重新分配的过程。</p><p><img src="/2022/08/15/RocketMQ/image-20211229175925307.png" alt="RocketMQ工作原理"></p><p>Rebalance机制的本意是为了提升消息的并行消费能力。例如，一个Topic下5个队列，在只有一个消费者的情况下，这个消费者将负责消费这5个队列的消息。如果此时我们增加一个消费者，那么就可以给其中一个消费者分配2个队列，给另一个分配3个队列，从而提升消息的并行消费能力。</p><h4 id="Rebalance限制"><a href="#Rebalance限制" class="headerlink" title="Rebalance限制"></a>Rebalance限制</h4><p>由于一个队列最多分配给一个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列。</p><h4 id="Rebalance危害"><a href="#Rebalance危害" class="headerlink" title="Rebalance危害"></a>Rebalance危害</h4><p><strong>消费暂停：</strong>在只有一个Consumer时，其负责消费所有队列，在新增了一个Consumer后会触发Rebalance的发生。此时原Consumer就需要暂停部分队列的消费，等到这些队列分配给新的Consumer后，这些暂停消费的队列才能继续被消费。</p><p><strong>消费重复：</strong>Consumer在消费分配给自己的队列时，必须接着之前Consumer提交的消费进度的offset继续消费。然而默认情况下，offset是异步提交的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复提交的消息。</p><blockquote><p>同步提交：consumer提交了其消费完毕的一批消息的offset给broker后，需要等待broker的成功ACK。当收到ACK后，consumer才会继续获取并消费下一批消息（从ack中获取nextBeginOffset）。获取ACK超时会重新提交offset，直到获取到响应。在等待ACK期间，consumer是阻塞的（严重影响吞吐量）。</p><p>异步提交：consumer提交了其消费完毕的一批消息的offset给broker后，不需要等待broker的成功ACK。consumer可以直接获取并消费下一批消息。</p></blockquote><p><strong>消费突刺：</strong>由于Rebalance可能导致重复消费，如果需要重复消费的消息过多，或者因为Rebalance暂停时间过长从而导致积压了部分消息。那么有可能会导致在Rebalance结束之后瞬间需要消费很多消息。</p><h4 id="Rebalance产生的原因"><a href="#Rebalance产生的原因" class="headerlink" title="Rebalance产生的原因"></a>Rebalance产生的原因</h4><p>导致Rebalance产生的原因无非就两个：消费者所订阅Topic的Queue数量发生变化，或消费者组中消费者数量发生变化。</p><h4 id="Rebalance过程"><a href="#Rebalance过程" class="headerlink" title="Rebalance过程"></a>Rebalance过程</h4><p>在Broker中维护着多个Map集合，这些集合中动态存放着当前Topic中Queue的信息、Consumer Group中Consumer实例的信息。一旦发现消费者所订阅的Queue数量发生变化，或消费者组中消费者的数量发生变化，立即向Consuemr Group中的每个实例发出Rebalance通知。</p><p>Consumer实例在接收到通知后会采用<code>Queue分配算法</code>自己获取到相应的Queue，即由Consumer实例自主进行Rebalance。</p><h4 id="与Kafka对比"><a href="#与Kafka对比" class="headerlink" title="与Kafka对比"></a>与Kafka对比</h4><p>在Kafka中，一旦发现出现了Rebalance条件，Broker会调用Group Coordinator来完成Rebalance。Coordinator是Broker中的一个进程。Coordinator会在Consumer Group中选出一个Group Leader。由这个Leader根据自己本身组情况完成Partition分区的再分配。这个再分配结果会上报给Coordinator，并由Coordinator同步给Group中的所有Consumer实例。</p><p>Kafka中的Rebalance是由Consumer Leader完成的。而RocketMQ中Rebalance是由每个Consumer自身完成的，Group中不存在Leader。</p><h3 id="4-Queue分配算法"><a href="#4-Queue分配算法" class="headerlink" title="4.Queue分配算法"></a>4.Queue分配算法</h3><p>一个Topic中的Queue只能由Consumer Group中的一个Consumer进行消费，那么它们间的配对关系是如何确定的，即Queue要分配给哪个Consumer进行消费？也是有算法策略的。常见的有4种策略。这些策略是通过在创建Consumer时的构造器传进去的。</p><h4 id="平均分配策略"><a href="#平均分配策略" class="headerlink" title="平均分配策略"></a>平均分配策略</h4><p>该算法是根据<code>avg = QueueCount / ConsumerCount</code>的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配给Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。</p><blockquote><p>该算法即，先计算好每个Consumer应该分得几个Queue，然后再依次将这些数量的Queue逐个分配。</p></blockquote><h4 id="环形平均策略"><a href="#环形平均策略" class="headerlink" title="环形平均策略"></a>环形平均策略</h4><p><img src="/2022/08/15/RocketMQ/image-20211229175054146.png" alt="环形平均策略"></p><p>环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。</p><h4 id="一致性hash策略"><a href="#一致性hash策略" class="headerlink" title="一致性hash策略"></a>一致性hash策略</h4><p><img src="/2022/08/15/RocketMQ/image-20211229175134329.png" alt="一致性hash策略"></p><p>该算法会将consumer的hash值作为Node节点存放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。</p><p>应用场景：</p><p>Consumer数量变化较频繁的场景。</p><blockquote><p>缺点：分配不均</p><p>优点：队列扩缩容或Consumer数量变化频繁时变化小</p></blockquote><h4 id="同机房策略"><a href="#同机房策略" class="headerlink" title="同机房策略"></a>同机房策略</h4><p><img src="/2022/08/15/RocketMQ/image-20211229175233233.png" alt="同机房策略"></p><p>该算法会根据Queue的部署机房位置和Consumer的位置，过滤出当前相同机房的Queue，然后按照平均分配或环形平均策略对同机房的Queue进行分配，如果没有同机房的Queue，则会按照平均策略或者环形平均策略对所有的Queue进行分配。</p><h3 id="5-至少一次原则"><a href="#5-至少一次原则" class="headerlink" title="5.至少一次原则"></a>5.至少一次原则</h3><p>RocketMQ有一个原则，每条消息必须被成功消费一次。</p><p>什么是消费成功呢？Consumer在消息消费完成后会向其消费进度记录器提交消费消息的offset，offset被成功记录到记录器中，那么这条消息就被成功消费了。</p><h2 id="五、订阅关系的一致性"><a href="#五、订阅关系的一致性" class="headerlink" title="五、订阅关系的一致性"></a>五、订阅关系的一致性</h2><p>订阅关系一致指的是同一个消费者Group ID下所有Consumer实例所订阅的Topic、Tag必须完全一致。如果订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。</p><p>[订阅关系一致 (aliyun.com)](<a href="https://help.aliyun.com/document_detail/43523.html">订阅关系一致 (aliyun.com)</a>)</p><h2 id="六、offset管理"><a href="#六、offset管理" class="headerlink" title="六、offset管理"></a>六、offset管理</h2><p>p61</p><h2 id="七、消费幂等"><a href="#七、消费幂等" class="headerlink" title="七、消费幂等"></a>七、消费幂等</h2><h3 id="1-什么是消费幂等"><a href="#1-什么是消费幂等" class="headerlink" title="1.什么是消费幂等"></a>1.什么是消费幂等</h3><p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p><blockquote><p>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。</p></blockquote><p>在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p><h3 id="2-消息重复的场景分析"><a href="#2-消息重复的场景分析" class="headerlink" title="2.消息重复的场景分析"></a>2.消息重复的场景分析</h3><p>什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：</p><h4 id="发送时消息重复"><a href="#发送时消息重复" class="headerlink" title="发送时消息重复"></a>发送时消息重复</h4><p>当一条消息已被成功发送到Broker并完成持久化，此时出现了网络闪断，从而导致Broker对Producer应答失败。如果此时Producer意识到消息发送失败并尝试再次发送消息，此时Broker中就可能会出现两条内容相同并且Message ID也相同的消息，那么后续Consumer就一定会消费两次该消息。</p><h4 id="消费时消息重复"><a href="#消费时消息重复" class="headerlink" title="消费时消息重复"></a>消费时消息重复</h4><p>消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，Broker没有接收到消费成功响应。为了保证消息<code>至少被消费一次</code>的原则，Broker将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。</p><h4 id="Rebalance时消息重复"><a href="#Rebalance时消息重复" class="headerlink" title="Rebalance时消息重复"></a>Rebalance时消息重复</h4><p>当Consumer Group中的Consumer数量发生变化时，或其订阅的Topic的Queue数量发生变化时，会触发Reblance，此时Consumer可能会收到曾经被消费过的消息。</p><h3 id="3-通用解决方案"><a href="#3-通用解决方案" class="headerlink" title="3.通用解决方案"></a>3.通用解决方案</h3><h4 id="两要素"><a href="#两要素" class="headerlink" title="两要素"></a>两要素</h4><p>幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，都可以设计出好的幂等解决方案。</p><ul><li>幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。</li><li>唯一性处理:服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>对于常见的系统，幂等性操作的通用性解决方案是：</p><p>1.首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。</p><p>2.在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。</p><p>3.在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到DB中。</p><blockquote><p>第1步已经判断过是否是重复性操作了，为什么第2步还要再次判断？能够进入第2步，说明已经不是重复操作了，第二次判断是否重复？</p><p>不重复，一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接到达了DBMS。</p></blockquote><h2 id="八、消息堆积与消息延迟"><a href="#八、消息堆积与消息延迟" class="headerlink" title="八、消息堆积与消息延迟"></a>八、消息堆积与消息延迟</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多，这部分消息就被称为堆积消息。消息出现堆积进而会造成消息的消费延迟。以下场景需要重点关注消息堆积和消费延迟问题：</p><ul><li>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</li><li>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消息延迟也无法接受。</li></ul><h3 id="2-产生原因分析"><a href="#2-产生原因分析" class="headerlink" title="2.产生原因分析"></a>2.产生原因分析</h3><p>Consumer使用长轮询Pull模式消费消息时，分为以下两个阶段：</p><h4 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h4><p>Consumer通过长轮询Pull模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。</p><h4 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h4><p>Consumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的<code>消费耗时</code>和<code>消费并发度</code>了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由<code>消费耗时</code>和<code>消费并发度</code>决定。</p><h3 id="3-消费耗时"><a href="#3-消费耗时" class="headerlink" title="3.消费耗时"></a>3.消费耗时</h3><p>影响消息处理时长的代码逻辑，可能主要产生于两种类型的代码：CPU内部计算型代码和外部I&#x2F;O操作型代码。</p><p>通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I&#x2F;O操作来说几乎可以忽略。所以外部IO型代码是影响消息处理时长的主要症结所在。</p><h3 id="4-消费并发度"><a href="#4-消费并发度" class="headerlink" title="4.消费并发度"></a>4.消费并发度</h3><p>一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为<code>单节点线程数</code>*<code>节点数量</code>。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。</p><blockquote><p>单节点线程数：单个Consumer所包含的线程数量</p><p>节点数量：Consumer Group所包含的Consumer数量</p><p>对于普通消息、延时消息及事务消息，并发度计算都是<code>单节点线程数</code>*<code>节点数量</code>。但对于顺序消息则是不同的。顺序消息的消息并发度等于Topic的Queue分区数量。</p></blockquote><h3 id="5-单机线程数计算"><a href="#5-单机线程数计算" class="headerlink" title="5.单机线程数计算"></a>5.单机线程数计算</h3><p>对于一台主机中线程池中线程数的设置需要谨慎，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。理想环境下单节点的最优线程数计算模型为：C*(T1+T2)&#x2F;T1。</p><ul><li>C：CPU内核数</li><li>T1：CPU内部逻辑计算耗时</li><li>T2：外部IO操作哦耗时</li></ul><h2 id="九、消息的清理"><a href="#九、消息的清理" class="headerlink" title="九、消息的清理"></a>九、消息的清理</h2><p>消息被消费后会被清理掉吗？不会</p><p>消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。</p><p>commitlog文件存在一个<code>过期时间</code>，默认为72小时，即3天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p><ul><li>文件过期，且到达<code>清理时间点</code>（默认为凌晨4点）后，自动清理过期文件。</li><li>文件过期，且磁盘空间占用率已达<code>过期清理警戒线</code>（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件。</li><li>磁盘占用率达到<code>清理警戒线</code>（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理。</li><li>磁盘占用率达到<code>系统危险警戒线</code>（默认90%）后，Broker将拒绝消息写入。</li></ul><h1 id="第4章-RocketMQ应用"><a href="#第4章-RocketMQ应用" class="headerlink" title="第4章 RocketMQ应用"></a>第4章 RocketMQ应用</h1><h2 id="一、普通消息"><a href="#一、普通消息" class="headerlink" title="一、普通消息"></a>一、普通消息</h2><p>Producer对于消息的发送方式有多种选择，不同的方式会产生不同的系统效果。</p><h3 id="1-消息发送分类"><a href="#1-消息发送分类" class="headerlink" title="1.消息发送分类"></a>1.消息发送分类</h3><h4 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h4><p>同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的可靠性最高，但消息发送效率太低。</p><h4 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h4><p>异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</p><h4 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h4><p>单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。使用该发送方式时，MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。</p><h3 id="2-代码举例"><a href="#2-代码举例" class="headerlink" title="2.代码举例"></a>2.代码举例</h3><p>同步消息发送生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步发送消息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建一个producer，参数为Producer Group名称</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;pg&quot;</span>);<br>        <span class="hljs-comment">//指定nameServer地址</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        <span class="hljs-comment">//设置当发送失败时重试发送的次数，默认为2次</span><br>        producer.setRetryTimesWhenSendFailed(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//设置发送超时时限为5s，默认3秒</span><br>        producer.setSendMsgTimeout(<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">//开启生产者</span><br>        producer.start();<br><br>        <span class="hljs-comment">//生产并发送10条消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">byte</span>[] body = (<span class="hljs-string">&quot;Hi,&quot;</span> + i).getBytes();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;someTopic&quot;</span>, <span class="hljs-string">&quot;someTag&quot;</span>, body);<br>            <span class="hljs-comment">//发送消息</span><br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(msg);<br>            System.out.println(sendResult);<br>        &#125;<br>        <span class="hljs-comment">//关闭producer</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异步消息发送生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建一个producer，参数为Producer Group名称</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;pg&quot;</span>);<br>        <span class="hljs-comment">//指定nameServer地址</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        <span class="hljs-comment">//指定异步发送失败后不进行重试</span><br>        producer.setRetryTimesWhenSendAsyncFailed(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//指定新创建的Topic的Queue数量为2，默认为4</span><br>        producer.setDefaultTopicQueueNums(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//开启生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">byte</span>[] body = (<span class="hljs-string">&quot;Hi,&quot;</span> + i).getBytes();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;myTopic&quot;</span>, <span class="hljs-string">&quot;mytag&quot;</span>, body);<br>                <span class="hljs-comment">//异步发送指定回调</span><br>                producer.send(msg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendCallback</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(SendResult sendResult)</span> &#123;<br>                        System.out.println(sendResult);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onException</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>                        throwable.printStackTrace();<br>                    &#125;<br>                &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//由于采用的是异步发送，如果不sleep，则消息还未发送就会将producer给关闭</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        producer.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>单向消息发送生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnewayProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建一个producer，参数为Producer Group名称</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;pg&quot;</span>);<br>        <span class="hljs-comment">//指定nameServer地址</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        <span class="hljs-comment">//开启生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">byte</span>[] body = (<span class="hljs-string">&quot;Hi,&quot;</span> + i).getBytes();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;single&quot;</span>, <span class="hljs-string">&quot;someTag&quot;</span>, body);<br>            producer.sendOneway(msg);<br>        &#125;<br>        producer.shutdown();<br>        System.out.println(<span class="hljs-string">&quot;producer shutdown&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消息消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeConsumer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException &#123;<br>        <span class="hljs-comment">//定义一个pull消费者</span><br>        <span class="hljs-comment">//DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(&quot;cg&quot;);</span><br>        <span class="hljs-comment">//定义一个push消费者</span><br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;cg&quot;</span>);<br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        <span class="hljs-comment">//指定从第一条消息开始消费</span><br>        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);<br>        <span class="hljs-comment">//指定消费topic与tag</span><br>        consumer.subscribe(<span class="hljs-string">&quot;someTopic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">//指定采用“广播模式”进行消费，默认为“集群模式”</span><br>        consumer.setMessageModel(MessageModel.BROADCASTING);<br><br>        <span class="hljs-comment">//注册消息监听器</span><br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>            <span class="hljs-comment">//一旦broker中有了其订阅的消息就会触发该方法的执行</span><br>            <span class="hljs-comment">//其返回值为当前consumer消费的状态</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;<br>                <span class="hljs-keyword">for</span> (MessageExt messageExt : list) &#123;<br>                    System.out.println(messageExt);<br>                &#125;<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//开启消费者</span><br>        consumer.start();<br>        System.out.println(<span class="hljs-string">&quot;Consumer Started&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、顺序消息"><a href="#二、顺序消息" class="headerlink" title="二、顺序消息"></a>二、顺序消息</h2><h3 id="1-什么是顺序消息"><a href="#1-什么是顺序消息" class="headerlink" title="1.什么是顺序消息"></a>1.什么是顺序消息</h3><p>顺序消息指的是，严格按照消息的发送顺序进行消费的消息。</p><p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只能从这个Queue上拉取消息，就严格保证了消息的顺序性。</p><h3 id="2-为什么需要顺序消息"><a href="#2-为什么需要顺序消息" class="headerlink" title="2.为什么需要顺序消息"></a>2.为什么需要顺序消息</h3><p>例如，现在有TOPIC ORDER_STATUS，其下有4个Queue队列，该Topic中的不同消息用于描述当前订单的不同状态。假设订单有状态：未支付、已支付、发货中、发货成功、发货失败。</p><p>根据以上订单状态，生产者从时序上可以生成如下几个消息：</p><p>订单000001：未支付 –&gt; 订单0001：已支付 –&gt; 订单0001：发货中 –&gt; 订单0001：发货失败</p><p>可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个Queue中，然后消费者再采用一定的策略（例如，一个线程独立处理一个queue，保证处理消息的顺序性），能够保证消费的顺序性。</p><h3 id="3-有序性分类"><a href="#3-有序性分类" class="headerlink" title="3.有序性分类"></a>3.有序性分类</h3><p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：<code>分区有序</code>与<code>全局有序</code>。</p><p><strong>全局有序</strong></p><p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序，称为<code>全局有序</code>。</p><p><strong>分区有序</strong></p><p><img src="/2022/08/15/RocketMQ/image-20211214112330003.png" alt="分区有序示意图"></p><p>如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为<code>分区有序</code></p><blockquote><p>如何实现Queue的选择？在定义Producer是可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。</p><p>在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其他数据。但无论谁做选择key，都不能重复，都是唯一的。</p><p>一般性的选择算法是，让选择key与该topic所包含的queue的数量取模，其结果即为选择出的Queue的QueueId</p><p>取模算法存在一个问题：不同选择key与Queue数量取模结果可能是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consumer可能会消费到不同选择key的消息。这个问题如何解决？一般性的做法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。</p></blockquote><h3 id="4-代码举例"><a href="#4-代码举例" class="headerlink" title="4.代码举例"></a>4.代码举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderedProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建一个producer，参数为Producer Group名称</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;pg&quot;</span>);<br>        <span class="hljs-comment">//指定nameServer地址</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        <span class="hljs-comment">//若为全局有序，则需要设置queue数量为1</span><br>        producer.setDefaultTopicQueueNums(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//开启生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-type">byte</span>[] body = (<span class="hljs-string">&quot;Hi,&quot;</span> + i).getBytes();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicA&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, body);<br>            <span class="hljs-comment">//将orderId作为消息key</span><br>            message.setKeys(orderId.toString());<br>            <span class="hljs-comment">// send()的第三个参数值会传递给选择器的select()的第三个参数</span><br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br>                <span class="hljs-comment">//具体的选择算法在该方法中定义</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;<br>                    <span class="hljs-comment">//一下是使用消息key作为选择的选择算法</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> msg.getKeys();<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Integer.valueOf(keys);<br><br>                    <span class="hljs-comment">//一下是使用arg作为选择key的选择算法</span><br>                    <span class="hljs-comment">//Integer id = (Integer) arg;</span><br><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> id % mqs.size();<br>                    <span class="hljs-keyword">return</span> mqs.get(index);<br>                &#125;<br>            &#125;, orderId);<br>            System.out.println(sendResult);<br>        &#125;<br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、延时消息"><a href="#三、延时消息" class="headerlink" title="三、延时消息"></a>三、延时消息</h2><h3 id="1-什么是延时消息"><a href="#1-什么是延时消息" class="headerlink" title="1.什么是延时消息"></a>1.什么是延时消息</h3><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。</p><p>采用RocketMQ的延时消息可以实现定时任务的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景，12306平台订票超时未支付取消订票的场景。</p><h3 id="2-延时等级"><a href="#2-延时等级" class="headerlink" title="2.延时等级"></a>2.延时等级</h3><p>延时消息的延迟时长<code>不支持随意时长的延迟</code>，是通过特定的延迟等级来指定的。延迟等级定义在RocketMQ服务端的<code>MessageStoreConfig</code>类中的如下变量中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">messageDelayLevel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span><br></code></pre></td></tr></table></figure><p>即，若指定的延时等级为3，则表示延迟时长为10s，即延时等级是从1开始计数的。</p><h3 id="3-延时消息实现原理"><a href="#3-延时消息实现原理" class="headerlink" title="3.延时消息实现原理"></a>3.延时消息实现原理</h3><h4 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h4><p>Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p><ul><li><p>修改消息的Topic为<code>SCHEDULE_TOPIC_XXXX</code></p></li><li><p>根据延时等级，在consumequeue目录中<code>SCHEDULE_TOPIC_XXXX</code>主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）</p><blockquote><p>延迟等级delayLevel与queueId的对应关系为queueId &#x3D; delayLevel - 1</p><p>需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p></blockquote></li><li><p>修改消息索引单元的内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的投递时间。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。投递时间 &#x3D; 消息存储时间 + 延时等级时间。消息存储时间指的是消息被发送到Broker时的时间戳。</p></li><li><p>将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumerqueue中。</p></li></ul><h4 id="投递延时消息"><a href="#投递延时消息" class="headerlink" title="投递延时消息"></a>投递延时消息</h4><p>Broker内部有一个延迟消息服务类，其会消费<code>SCHEDULE_TOPIC_XXXX</code>中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为0，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。</p><blockquote><p>ScheduleMessageService在Broker启动时，会创建并启动一个定时器Timer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimeTask负责一个延时等级消息的消费与投递。每个TimerTask都会检测相应Queue队列的第一条消息是否到期，若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）</p></blockquote><h4 id="将消息重新写入commitlog"><a href="#将消息重新写入commitlog" class="headerlink" title="将消息重新写入commitlog"></a>将消息重新写入commitlog</h4><p>延迟消息服务类将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p><h3 id="4-代码举例-1"><a href="#4-代码举例-1" class="headerlink" title="4.代码举例"></a>4.代码举例</h3><p>定义DelayProducer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建一个producer，参数为Producer Group名称</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;pg&quot;</span>);<br>        <span class="hljs-comment">//指定nameServer地址</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        <span class="hljs-comment">//开启生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">byte</span>[] body = (<span class="hljs-string">&quot;Hi,&quot;</span> + i).getBytes();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicB&quot;</span>, <span class="hljs-string">&quot;TagB&quot;</span>, body);<br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(msg);<br>            <span class="hljs-comment">//指定消息延时等级</span><br>            msg.setDelayTimeLevel(<span class="hljs-number">3</span>);<br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>            System.out.println(<span class="hljs-string">&quot;,&quot;</span> + sendResult);<br>        &#125;<br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、事务消息"><a href="#四、事务消息" class="headerlink" title="四、事务消息"></a>四、事务消息</h2><h3 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h3><p>需求场景：工行用户A向建行用户B转账1万元</p><p>使用同步消息处理需求场景</p><ol><li>工行系统发送一个给B增款1万元的同步消息M给Broker</li><li>消息被Broker成功接收后，向工行系统发送成功ACK</li><li>工行系统收到成功ACK后从用户A中扣款1万元</li><li>建行系统从Broker中获取到消息M</li><li>建行系统从Broker中获取到消息M，即向用户B中增加1万元</li></ol><h3 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2.解决思路"></a>2.解决思路</h3><p>p86</p><h2 id="五、批量发送消息"><a href="#五、批量发送消息" class="headerlink" title="五、批量发送消息"></a>五、批量发送消息</h2><h3 id="1-批量发送消息"><a href="#1-批量发送消息" class="headerlink" title="1.批量发送消息"></a>1.批量发送消息</h3><p><strong>发送限制</strong></p><p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以下几点：</p><ul><li>批量发送的消息必须具有相同的Topic</li><li>批量发送的消息必须具有相同的刷盘策略</li><li>批量发送的消息不能是延时消息与事务消息</li></ul><p><strong>批量发送大小</strong></p><p>默认情况下，一批发送的消息不能超过4MB字节。如果想超出该值，有两种解决方案：</p><ul><li>方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送。</li><li>方案二：在Producer端与Broker端修改属性<ul><li>Producer端需要在发送之前设置Producer的maxMessageSize属性</li><li>Broker端需要修改其加载的配置文件中的maxMessageSize属性</li></ul></li></ul><p><strong>生产者发送的消息大小</strong></p><p>生产者通过send()方法发送的message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占20字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p><h3 id="2-批量消费消息"><a href="#2-批量消费消息" class="headerlink" title="2.批量消费消息"></a>2.批量消费消息</h3><p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过32。因为默认情况下消费者每次可以拉取的消息最多是32条。若要修改一次拉取的最大值，则可通过修改Consuemr的pullBatchSize属性来指定。</p><p><strong>存在的问题</strong></p><p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置得越大越好？当然不是。</p><ul><li>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中出现了问题，那么本批次所有的消息都需要全部重新拉取。</li><li>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。</li></ul><h3 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3.代码举例"></a>3.代码举例</h3><p>p93 05:05</p><h2 id="六、消息过滤"><a href="#六、消息过滤" class="headerlink" title="六、消息过滤"></a>六、消息过滤</h2><h2 id="七、消息消费重试机制"><a href="#七、消息消费重试机制" class="headerlink" title="七、消息消费重试机制"></a>七、消息消费重试机制</h2><h2 id="八、死信队列"><a href="#八、死信队列" class="headerlink" title="八、死信队列"></a>八、死信队列</h2><h2 id="九、消息发送重试机制"><a href="#九、消息发送重试机制" class="headerlink" title="九、消息发送重试机制"></a>九、消息发送重试机制</h2><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h3 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h3><p>先提条件：Topic：someTopic（默认4个队列）</p><ul><li><p>producer（someTopic，tagA）</p></li><li><p>ConsumerA1（someTopic，tagA）</p></li><li><p>ConsumerA2（someTopic，tagA）</p></li></ul><p>结果：</p><p>ConsumerA1消费queueId&#x3D;0,queueId&#x3D;3</p><p>ConsumerA2消费queueId&#x3D;1,queueId&#x3D;2</p><p>顺序启动ConsumerA1、ConsumerA2，再启动producer生产10条消息</p><h3 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h3><p>先提条件：Topic：someTopic（默认4个队列）</p><ul><li><p>producer（someTopic，tagA）</p></li><li><p>ConsumerA1（someTopic，tagA）</p></li><li><p>ConsumerA2（someTopic，tagA）</p></li><li><p>ConsumerA3（someTopic，tagA）</p></li></ul><p>顺序启动ConsumerA1、ConsumerA2、ConsumerA3，再启动producer生产10条消息</p><p>结果：</p><p>ConsumerA1消费queueId&#x3D;2</p><p>ConsumerA2消费queueId&#x3D;3</p><p>ConsumerA3消费queueId&#x3D;0,queueId&#x3D;1</p><h3 id="测试3"><a href="#测试3" class="headerlink" title="测试3"></a>测试3</h3><p>先提条件：Topic：someTopic（默认4个队列）</p><ul><li><p>producer1（someTopic，tagA）</p></li><li><p>producer2（someTopic，tagB）</p></li><li><p>ConsumerA1（someTopic，tagA）</p></li><li><p>ConsumerA2（someTopic，tagA）</p></li><li><p>ConsumerA3（someTopic，tagB）</p></li></ul><p>顺序启动ConsumerA1、ConsumerA2、ConsumerA3，再启动producer1生产10条消息</p><p>结果：</p><p>所有消费者均没有收到消息（原因，consumerA3最后启动，将订阅的tag进行了覆盖，此消费者组只消费tagB）</p><blockquote><p>再启动一个producer2（someTopic，tagB）</p><p>Consumer3消费queueId&#x3D;3</p><p>其他消费者无消费信息</p></blockquote><h3 id="测试4"><a href="#测试4" class="headerlink" title="测试4"></a>测试4</h3><p>先提条件：Topic：someTopic（默认4个队列）</p><ul><li><p>producer1（someTopic，tagA）</p></li><li><p>producer2（someTopic，tagB）</p></li><li><p>ConsumerA1（someTopic，tagA）</p></li><li><p>ConsumerA2（someTopic，tagA）</p></li><li><p>ConsumerA3（someTopic，tagB）</p></li></ul><p>顺序启动ConsumerA3、ConsumerA2、ConsumerA1，再启动producer1生产10条消息</p><p>结果：</p><p>ConsumerA1消费queueId&#x3D;3</p><p>ConsumerA2消费queueId&#x3D;0,queueId&#x3D;1</p><p>ConsumerA3无消费</p><blockquote><p>再启动producer2（someTopic，tagB）</p><p>ConsumerA3依旧无消费任何消息</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MessageQueue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发编程</title>
    <link href="/2022/04/21/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/21/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA多线程基础（链接）"><a href="#JAVA多线程基础（链接）" class="headerlink" title="JAVA多线程基础（链接）"></a><a href="E:\study\markdown笔记\JAVA多线程基础">JAVA多线程基础（链接）</a></h1><p><strong>JUC并发编程</strong></p><h1 id="1-JUC概述"><a href="#1-JUC概述" class="headerlink" title="1.JUC概述"></a>1.JUC概述</h1><h2 id="1-1-什么是JUC"><a href="#1-1-什么是JUC" class="headerlink" title="1.1 什么是JUC"></a>1.1 什么是JUC</h2><p>JUC是<code>java.util.concurrent</code>工具包的简称，是一个处理线程的工具包，JDK1.5开始出现。</p><h2 id="1-2-线程和进程的概念"><a href="#1-2-线程和进程的概念" class="headerlink" title="1.2 线程和进程的概念"></a>1.2 线程和进程的概念</h2><p>**进程(Process)**是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><h2 id="1-3-线程的状态"><a href="#1-3-线程的状态" class="headerlink" title="1.3 线程的状态"></a>1.3 线程的状态</h2><h3 id="1-3-1-线程状态枚举类"><a href="#1-3-1-线程状态枚举类" class="headerlink" title="1.3.1 线程状态枚举类"></a>1.3.1 线程状态枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">         */</span><br>        NEW,(新建)<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">         * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">         * be waiting for other resources from the operating system</span><br><span class="hljs-comment">         * such as processor.</span><br><span class="hljs-comment">         */</span><br>        RUNNABLE,（准备就绪）<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">         * to enter a synchronized block/method or</span><br><span class="hljs-comment">         * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">         */</span><br>        BLOCKED,（阻塞）<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Thread state for a waiting thread.</span><br><span class="hljs-comment">         * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">         * following methods:</span><br><span class="hljs-comment">         * &lt;ul&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">         * &lt;/ul&gt;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">         * perform a particular action.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">         * on an object is waiting for another thread to call</span><br><span class="hljs-comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">         * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">         */</span><br>        WAITING,（不见不散）<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">         * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">         * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">         * &lt;ul&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">         *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">         * &lt;/ul&gt;</span><br><span class="hljs-comment">         */</span><br>        TIMED_WAITING,（过时不候）<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Thread state for a terminated thread.</span><br><span class="hljs-comment">         * The thread has completed execution.</span><br><span class="hljs-comment">         */</span><br>        TERMINATED;（终结）<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-wait-x2F-sleep的区别"><a href="#1-3-2-wait-x2F-sleep的区别" class="headerlink" title="1.3.2 wait&#x2F;sleep的区别"></a>1.3.2 wait&#x2F;sleep的区别</h3><p>（1）sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。</p><p>（2）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在<code>synchronized</code>中）</p><p>（3）它们都可以被interrupted方法中断。</p><h2 id="1-4-并发与并行"><a href="#1-4-并发与并行" class="headerlink" title="1.4 并发与并行"></a>1.4 并发与并行</h2><h3 id="1-4-1-串行模式"><a href="#1-4-1-串行模式" class="headerlink" title="1.4.1 串行模式"></a>1.4.1 串行模式</h3><p>串行表示所有任务都一一按先后顺序进行。</p><p>串行是一次只能取得一个任务，并执行这个任务。</p><h3 id="1-4-2-并行模式"><a href="#1-4-2-并行模式" class="headerlink" title="1.4.2 并行模式"></a>1.4.2 并行模式</h3><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。</p><p><strong>并发</strong>：同一时刻多个线程访问同一个资源，多个线程对一个点。</p><p><strong>并行</strong>：多项工作一起执行，之后再汇总。</p><h2 id="1-5-管程"><a href="#1-5-管程" class="headerlink" title="1.5 管程"></a>1.5 管程</h2><p>Monitor 监视器  锁</p><p>一种同步机制，保证同一时间只有一个线程访问被保护数据或代码。</p><h2 id="1-6-用户线程和守护线程"><a href="#1-6-用户线程和守护线程" class="headerlink" title="1.6 用户线程和守护线程"></a>1.6 用户线程和守护线程</h2><h1 id="2-Lock接口"><a href="#2-Lock接口" class="headerlink" title="2.Lock接口"></a>2.Lock接口</h1><h3 id="2-1-Synchronized"><a href="#2-1-Synchronized" class="headerlink" title="2.1 Synchronized"></a>2.1 Synchronized</h3><h3 id="2-2-什么是Lock"><a href="#2-2-什么是Lock" class="headerlink" title="2.2 什么是Lock"></a>2.2 什么是Lock</h3><p>Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock提供了比synchronized更多的功能。</p><p>Lock与Synchronized区别</p><ul><li>Lock不是Java语言内置的，<code>synchronized</code>是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li><li>Lock和synchronized有一点非常大的不同，采用synchorized不需要用户手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。</li></ul><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。</p><h1 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3.线程间通信"></a>3.线程间通信</h1><h2 id="防止虚假唤醒问题"><a href="#防止虚假唤醒问题" class="headerlink" title="防止虚假唤醒问题"></a>防止虚假唤醒问题</h2><p>等待应该总是出现在循环中，就像这样： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       <span class="hljs-keyword">while</span> (&lt;condition does not hold&gt;)<br>           obj.wait(timeout);<br>       ... <span class="hljs-comment">// Perform action appropriate to condition</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>如果使用if进行判断，判断完进入了if代码块后调用了wait，之后被唤醒后代码会继续往下进行，从而不会再进入if语句进行判断，因此需要将if改为while。</p><h1 id="4-线程间定制化通信"><a href="#4-线程间定制化通信" class="headerlink" title="4.线程间定制化通信"></a>4.线程间定制化通信</h1><p>AA线程每轮打印5次，BB线程每轮打印10次，CC线程每轮打印15次，共打印10轮。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建资源类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareResource</span> &#123;<br>    <span class="hljs-comment">// 定义标志位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//创建lock锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">// 创建Condition</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//打印5次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print5</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//上锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//判断，防止虚假唤醒，使用while</span><br>            <span class="hljs-keyword">while</span> (flag != <span class="hljs-number">1</span>)&#123;<br>                c1.await();<br>            &#125;<br>            <span class="hljs-comment">// 打印5次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;::&quot;</span>+i+<span class="hljs-string">&quot;:轮数:&quot;</span>+loop);<br>            &#125;<br>            <span class="hljs-comment">//通知</span><br>            flag = <span class="hljs-number">2</span>;<br>            c2.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印10次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print10</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//上锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//判断，防止虚假唤醒，使用while</span><br>            <span class="hljs-keyword">while</span> (flag != <span class="hljs-number">2</span>)&#123;<br>                c2.await();<br>            &#125;<br>            <span class="hljs-comment">// 打印10次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;::&quot;</span>+i+<span class="hljs-string">&quot;:轮数:&quot;</span>+loop);<br>            &#125;<br>            <span class="hljs-comment">//通知</span><br>            flag = <span class="hljs-number">3</span>;<br>            c3.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印15次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print15</span><span class="hljs-params">(<span class="hljs-type">int</span> loop)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//上锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//判断，防止虚假唤醒，使用while</span><br>            <span class="hljs-keyword">while</span> (flag != <span class="hljs-number">3</span>)&#123;<br>                c3.await();<br>            &#125;<br>            <span class="hljs-comment">// 打印15次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;::&quot;</span>+i+<span class="hljs-string">&quot;:轮数:&quot;</span>+loop);<br>            &#125;<br>            <span class="hljs-comment">//通知</span><br>            flag = <span class="hljs-number">1</span>;<br>            c1.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ShareResource</span> <span class="hljs-variable">shareResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareResource</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareResource.print5(i);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;AA&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareResource.print10(i);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;BB&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    shareResource.print15(i);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;CC&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-集合的线程安全"><a href="#5-集合的线程安全" class="headerlink" title="5.集合的线程安全"></a>5.集合的线程安全</h1><h2 id="5-1-ArrayList的线程不安全"><a href="#5-1-ArrayList的线程不安全" class="headerlink" title="5.1 ArrayList的线程不安全"></a>5.1 ArrayList的线程不安全</h2><p>ArrayList是线程不安全的</p><p>解决方案：</p><ul><li>Vector（使用了synchronized关键字），方案古老，使用频率不高</li><li>Collections.synchronizedList，方案古老，使用频率不高</li><li>CopyOnWriteArrayList（JUC提供，写时复制技术）</li></ul><h2 id="5-2-HashSet线程不安全"><a href="#5-2-HashSet线程不安全" class="headerlink" title="5.2 HashSet线程不安全"></a>5.2 HashSet线程不安全</h2><p>解决方案：</p><ul><li>CopyOnWriteArraySet</li></ul><h2 id="5-3-HashMap线程不安全"><a href="#5-3-HashMap线程不安全" class="headerlink" title="5.3 HashMap线程不安全"></a>5.3 HashMap线程不安全</h2><p>解决方案：</p><ul><li>ConcurrentHashMap</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 集合线程不安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ArrayList集合</span><br>        <span class="hljs-comment">// List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><br>        <span class="hljs-comment">// Vector解决</span><br>        <span class="hljs-comment">// List&lt;String&gt; list = new Vector&lt;&gt;();</span><br><br>        <span class="hljs-comment">// Collections解决</span><br>        <span class="hljs-comment">// List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><br>        <span class="hljs-comment">// CopyOnWriteArrayList解决</span><br>        <span class="hljs-comment">// List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; 30; i++) &#123;</span><br>        <span class="hljs-comment">//     new Thread(()-&gt;&#123;</span><br>        <span class="hljs-comment">//         // 向集合中添加内容</span><br>        <span class="hljs-comment">//         list.add(UUID.randomUUID().toString().substring(0,8));</span><br>        <span class="hljs-comment">//         // 从集合中获取内容</span><br>        <span class="hljs-comment">//         System.out.println(list);</span><br>        <span class="hljs-comment">//     &#125;, String.valueOf(i)).start();</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">// 演示Hashset</span><br>        <span class="hljs-comment">// Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><br>        <span class="hljs-comment">// Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; 30; i++) &#123;</span><br>        <span class="hljs-comment">//     new Thread(()-&gt;&#123;</span><br>        <span class="hljs-comment">//         // 向集合中添加内容</span><br>        <span class="hljs-comment">//         set.add(UUID.randomUUID().toString().substring(0,8));</span><br>        <span class="hljs-comment">//         // 从集合中获取内容</span><br>        <span class="hljs-comment">//         System.out.println(set);</span><br>        <span class="hljs-comment">//     &#125;,String.valueOf(i)).start();</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        <span class="hljs-comment">// 演示HashMap</span><br>        <span class="hljs-comment">// Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(i);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-comment">// 向集合中添加内容</span><br>                map.put(key, UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>));<br>                <span class="hljs-comment">// 从集合中获取内容</span><br>                System.out.println(map);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-多线程锁"><a href="#6-多线程锁" class="headerlink" title="6.多线程锁"></a>6.多线程锁</h1><h2 id="6-1-锁的8种情况"><a href="#6-1-锁的8种情况" class="headerlink" title="6.1 锁的8种情况"></a>6.1 锁的8种情况</h2><p><a href="F:\study\my-practice\common\src\main\java\com\czh\common\multiThread\lock\Lock_8.java">锁的8种情况</a></p><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</p><p>具体表现为以下3种形式：</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的class对象。</li><li>对于同步方法块，锁是synchronized括号里配置的对象。</li></ul><h2 id="6-2-公平锁和非公平锁"><a href="#6-2-公平锁和非公平锁" class="headerlink" title="6.2 公平锁和非公平锁"></a>6.2 公平锁和非公平锁</h2><p>new ReentrantLock(false)，设为false为非公平锁，不设默认为false。</p><p>new ReentrantLock(true)，设为true为公平锁。</p><p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li></ul><ul><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><h2 id="6-3-可重入锁（递归锁）"><a href="#6-3-可重入锁（递归锁）" class="headerlink" title="6.3 可重入锁（递归锁）"></a>6.3 可重入锁（递归锁）</h2><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。</p><p>synchronized（隐式）和lock（显式）都是可重入锁。</p><h3 id="6-4-死锁"><a href="#6-4-死锁" class="headerlink" title="6.4 死锁"></a>6.4 死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLock</span> &#123;<br><br>    <span class="hljs-comment">// 创建两个对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (a)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 持有锁a，试图获取锁b&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (b)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 获取锁b&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (b)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 持有锁b，试图获取锁a&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (a)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 获取锁a&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>验证是否是死锁</strong></p><p>（1）jps</p><p>（2）jstack（jvm自带堆栈跟踪工具）</p><p>使用<code>jps -l</code>命令查看进程号，使用<code>jstack 进程号</code>命令查看是否存在死锁。</p><h1 id="7-Callable接口"><a href="#7-Callable接口" class="headerlink" title="7.Callable接口"></a>7.Callable接口</h1><p>创建线程的方法：</p><ul><li>通过继承Thread类</li><li>实现Runnable接口创建线程</li><li>实现Callable接口</li><li>线程池方式</li></ul><p>Runable缺少一项功能，当线程终止时（即run()完成时），无法使线程返回结果。为支持此功能，Java提供了Callable接口。</p><p>Callable接口的特点如下：</p><ul><li>为了实现Runnable，需要实现不返回任何内容的run()方法，而对于Callable接口，需要实现在完成时返回结果的call()方法。</li><li>call()方法可以引发异常，而run()则不能。</li><li>为实现Callable而必须重写call方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// Runnable接口创建线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>(), <span class="hljs-string">&quot;AA&quot;</span>).start();<br><br>        <span class="hljs-comment">// Callable接口，报错</span><br>        <span class="hljs-comment">// new Thread(new MyThread2(), &quot;BB&quot;).start();</span><br><br>        FutureTask&lt;Integer&gt; futureTask1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>());<br><br>        <span class="hljs-comment">//lambda表达式</span><br>        FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come in callable&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;<br>        &#125;);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask2, <span class="hljs-string">&quot;lucy&quot;</span>).start();<br><br>        <span class="hljs-keyword">while</span>(!futureTask2.isDone()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;wait...&quot;</span>);<br>        &#125;<br><br>        System.out.println(futureTask2.get());<br><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; come over&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-JUC强大的辅助类"><a href="#8-JUC强大的辅助类" class="headerlink" title="8.JUC强大的辅助类"></a>8.JUC强大的辅助类</h1><h2 id="8-1-减少计数CountDownLatch"><a href="#8-1-减少计数CountDownLatch" class="headerlink" title="8.1 减少计数CountDownLatch"></a>8.1 减少计数CountDownLatch</h2><p>CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行减1操作，使用await方法等待计数器不大于0，然后继续执行await方法之后的语句。</p><ul><li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li><li>其他线程调用countDown方法会将计数器减1（调用countDown方法的线程不会阻塞）</li><li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示CountDownLatch</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//创建CountDownLatch对象，设置初始值</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br><br>        <span class="hljs-comment">// 6个同学陆续离开教室之后，班长锁门</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 号同学离开了教室&quot;</span>);<br><br>                <span class="hljs-comment">//计数-1</span><br>                countDownLatch.countDown();<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        <span class="hljs-comment">//等待</span><br>        countDownLatch.await();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 班长锁门&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-循环栅栏CyclicBarrier"><a href="#8-2-循环栅栏CyclicBarrier" class="headerlink" title="8.2 循环栅栏CyclicBarrier"></a>8.2 循环栅栏CyclicBarrier</h2><p>允许一组线程全部等待彼此达到共同屏障点的同步辅助。循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为<em>循环</em> ，因为它可以在等待的线程被释放之后重新使用。</p><p>CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier.await()之后的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建CyclicBarrier</span><br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(NUMBER, ()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;集齐7颗龙珠可以召唤神龙&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">//集齐七颗龙珠过程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 星龙珠被收集到了&quot;</span>);<br>                    <span class="hljs-comment">//等待</span><br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-信号灯Semaphore"><a href="#8-3-信号灯Semaphore" class="headerlink" title="8.3 信号灯Semaphore"></a>8.3 信号灯Semaphore</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//6辆汽车，停3个车位</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建Semaphore，设置许可数量</span><br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">//模拟6辆汽车</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-comment">//抢占</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 抢到了车位&quot;</span>);<br><br>                    <span class="hljs-comment">//设置随机停车时间</span><br>                    TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>));<br><br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; ----离开了车位&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">//释放</span><br>                    semaphore.release();<br>                &#125;<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-ReentrantReadWriteLock读写锁"><a href="#9-ReentrantReadWriteLock读写锁" class="headerlink" title="9.ReentrantReadWriteLock读写锁"></a>9.ReentrantReadWriteLock读写锁</h1><p>共享锁(S锁)又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><p>排他锁(X锁)又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//资源类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCache</span> &#123;<br><br>    <span class="hljs-comment">//创建map集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-comment">//放数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        <span class="hljs-comment">//添加写锁</span><br>        rwLock.writeLock().lock();<br><br>        <span class="hljs-comment">//暂停一会</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 正在写&quot;</span>+key);<br><br>            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">300</span>);<br>            <span class="hljs-comment">//放数据</span><br>            map.put(key, value);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 写完了&quot;</span>+key);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放写锁</span><br>            rwLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//取数据</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span>&#123;<br>        <span class="hljs-comment">//添加读锁</span><br>        rwLock.readLock().lock();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 正在读取&quot;</span>+key);<br><br>            TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">300</span>);<br>            result = map.get(key);<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 取完了&quot;</span>+key);<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放读锁</span><br>            rwLock.readLock().unlock();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadWriteLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyCache</span> <span class="hljs-variable">myCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCache</span>();<br>        <span class="hljs-comment">//创建线程放数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                myCache.put(num+<span class="hljs-string">&quot;&quot;</span>,num+<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br><br>        <span class="hljs-comment">//创建线程取数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                myCache.get(num+<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写锁可以降级为读锁</p><ul><li>获取写锁–&gt;获取读锁–&gt;释放写锁–&gt;释放读锁</li></ul><p>读锁不能升级为写锁</p><h1 id="10-BlockingQueue阻塞队列"><a href="#10-BlockingQueue阻塞队列" class="headerlink" title="10.BlockingQueue阻塞队列"></a>10.BlockingQueue阻塞队列</h1><p>在多线程领域，所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒。</p><p>使用BlockingQueue的好处是不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，BlockingQueue会处理一切。</p><h2 id="10-1-阻塞队列的分类"><a href="#10-1-阻塞队列的分类" class="headerlink" title="10.1 阻塞队列的分类"></a>10.1 阻塞队列的分类</h2><h3 id="10-1-1-ArrayBlockingQueue-常用"><a href="#10-1-1-ArrayBlockingQueue-常用" class="headerlink" title="10.1.1 ArrayBlockingQueue(常用)"></a>10.1.1 ArrayBlockingQueue(常用)</h3><p>由数组结构组成的有界阻塞队列</p><h3 id="10-1-2-LinkedBlockingQueue-常用"><a href="#10-1-2-LinkedBlockingQueue-常用" class="headerlink" title="10.1.2 LinkedBlockingQueue(常用)"></a>10.1.2 LinkedBlockingQueue(常用)</h3><p>由链表结构组成的有界（大小默认值为integer.MAX_VALUE）阻塞队列</p><h3 id="10-1-3-DelayQueue"><a href="#10-1-3-DelayQueue" class="headerlink" title="10.1.3 DelayQueue"></a>10.1.3 DelayQueue</h3><p>使用优先级队列实现的延迟无界阻塞队列</p><h3 id="10-1-4-PriorityBlockingQueue"><a href="#10-1-4-PriorityBlockingQueue" class="headerlink" title="10.1.4 PriorityBlockingQueue"></a>10.1.4 PriorityBlockingQueue</h3><p>支持优先级排序的无界阻塞队列</p><h3 id="10-1-5-SynchronousQueue"><a href="#10-1-5-SynchronousQueue" class="headerlink" title="10.1.5 SynchronousQueue"></a>10.1.5 SynchronousQueue</h3><p>不存储元素的阻塞队列，也即单个元素的队列</p><h3 id="10-1-6-LinkedTransferQueue"><a href="#10-1-6-LinkedTransferQueue" class="headerlink" title="10.1.6 LinkedTransferQueue"></a>10.1.6 LinkedTransferQueue</h3><p>由链表组成的无界阻塞队列</p><h3 id="10-1-7-LinkedBlockingDeque"><a href="#10-1-7-LinkedBlockingDeque" class="headerlink" title="10.1.7 LinkedBlockingDeque"></a>10.1.7 LinkedBlockingDeque</h3><p>由链表组成的双向阻塞队列</p><h2 id="10-2-BlockingQueue核心方法"><a href="#10-2-BlockingQueue核心方法" class="headerlink" title="10.2 BlockingQueue核心方法"></a>10.2 BlockingQueue核心方法</h2><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><p>抛出异常：</p><ul><li>当阻塞队列满时，再往队列里add插入元素会抛<code>IllegalStateException:Queue full</code></li><li>当阻塞队列空时，再往队列里remove移除原色会抛<code>NoSuchElementException</code></li></ul><p>特殊值：</p><ul><li>插入方法，成功返回true，失败返回false。</li><li>移除方法，成功返回出队列的元素，队列里没有就返回null。</li></ul><p>阻塞：</p><ul><li>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据或响应中断退出。</li><li>当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者直到队列可用。</li></ul><p>超时退出：</p><ul><li>当阻塞队列满&#x2F;空时，队列会阻塞生产者&#x2F;消费者线程一定时间，超时后生产者&#x2F;消费者线程会退出。</li></ul><h1 id="11-ThreadPool线程池"><a href="#11-ThreadPool线程池" class="headerlink" title="11.ThreadPool线程池"></a>11.ThreadPool线程池</h1><p><strong>线程池（Thread Pool）</strong>：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务，避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能保证内核的充分利用，还能防止过分调度。</p><p><strong>线程池的优势</strong>：线程池做的工作只是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排对等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p>其主要特点：</p><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等待创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一地分配、调优和监控。</li></ul><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor, Executors, ExecutorService, ThreadPoolExecutor这几个类。</p><p><strong>ThreadPoolExecutor的七个参数</strong></p><p>int corePoolSize常驻线程数量</p><p>int maximumPoolSize最大线程数量</p><p>long keepAliveTime线程存活时间</p><p>TimeUnit unit线程存活时间</p><p>BlockingQueue<Runnable> workQueue阻塞队列</p><p>ThreadFactory threadFactory线程工厂</p><p>RejectedExecutionHandler handler拒绝策略</p><p><strong>拒绝策略</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">THREAD_POOL_EXECUTOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">4</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60</span>,<br>            TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>), Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br></code></pre></td></tr></table></figure><ul><li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行。</li><li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中，尝试再次提交当前任务。</li><li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常，如果允许任务丢失，这是最好的一种策略。</li></ul><blockquote><p>实际开发中不会使用Executors创建线程池，而是通过ThreadPoolExecutor的方式，这样的处理方式让写代码的人员更加明确线程池的运行规则，避免资源耗尽的风险。</p></blockquote><p>说明：Executors返回的线程池对象的弊端如下：</p><p>1）FixedThreadPool和SingleThreadPool:</p><p>允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</p><p>2）CacheThreadPool和ScheduledThreadPool:</p><p>允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p><p><strong>自定义线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">2</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">2L</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<br>                Executors.defaultThreadFactory(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<br>        );<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>                threadPool.execute(()-&gt;&#123;<br>                    System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; 办理业务&quot;</span>);<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            threadPool.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="12-Fork-x2F-Join分支合并框架"><a href="#12-Fork-x2F-Join分支合并框架" class="headerlink" title="12.Fork&#x2F;Join分支合并框架"></a>12.Fork&#x2F;Join分支合并框架</h1><p>Fork&#x2F;Join可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join框架要完成两件事情：</p><ul><li>Fork：把一个复杂任务进行分拆，大事化小</li><li>Join：把分拆任务的结果进行合并</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> begin;<span class="hljs-comment">//拆分开始值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<span class="hljs-comment">//拆分结束值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> result;<span class="hljs-comment">//返回结果</span><br><br>    <span class="hljs-comment">//有参构造</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-built_in">this</span>.begin = begin;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//判断</span><br>        <span class="hljs-keyword">if</span>(end - begin &lt;= VALUE)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i&lt;=end;i++)&#123;<br>                result = result + i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (begin + end)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">MyTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(begin,middle);<br>            <span class="hljs-type">MyTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(middle+<span class="hljs-number">1</span>,end);<br>            task1.fork();<br>            task2.fork();<br>            <span class="hljs-comment">//合并结果</span><br>            result = task1.join()+task2.join();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//创建MyTask对象</span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">myTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//创建分支合并池对象</span><br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> forkJoinTask.get();<br>        System.out.println(result);<br>        <span class="hljs-comment">//关闭池对象</span><br>        forkJoinPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="13-CompletableFuture异步回调"><a href="#13-CompletableFuture异步回调" class="headerlink" title="13.CompletableFuture异步回调"></a>13.CompletableFuture异步回调</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletableFutureDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//异步调用，没有返回值</span><br>        CompletableFuture&lt;Void&gt; completableFuture1 = CompletableFuture.runAsync(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; completableFuture1&quot;</span>);<br>        &#125;);<br>        completableFuture1.get();<br><br>        <span class="hljs-comment">//异步调用，有返回值</span><br>        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; completableFuture2&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;<br>        &#125;);<br>        completableFuture2.whenComplete((t,u)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;t=&quot;</span>+t);<br>            System.out.println(<span class="hljs-string">&quot;u=&quot;</span>+u);<br>        &#125;).get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目构建工具Gradle</title>
    <link href="/2021/09/27/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/"/>
    <url>/2021/09/27/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/</url>
    
    <content type="html"><![CDATA[<h3 id="技术分享——项目构建工具Gradle"><a href="#技术分享——项目构建工具Gradle" class="headerlink" title="技术分享——项目构建工具Gradle"></a>技术分享——项目构建工具Gradle</h3><h3 id="Gradle是什么？"><a href="#Gradle是什么？" class="headerlink" title="Gradle是什么？"></a><strong>Gradle是什么？</strong></h3><p>Java世界主要的三大构建工具：Ant、Maven和Gradle。</p><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具，使用基于Groovy的特定领域语言（DSL）来声明项目设置，抛弃了基于XML的各种繁琐配置。</p><p>Google选择gradle作为android项目的构建工具，因为gradle非常灵活，除了java外，gradle还支持C++、Groovy、Kotlin、Scala和Swift，并且计划未来支持更多语言。</p><p>目前有的spring项目已经从maven切换到gradle，而且安卓项目只支持gradle构建。</p><p>例如Spring团队在Spring Boot 2.3.0.M1版本中使用了Gradle来构建项目，这是Spring Boot使用Gradle而非Maven构建的第一个版本。（Spring Framework自2012年的3.2.0版本起就使用Gradle构建）。</p><p><strong>为什么从maven迁移到gradle?</strong></p><ul><li>使用gradle和maven构建apache commons lang3比较</li></ul><p><img src="/2021/09/27/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/image-20210914201007764.png" alt="gradle和maven构建速度比较"></p><p>Gradle运行测试的速度提高了1.7倍，而在使用构建缓存时，构建速度提高了30倍</p><ul><li>使用gradle和maven构建小项目（10个模块，每个模块50个源文件和50个测试文件）的比较</li></ul><p><img src="/2021/09/27/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/image-20210914201142468.png" alt="gradle和maven构建速度比较"></p><p>对于clean构建，Gradle 的速度要快 2-3 倍，增量构建的速度要快 7 倍，当 Gradle 任务被缓存时，速度会快 14 倍。</p><ul><li>使用gradle和maven构建中等项目（100个模块，每个模块100个源文件和100个测试文件）的比较</li></ul><p><img src="/2021/09/27/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/image-20210914201524782.png" alt="gradle和maven构建速度比较"></p><p>对于clean构建，Gradle 的速度要快 4-5 倍，增量构建的速度要快 40 倍，当 Gradle 任务被缓存时，速度会快 13 倍。</p><ul><li>使用gradle和maven构建大项目（500个模块，每个模块100个源文件和100个测试文件）的比较：</li></ul><p><img src="/2021/09/27/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Gradle/image-20210914201639981.png" alt="gradle和maven构建速度比较"></p><p>对于clean构建，Gradle 的速度要快 3-10 倍，增量构建的速度要快 85 倍，当 Gradle 任务被缓存时，速度会快 13 倍。</p><p>Spring团队考虑由Maven切换到Gradle的主要原因就是为了减少构建项目所需的时间。在开发和测试的过程中，由于减少了等待构建完成所花费的时间，花费在修复错误和实现新功能上所花费的时间也就变多了。</p><p>经过Spring团队的统计，使用Gradle构建Spring Boot项目的平均成功构建时间为9分22秒，而在CI和开发人员自己的机器上，基于Maven的完整构建需要一个小时或更长的时间。</p><p><a href="https://spring.io/blog/2020/06/08/migrating-spring-boot-s-build-to-gradle">Migrating Spring Boot’s Build to Gradle</a></p><h3 id="为什么gradle速度更快-什么是增量构建和构建缓存？"><a href="#为什么gradle速度更快-什么是增量构建和构建缓存？" class="headerlink" title="为什么gradle速度更快?什么是增量构建和构建缓存？"></a>为什么gradle速度更快?什么是增量构建和构建缓存？</h3><p>gradle引入增量构建的概念，使用构建缓存、守护进程方式提高构建速度，结果就是gradle的构建速度要远超maven，平均构建速度比maven快好几倍，而且项目越大差距越明显。</p><ul><li><p>引入增量构建</p><p>Gradle通过跟踪任务的输入和输出，只运行必要的内容，并在可能的情况下只处理有变化的文件，从而避免多余的工作。</p><p>向Gradle提供关于任务的输入和输出的信息。可以将一个任务配置为只有输出。在执行任务之前，Gradle会检查输出，如果输出没有变化，就会跳过任务的执行。在实际构建中，一个任务通常也有输入，包括源文件、资源和属性。Gradle在执行任务之前会检查输入和输出是否有变化。</p><p><strong>在一个任务第一次执行之前，Gradle会对输入文件进行快照。这个快照包含了一组输入文件和每个文件的内容的哈希值。然后，Gradle执行该任务。如果任务成功完成，Gradle 会获取输出的快照。这个快照包含了输出文件的集合和每个文件内容的哈希值。Gradle将这两个快照持久化，以便在下次执行任务时使用。</strong></p><p><strong>Gradle比较的是输入和输出的校验和，而不是只比较文件的时间戳。即使任务每次运行都会覆盖所有的输出文件，但内容并没有改变，任务也不需要再次运行。</strong></p></li><li><p>引入构建缓存</p><p>Gradle 通过对任务的所有输入进行哈希计算来构建缓存密钥并将其用来唯一地识别一个任务的输出。启用构建缓存功能后，如果Gradle能在构建缓存中找到该密钥，Gradle将跳过此任务的执行，直接将缓存中的输出复制到构建目录中。</p><p><strong>缓存可以跨机器共享，如果使用的是持续集成服务器，可以配置Gradle将任务输出推送到共享构建缓存中。当开发者构建时，已经在CI上构建的任务输出被复制到开发者的机器上，可以极大地加快本地构建的速度。</strong></p></li><li><p>守护进程</p><p>守护进程是一个一直运行的进程，可以避免每次JVM启动的开销，还可以在内存中缓存项目结构、文件、task等信息，从而提升运行速度。</p><p>守护进程是默认启用的，可以使用命令<code>gradle --stop</code>来停止守护进程。守护进程会监控内存使用情况，并在系统内存不足时停止空闲状态的守护进程。若守护进程在3个小时或更短时间内不活动，它就会自动终止自己。</p></li></ul><h3 id="gradle项目目录结构"><a href="#gradle项目目录结构" class="headerlink" title="gradle项目目录结构"></a><strong>gradle项目目录结构</strong></h3><p><a href="https://docs.gradle.org/current/userguide/directory_layout.html#dir:project_root">The Directories and Files Gradle Uses</a></p><p>|————.gradle (1)</p><p>|————gradle</p><p>||————wrapper (2)</p><p>|————gradlew (3)</p><p>|————gradlew.bat （3）</p><p>|————settings.gradle (4)</p><p>|————subproject-one (5)</p><p>||————build.gradle (6)</p><p>|————build.gradle (7)</p><p>（1）由gradle生成的项目缓存（最多每24小时检查一次，7天未使用则删除）</p><p>（2）gradle wrapper 的jar文件和配置</p><p>（3）shell脚本和windows批处理脚本，使用gradle-wapper来执行构建</p><p>（4）项目的设置文件，定义子项目列表</p><p>（5）子项目</p><p>（6）子项目配置文件</p><p>（7）根项目配置文件</p><p>gradle-wapper是一个脚本，用来调用一个已声明版本的gradle。使用wapper可以快速启动和运行gradle项目，无需遵循人工流程。</p><p>gradle-wrapper.properties</p><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td>distributionBase</td><td>下载的Gradle压缩包解压后存储的主目录</td></tr><tr><td>distributionPath</td><td>相对于distributionBase的解压后的Gradle压缩包的路径</td></tr><tr><td>zipStoreBase</td><td>同distributionBase，只不过是存放zip压缩包的</td></tr><tr><td>zipStorePath</td><td>同distributionPath，只不过是存放zip压缩包的</td></tr><tr><td>distributionUrl</td><td>Gradle发行版压缩包的下载地址</td></tr></tbody></table><p>&#x2F;&#x2F;<strong>build.gradle</strong>文件构建脚本块</p><p><a href="https://docs.gradle.org/current/dsl/">Gradle DSL Version 7.2</a></p><p>java插件</p><p><a href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_project_layout">The Java Plugin (gradle.org)</a></p><h3 id="Gradle与Maven的异同点"><a href="#Gradle与Maven的异同点" class="headerlink" title="Gradle与Maven的异同点"></a><strong>Gradle与Maven的异同点</strong></h3><p>Maven:</p><ul><li>三个内置的构建生命周期(lifecycle)：clean, default, site。<a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">Maven - 构建生命周期简介 (apache.org)</a></li><li>最小的运行单元是目标(goal)</li><li>插件可以把自己的目标绑定在生命周期的某个阶段(phase)上</li></ul><p>Gradle:</p><ul><li>构建时有三个不同的阶段：初始化、配置和执行。<a href="https://www.pianshen.com/article/536459444/">详解Gradle项目构建的生命周期</a></li><li>最小的运行单元是任务(task)，任务之间相互依赖。</li><li>可以动态创建任务。</li></ul><p>依赖冲突：</p><p>gradle：默认选择版本更高的依赖。</p><p>maven：默认路径最近原则。</p><p>Gradle与Maven的项目目录结构基本相同:</p><ul><li>生产代码存放在src&#x2F;main&#x2F;java</li><li>测试代码存放在src&#x2F;test&#x2F;java</li></ul><p>不同之处：<br>Maven项目依赖由pom.xml定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Gradle项目依赖由build.gradle定义</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-string">&#x27;log4j:log4j:1.2.12&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>灵活：gradle项目的配置文件是一个groovy脚本文件，在其中可以以编程方式自定义一些构建任务，因为使用了编程方式，这就带给了我们极大的灵活性和便捷性。例如，在打jar包的时候输出jar文件的大小，在gradle中仅需在构建脚本中编写几行代码即可，但在maven中则需要编写maven插件来实现，复杂程度不在一个水平。</p><h3 id="gradle和maven优缺点总结"><a href="#gradle和maven优缺点总结" class="headerlink" title="gradle和maven优缺点总结"></a><strong>gradle和maven优缺点总结</strong></h3><p>gradle优点：</p><ol><li>使用构建缓存、守护进程等方式提高构建速度，项目构建速度快。</li><li>采用代码逻辑的方式进行构建，使其非常灵活。</li><li>配置代码减少，大约为maven的pom配置的四分之一。</li></ol><p>缺点：</p><ol><li>由于gradle配置过于灵活，导致它的构建比基于maven构建更难以维护和理解。</li><li>更新速度很快，语法变化较大。</li></ol><p>缓存带来的问题：</p><p>gradle内部存在缓存机制，当文件输入和输出都没改变的情况下，认为这就是没变的代码，直接进行输出。但当你改变的依赖包版本，它有时并没更新，这也是缓存机制的问题。</p><p>maven缺点:</p><ol><li>配置文件是xml格式的，如果项目依赖的包比较多，xml文件会变得非常长。</li><li>xml文件不太灵活，如果需要在构建过程中添加自定义逻辑会非常麻烦。</li><li>虽然maven稳定但对新版java支持不足，需要更新内置的maven插件。</li><li>使用maven构建的项目都会经过几个生命流程，内部没有缓存机制，随着项目越来越大重新构建所花费的时间也就越长。</li></ol><p>maven优点：</p><ol><li>maven项目比较容易看懂，上手简单。</li><li>maven非常稳定</li></ol><h3 id="从maven迁移到gradle"><a href="#从maven迁移到gradle" class="headerlink" title="从maven迁移到gradle"></a>从maven迁移到gradle</h3><p><a href="https://docs.gradle.org/current/userguide/migrating_from_maven.html">从阿帕奇马文迁移构建 (gradle.org)</a></p><p>使用<code>gradle init</code>命令，此命令通常用于新项目的初始化，但也可以使用此命令自动将现有的Maven构建转换为Gradle，包括解析现有的pom并生成相应的gradle构建脚本，如果是多项目，还会创建一个设置脚本。</p><p>不一定会有转换问题，但是还是需要做一些手动工作</p><h3 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h3><p>总结：</p><p>Ant：Ant的功能虽然强大，但过于灵活，规范性不足，对目录结构及build.xml没有默认约定，且没有统一的项目依赖管理。</p><p>Maven：Maven解决了规范性的问题，也顺带解决了依赖项统一管理的问题，但由于规范性太强，灵活性不足，pom.xml采用Xml结构，项目一大，Xml就显得冗长。</p><p>Gradle：综合了Ant和Maven的优点，吸收了Ant中task的思想，然后把Maven的目录规范以及仓库思想也融合了进来，但允许用户自由的修改默认的规范（如，可随意修改源码目录），配置文件则采用Groovy语言来书写，Groovy是一门可编程语言，配置文件本身就可以视为一份源代码，并最终交由Gradle来处理执行。</p><p>展望：</p><p>虽然目前大家的电脑性能比较强劲，在做项目构建的时候对构建性能的优势不是那么迫切，但是对大型项目来说，一次构建可能会需要很长时间，尤其是对于自动化构建和CI环境来说，当然是构建地越快越好。从Spring 和 Spring Boot等项目从Maven迁移到Gradle来看，Gradle有可能成为未来主流的项目构建工具。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目构建工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于token的鉴权机制</title>
    <link href="/2021/08/25/%E5%9F%BA%E4%BA%8Etoken%E7%9A%84%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/08/25/%E5%9F%BA%E4%BA%8Etoken%E7%9A%84%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h1><p>流程：</p><ol><li><p>用户使用用户名密码来请求服务器</p></li><li><p>服务器进行验证用户的信息</p></li><li><p>服务器通过验证并发送给用户一个token</p></li><li><p>客户端存储token，并在每次请求时在请求头附上这个token</p></li><li><p>服务端验证token，并返回数据</p></li></ol><p>这个token必须要在每次请求时传递给服务端，应该保存在请求头里，另外，服务端要支持CORS(跨来源资源共享)策略。</p><h1 id="JWT-Json-Web-Token"><a href="#JWT-Json-Web-Token" class="headerlink" title="JWT(Json Web Token)"></a>JWT(Json Web Token)</h1><p>JWT由三段信息构成，将这三段信息文本用<code>.</code>链接就构成了JWT字符串，如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span>.eyJzdWIiOiIxMj<span class="hljs-name">M0</span><span class="hljs-symbol">NTY3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>Ikpva<span class="hljs-name">G4</span>gR<span class="hljs-name">G9</span>lIiwiYWRtaW<span class="hljs-number">4</span>iO<span class="hljs-symbol">nRydWV9</span>.TJVA<span class="hljs-number">95</span><span class="hljs-keyword">Or</span><span class="hljs-name">M7</span>E<span class="hljs-number">2</span>cBab<span class="hljs-number">30</span>RMHrHDcEfxjoYZgeFO<span class="hljs-symbol">NFh7</span>HgQ<br></code></pre></td></tr></table></figure><h2 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h2><p>第一部分称为头部（header），第二部分称为载荷（payload），第三部分称为签证（signature）</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>头部承载两部分信息：</p><ul><li><p>声明类型</p></li><li><p>声明加密的算法，通常直接使用HMAC SHA256（第三部分加密使用）</p></li></ul><p>完整头部就像如下JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  &#x27;typ&#x27;<span class="hljs-punctuation">:</span> &#x27;JWT&#x27;<span class="hljs-punctuation">,</span><br>  &#x27;alg&#x27;<span class="hljs-punctuation">:</span> &#x27;HS256&#x27;<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密为对称加密），构成第一部分</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJ<span class="hljs-number">0</span>eXAiOiJKV<span class="hljs-number">1</span>QiLCJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiJ9</span><br></code></pre></td></tr></table></figure><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>载荷是存放有效信息的地方，包含三个部分</p><ul><li>标准中注册的声明</li><li>公共声明</li><li>私有声明</li></ul><p>标准声明（建议但不强制使用）</p><ul><li>iss：jwt签发者</li><li>sub：jwt所面向的用户</li><li>aud：接收jwt的一方</li><li>exp：jwt的过期时间，这个过期时间必须大于签发时间</li><li>nbf：定义在什么时间之前，该jwt都是不可用的</li><li>iat：jwt的签发时间</li><li>jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击</li></ul><p>公共声明（Public claims）：</p><p>公共声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。</p><p>私有声明（<strong>Private claims</strong>）：</p><p>私有的声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的。</p><p>定义一个payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;admin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后对其进行base64加密，得到jwt的第二部分</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJzdWIiOiIxMj<span class="hljs-name">M0</span><span class="hljs-symbol">NTY3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>Ikpva<span class="hljs-name">G4</span>gR<span class="hljs-name">G9</span>lIiwiYWRtaW<span class="hljs-number">4</span>iO<span class="hljs-symbol">nRydWV9</span><br></code></pre></td></tr></table></figure><h3 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h3><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header（base64加密后的）</li><li>payload（base64加密后的）</li><li>secret</li></ul><p>将base64加密后的header和base64加密后的payload使用<code>.</code>连接组成字符串，然后通过header中声明的加密方式进行加盐<code>secret</code>组合加密，就构成了jwt的第三部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> encodedString = <span class="hljs-title function_">base64UrlEncode</span>(header) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-title function_">base64UrlEncode</span>(payload);<br><br><span class="hljs-keyword">var</span> signature = <span class="hljs-title class_">HMACSHA256</span>(encodedString, <span class="hljs-string">&#x27;secret&#x27;</span>); <span class="hljs-comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></code></pre></td></tr></table></figure><p>将这三部分用<code>.</code>连接成一个完整的字符串就构成了最终的jwt：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJ<span class="hljs-number">0</span>eXAiOiJKV<span class="hljs-number">1</span>QiLCJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiJ9</span>.eyJzdWIiOiIxMj<span class="hljs-name">M0</span><span class="hljs-symbol">NTY3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>Ikpva<span class="hljs-name">G4</span>gR<span class="hljs-name">G9</span>lIiwiYWRtaW<span class="hljs-number">4</span>iO<span class="hljs-symbol">nRydWV9</span>.TJVA<span class="hljs-number">95</span><span class="hljs-keyword">Or</span><span class="hljs-name">M7</span>E<span class="hljs-number">2</span>cBab<span class="hljs-number">30</span>RMHrHDcEfxjoYZgeFO<span class="hljs-symbol">NFh7</span>HgQ<br></code></pre></td></tr></table></figure><p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>一般在请求头中加入<code>Authorization</code>，并加上<code>Bearer</code>标注：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;api/user/1&#x27;</span>, &#123;<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer &#x27;</span> + token<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>流程如下图：</p><p><img src="/2021/08/25/%E5%9F%BA%E4%BA%8Etoken%E7%9A%84%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/1821058-2e28fe6c997a60c9.png" alt="鉴权流程"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>因为json的通用性，所以JWT是可以进行跨语言支持的，像Java，JavaScript，Nodejs，Php等很多语言都可以使用。</li><li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li><li>便于传输，jwt的构成非常简单，字节占用很小，所以非常便于传输。</li><li>它不需要在服务端保存会话信息，所以它易于应用的扩展。</li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><ul><li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</li><li>需要保护好secret私钥，该私钥非常重要。</li><li>如果可以，使用https协议。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程基础</title>
    <link href="/2021/08/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/08/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><strong>JAVA多线程基础</strong></p><h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><p>三种创建方式</p><p>1.继承Thread类（重点）</p><p>2.实现Runnable接口（重点）</p><p>3.实现Callable接口（了解）</p><blockquote><p>继承Thread类</p></blockquote><p>自定义线程类继承Thread类</p><p>重写run()方法，编写线程执行体</p><p>创建线程对象，调用start()方法启动线程（<font color=#FF0000>不是调用run()方法</font>）</p><p><font color=#FF0000>不建议使用：避免OOP单继承局限性</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程方式一：继承Thread类，重写run()方法，调用start开启线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//run方法线程体</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码---&quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//main线程，主线程</span><br><br>        <span class="hljs-comment">//创建一个线程对象</span><br>        <span class="hljs-type">TestThread1</span> <span class="hljs-variable">testThread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestThread1</span>();<br>        <span class="hljs-comment">//调用start方法开启线程</span><br>        testThread1.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程--&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;      <br></code></pre></td></tr></table></figure><blockquote><p>实现Runnable接口</p></blockquote><p>定义MyRunnable类实现Runnable接口</p><p>实现Run()方法，编写线程执行体</p><p>创建线程对象，调用start()方法启动线程</p><p><font color=#FF0000>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程方式2：实现runnable接口，重写run()方法，执行线程需要丢入runnable接口实现类，调用start方法。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码---&quot;</span>+i);<br>        &#125;<br>    &#125;                     <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建runnable接口的实现类对象</span><br>        <span class="hljs-type">TestThread2</span> <span class="hljs-variable">testThread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestThread2</span>();<br>        <span class="hljs-comment">//创建线程对象，通过线程对象来开启我们的线程，代理</span><br><span class="hljs-comment">//        Thread thread = new Thread(testThread2);</span><br><span class="hljs-comment">//        thread.start();</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testThread2).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程--&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现Callable接口</p></blockquote><p>创建一个实现Callable的实现类。<br>实现call()方法，将此线程需要执行的操作声明在call()中。<br>创建Callable接口实现类的对象。<br>将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象。<br>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CallableThread</span> <span class="hljs-variable">callableThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableThread</span>();<br><br>        <span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(callableThread);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br><br>        t1.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//get()方法的返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(sum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(i);<br>                sum += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><p>函数式接口的定义：</p><p>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</p><p>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p><h1 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setPriority(int newPriority)</td><td>更改线程的优先级</td></tr><tr><td>static void sleep(long millis)</td><td>在指定的毫秒数内让当前正在执行的线程休眠</td></tr><tr><td>void join()</td><td>等待该线程终止（等待调用此方法的线程执行完毕）</td></tr><tr><td>static void yield()</td><td>暂停当前正在执行的线程对象，并执行其他线程</td></tr><tr><td>void interrupt()</td><td>中断线程</td></tr><tr><td>boolean isAlive()</td><td>测试线程是否处于活动状态</td></tr></tbody></table><h1 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试stop</span><br><span class="hljs-comment">//1.建议线程正常停止---&gt;利用次数，不建议死循环</span><br><span class="hljs-comment">//2.建议使用标志位---&gt;设置一个标志位</span><br><span class="hljs-comment">//3.不要用stop或destory等过时或者JDK不建议使用的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-comment">//设置一个标志位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            System.out.println(<span class="hljs-string">&quot;run...Thread&quot;</span> + i++);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.flag = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TestStop</span> <span class="hljs-variable">testStop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestStop</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testStop).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main&quot;</span> + i);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">900</span>)&#123;<br>                testStop.stop();<br>                System.out.println(<span class="hljs-string">&quot;线程停止了&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h1><ul><li>sleep(时间)指定当前线程阻塞的毫秒数</li><li>sleep存在异常InterruptedException</li><li>sleep时间达到后线程进入就绪状态</li><li>sleep可以模拟网络延时，倒计时等。</li><li>每一个对象都有一个锁，sleep不会释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//10秒倒计时</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSleep</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            tenDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tenDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(num--);<br>            <span class="hljs-keyword">if</span> (num&lt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h1><ul><li>礼让线程，让当前正在执行的线程暂停，但不阻塞</li><li>将线程从运行状态转为就绪状态</li><li>让CPU重新调度，礼让不一定成功，看CPU调度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestYield</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyYield</span> <span class="hljs-variable">myYield</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyYield</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myYield, <span class="hljs-string">&quot;a&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myYield, <span class="hljs-string">&quot;b&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyYield</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程开始执行&quot;</span>);<br>        Thread.<span class="hljs-keyword">yield</span>();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程停止执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h1><p>&#x2F;&#x2F;等待线程执行完毕</p><p>自己的理解：等待调用此方法的线程执行完毕。</p><h1 id="观测线程状态"><a href="#观测线程状态" class="headerlink" title="观测线程状态"></a>观测线程状态</h1><p>Thread.State</p><ul><li><p><strong>NEW</strong></p><p>尚未启动的线程处于此状态。</p></li><li><p><strong>RUNNABLE</strong></p><p>在Java虚拟机中执行的线程处与此状态。</p></li><li><p><strong>BLOCKED</strong></p><p>被阻塞等待监视器锁定的线程处于此状态。</p></li><li><p><strong>WAITING</strong></p><p>正在等待另一个线程执行特定动作的线程处于此状态。</p></li><li><p><strong>TIMED_WAITING</strong></p><p>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</p></li><li><p><strong>TERMINATED</strong></p><p>已退出的线程处于此状态。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;//////&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">//观察状态</span><br>        Thread.<span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> thread.getState();<br>        System.out.println(state);<span class="hljs-comment">//NEW</span><br><br>        <span class="hljs-comment">//观察启动后</span><br>        thread.start();<br>        state =  thread.getState();<br>        System.out.println(state);<span class="hljs-comment">//Run</span><br><br>        <span class="hljs-keyword">while</span>(state != Thread.State.TERMINATED)&#123;<span class="hljs-comment">//只要线程不终止，就一直输出状态</span><br>            Thread.sleep(<span class="hljs-number">100</span>);<br>            state = thread.getState();<br>            System.out.println(state);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul><li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</li><li>线程的优先级用数字表示，范围从1~10<ul><li>Thread.MIN_PRIORITY&#x3D;1</li><li>Thread.MAX_PRIORITY&#x3D;10</li><li>Thread.NORM_PRIORITY&#x3D;5</li></ul></li><li>使用以下方式改变或获取优先级<ul><li>getPriority()，setPriority(int xxx)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试线程的优先级</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPriority</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//主线程默认优先级</span><br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());<br><br>        <span class="hljs-type">MyPriority</span> <span class="hljs-variable">myPriority</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPriority</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myPriority);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myPriority);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myPriority);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myPriority);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myPriority);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myPriority);<br><br>        <span class="hljs-comment">//先设置优先级，再启动</span><br>        t1.start();<br><br>        t2.setPriority(<span class="hljs-number">1</span>);<br>        t2.start();<br><br>        t3.setPriority(<span class="hljs-number">4</span>);<br>        t3.start();<br><br>        t4.setPriority(Thread.MAX_PRIORITY);<br>        t4.start();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        t5.setPriority(-1);</span><br><span class="hljs-comment">        t5.start();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        t6.setPriority(11);</span><br><span class="hljs-comment">        t6.start();*/</span><br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPriority</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h1><ul><li>线程分为<font color="FF0000">用户线程</font>和<font color="FF0000">守护线程</font></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>如后台记录操作日志，监控内存，垃圾回收等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试守护线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDaemon</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">God</span> <span class="hljs-variable">god</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">God</span>();<br>        <span class="hljs-type">You</span> <span class="hljs-variable">you</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">You</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(god);<br>        thread.setDaemon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//默认是false表示是用户线程，正常的线程都是用户线程</span><br><br>        thread.start();<span class="hljs-comment">//守护线程启动</span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(you).start();<span class="hljs-comment">//用户线程启动</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">God</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;上帝保佑着你&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">36500</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;你一生都开心地活着&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;====goodbye!world!====&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>多个线程操作同一个资源</p><p>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制<code>synchronized</code>，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。存在以下问题：</p><ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li><li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。</li></ul><blockquote><p>同步方法</p></blockquote><ul><li>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是<code>synchronized</code>方法和<code>synchronized</code>块</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">//同步方法</span><br><span class="hljs-keyword">public</span> synchronized void <span class="hljs-keyword">method</span><span class="hljs-params">(int args)</span><span class="hljs-comment">&#123;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。（缺陷：若将一个大的方法申明为synchronized将会影响效率）</li></ul><blockquote><p>同步块</p></blockquote><ul><li>同步块：synchronized(Obj){}</li><li>Obj称之为<strong>同步监视器</strong><ul><li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class</li></ul></li><li>同步监视器的执行过程<ol><li>第一个线程访问，锁定同步监视器，执行其中的代码。</li><li>第二个线程访问，发现同步监视器被锁定，无法访问。</li><li>第一个线程访问完毕，解锁同步监视器。</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li></ol></li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源的情形。某个同步块同时拥有“两个以上对象的锁”时，就可能发生“死锁”的问题。</p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>只要破环其中任意一个或多个条件就可以避免死锁的发生。</p><h1 id="Lock（锁）"><a href="#Lock（锁）" class="headerlink" title="Lock（锁）"></a>Lock（锁）</h1><ul><li>从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li><li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li><li>ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock（可重入锁），可以显式加锁、释放锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReenTrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//保证线程安全的代码</span><br>        &#125;<br>        <span class="hljs-keyword">finally</span>&#123;<br>            lock.unlock();<br>            <span class="hljs-comment">//如果同步代码有异常，要将unlock()写入finally语句块</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>synchorized与Lock的对比</p></blockquote><ul><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放。</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li><li>优先使用顺序：<ul><li>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方法体之外）</li></ul></li></ul><h1 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h1><blockquote><p>线程通信</p></blockquote><p>&#96;Java提供了几个方法解决线程之间的通信问题</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁。</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数。</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程。</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度。</td></tr></tbody></table><p><font color="FF0000">注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常<code>IllegalMonitorStateException</code></font></p><p><strong>解决方式一：</strong></p><p>并发协作模型“生产者&#x2F;消费者模式”–&gt;管程法</p><ul><li>生产者：负责生产数据的模块（可能是方法，对象，线程，进程）；</li><li>消费者：负责处理数据的模块（可能是方法，对象，线程，进程）；</li><li>缓冲区：消费者不能直接使用生产者的数据，他们之间有“缓冲区”</li></ul><p>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</p><p><strong>解决方式二：</strong></p><p>并发协作模型“生产者&#x2F;消费者模式”—&gt;信号灯法</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ul><li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li><li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</li><li>好处：<ul><li>提高相应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li></ul><blockquote><p>使用线程池</p></blockquote><ul><li>JDK 5.0起提供了线程池相关API：ExecutorService和Executors</li><li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<ul><li>void execute(Runnable command)：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</li><li>&lt;T&gt;Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般又来执行Callable</li><li>void shutdown()：关闭连接池</li></ul></li><li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试线程池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建服务，创建线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>        service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br>        service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br>        service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br>        service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>());<br><br>        <span class="hljs-comment">//2.关闭连接</span><br>        service.shutdown();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JUC并发编程（链接）"><a href="#JUC并发编程（链接）" class="headerlink" title="JUC并发编程（链接）"></a><a href="E:\study\markdown笔记\JUC并发编程">JUC并发编程（链接）</a></h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/08/09/Redis/"/>
    <url>/2021/08/09/Redis/</url>
    
    <content type="html"><![CDATA[<p><strong>Redis</strong>（Remote Dictionary Server）</p><h2 id="Linux-centos-7-使用"><a href="#Linux-centos-7-使用" class="headerlink" title="Linux(centos 7)使用"></a>Linux(centos 7)使用</h2><p><code>yum install -y gcc tcl</code></p><p>解压redis安装包，并进入解压目录</p><p>执行<code>make &amp;&amp; make install</code></p><p>默认的安装路径是在<code>usr/local/bin</code>目录下</p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。</p><p>其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务器启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><p>直接使用<code>redis-server</code>可进行前台启动</p><p>如果要让Redis以后台方式启动，则必须修改redis的配置文件，即修改解压目录下的redis.conf。</p><p>备份：<code>cp redis.conf redis.conf.bak</code></p><p>修改配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs conf">#监听的地址，默认是127.0.0.1，会导致只能在本地访问，修改为0.0.0.0则可以在任意ip访问，生产环境不要设置为0.0.0.0<br>bind 0.0.0.0<br>#守护进程，修改为yes后即可后台运行<br>daemonize yes<br>#密码，设置后访问redis必须输入密码<br>requirepass 17221273<br></code></pre></td></tr></table></figure><p>其他配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs conf">#监听的端口<br>port 6379<br>#工作目录，默认当前目录（启动redis时所在目录）（建议在解压目录内启动）<br>dir .<br>#数据库数量，设置为1，代表只能使用1个库，默认16个库，编号0-15<br>database 1<br>#设置redis能够使用的最大内存<br>maxmemory 512mb<br>#日志文件，默认为空，不记录日志，可以指定日志文件名<br>logfile &quot;redis.log&quot;<br></code></pre></td></tr></table></figure><p>启动redis：</p><p>进入redis安装目录，启动：<code>redis-server redis.conf</code></p><p>开放6379端口号：<code>firewall-cmd --zone=public --add-port=6379/tcp --permanent</code></p><p>重新加载：<code>firewall-cmd --reload</code></p><p>查看开放的端口号：<code>firewall-cmd --zone=public --list-ports</code></p><p>开机自启需要单独编写redis.service（网上查）</p><h2 id="Windows下使用"><a href="#Windows下使用" class="headerlink" title="Windows下使用"></a>Windows下使用</h2><ul><li>redis-server.exe启动服务，默认端口号6379</li><li>redis-cli.exe打开客户端</li><li>ping命令测试是否连接，连接正常返回PONG</li></ul><h2 id="Redis的基本知识"><a href="#Redis的基本知识" class="headerlink" title="Redis的基本知识"></a>Redis的基本知识</h2><p>redis默认有16个数据库</p><p><img src="/2021/08/09/Redis/image-20210709120427992.png" alt="数据库数量配置"></p><p>默认使用第0个数据库</p><p>可以使用select进行切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; ping<br>PONG<br>127.0.0.1:6379&gt; <span class="hljs-keyword">select</span> 1<br>OK<br>127.0.0.1:6379[1]&gt; <span class="hljs-keyword">select</span> 0<br>OK<br>127.0.0.1:6379&gt; DBSIZE<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure><p>查询当前数据库所有的key <code>keys *</code></p><p>清除当前数据库<code>flushdb </code></p><p>清除全部数据库的内容<code>FLUSHALL</code></p><blockquote><p>Redis是单线程的</p></blockquote><p>Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是内存和网络带宽。</p><p>使用<code>help @generic</code>查看常用命令用法</p><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用命令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key，<font style="color:red">不建议在生产环境设备上使用。</font></li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command]可以查看一个命令的具体用法，例如：<code>help keys</code></p><h2 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类型，也就是字符串类型，是redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串格式不同，又分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>msg</td><td>hello world</td></tr><tr><td>num</td><td>10</td></tr><tr><td>score</td><td>92.5</td></tr></tbody></table><h4 id="String类型的常见命令"><a href="#String类型的常见命令" class="headerlink" title="String类型的常见命令"></a>String类型的常见命令</h4><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的键值对</li><li>MSET：批量添加多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY：让一个整形的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYALOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行：</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>project:user:1</td><td>{name:”Jack”, age:21}</td></tr><tr><td>project:user:2</td><td>{name:”Rose”, age:18}</td></tr></tbody></table><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><table><thead><tr><th>key</th><th>value</th><th>-</th></tr></thead><tbody><tr><td></td><td>field</td><td>value</td></tr><tr><td>project:user:1</td><td>name</td><td>Jack</td></tr><tr><td></td><td>age</td><td>21</td></tr><tr><td>project:user:2</td><td>name</td><td>Rose</td></tr><tr><td></td><td>age</td><td>18</td></tr></tbody></table><h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令"></a>Hash类型的常见命令</h4><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值（针对一个key批量添加多个field）（redis4.0以后被废弃）</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中所有的value</li><li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis中的LIst类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除块</li><li>查询速度一般</li></ul><h4 id="List常见命令"><a href="#List常见命令" class="headerlink" title="List常见命令"></a>List常见命令</h4><ul><li>LPUSH key element …：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element …：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因此也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a>Set类型的常见命令</h4><ul><li>SADD key member .. ：向set中添加一个或多个元素</li><li>SREM key member …：移除set中的指定元素</li><li>SCARD key：返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 …：求key1与key2的交集</li><li>SDIFF key1 key2 …：求key1与key2的差集（在key1中但不在key2中）</li><li>SUNION key1 key2 …：求key1和key2的并集</li></ul><h3 id="SortedSet（有序集合）"><a href="#SortedSet（有序集合）" class="headerlink" title="SortedSet（有序集合）"></a>SortedSet（有序集合）</h3><p>redis的SortedSet是一个可排序的set集合，与java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加hash表。</p><p>SortedSet具备下列特征：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度块</li></ul><p>因为SortedSet的可排序性，经常被用来实现排行榜这样的功能。</p><h4 id="SortedSet的常见命令"><a href="#SortedSet的常见命令" class="headerlink" title="SortedSet的常见命令"></a>SortedSet的常见命令</h4><ul><li>ZADD key score member：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member：获取sorted set中指定元素的score值</li><li>ZRANK key member：获取sorted set中的指定元素的排名</li><li>ZCARD key：获取sorted set中元素的个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><h2 id="key的层级格式"><a href="#key的层级格式" class="headerlink" title="key的层级格式"></a>key的层级格式</h2><p>redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：<code>项目名:业务名:类型:id</code></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><h4 id="GEO的常见命令"><a href="#GEO的常见命令" class="headerlink" title="GEO的常见命令"></a>GEO的常见命令</h4><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.2以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。6.2新功能</li></ul><p>6个命令</p><blockquote><p>geoadd</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加地理位置</span><br><span class="hljs-comment"># 参数 key 值（经度、纬度、名称）</span><br>127.0.0.1:6379&gt; GEOADD china:city 116.40 39.90 beijing<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian<br>(<span class="hljs-built_in">integer</span>) 2<br></code></pre></td></tr></table></figure><blockquote><p>geopos</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geopos china:city beijing<span class="hljs-comment">#获取指定城市的经度和纬度</span><br>1) 1) <span class="hljs-string">&quot;116.39999896287918&quot;</span><br>   2) <span class="hljs-string">&quot;39.900000091670925&quot;</span><br>127.0.0.1:6379&gt; geopos china:city beijing chongqing<br>1) 1) <span class="hljs-string">&quot;116.39999896287918&quot;</span><br>   2) <span class="hljs-string">&quot;39.900000091670925&quot;</span><br>2) 1) <span class="hljs-string">&quot;106.49999767541885&quot;</span><br>   2) <span class="hljs-string">&quot;29.529999579006592&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>geodist（返回两个给定位置之间的距离）</p></blockquote><p>单位：</p><ul><li>m表示米</li><li>km表示单位为千米</li><li>mi表示单位为英里</li><li>ft表示单位为英尺</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; geodist china:city beijing shanghai<span class="hljs-comment">#查看北京到上海的距离</span><br><span class="hljs-string">&quot;1067378.7564&quot;</span><br>127.0.0.1:6379&gt; geodist china:city beijing shanghai km<br><span class="hljs-string">&quot;1067.3788&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>georadius 以给定的经纬度为中心，找出某一半径内的元素</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km<span class="hljs-comment"># 以110，30这个经纬度为中心，寻找方圆1000km内的城市</span><br>1) <span class="hljs-string">&quot;chongqing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>3) <span class="hljs-string">&quot;hangzhou&quot;</span><br>127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km<br>1) <span class="hljs-string">&quot;chongqing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist<span class="hljs-comment"># 显示到中间距离的位置</span><br>1) 1) <span class="hljs-string">&quot;chongqing&quot;</span><br>   2) <span class="hljs-string">&quot;341.9374&quot;</span><br>2) 1) <span class="hljs-string">&quot;xian&quot;</span><br>   2) <span class="hljs-string">&quot;483.8340&quot;</span><br>127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord<span class="hljs-comment"># 显示他人的定位信息</span><br>1) 1) <span class="hljs-string">&quot;chongqing&quot;</span><br>   2) 1) <span class="hljs-string">&quot;106.49999767541885&quot;</span><br>      2) <span class="hljs-string">&quot;29.529999579006592&quot;</span><br>2) 1) <span class="hljs-string">&quot;xian&quot;</span><br>   2) 1) <span class="hljs-string">&quot;108.96000176668167&quot;</span><br>      2) <span class="hljs-string">&quot;34.2599996441893&quot;</span><br>127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 1<span class="hljs-comment"># count查询的个数</span><br>1) 1) <span class="hljs-string">&quot;chongqing&quot;</span><br>   2) 1) <span class="hljs-string">&quot;106.49999767541885&quot;</span><br>      2) <span class="hljs-string">&quot;29.529999579006592&quot;</span><br>127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 2<br>1) 1) <span class="hljs-string">&quot;chongqing&quot;</span><br>   2) 1) <span class="hljs-string">&quot;106.49999767541885&quot;</span><br>      2) <span class="hljs-string">&quot;29.529999579006592&quot;</span><br>2) 1) <span class="hljs-string">&quot;xian&quot;</span><br>   2) 1) <span class="hljs-string">&quot;108.96000176668167&quot;</span><br>      2) <span class="hljs-string">&quot;34.2599996441893&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>georadiusbymember 找出位于指定范围内的元素，中心点是由给定的位置元素决定</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km<br>1) <span class="hljs-string">&quot;beijing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km<br>1) <span class="hljs-string">&quot;hangzhou&quot;</span><br>2) <span class="hljs-string">&quot;shanghai&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>geohash 返回一个或多个位置元素的Geohash表示</p></blockquote><p>该命令将返回11个字符的Geohash字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近</span><br>127.0.0.1:6379&gt; geohash china:city beijing chongqing<br>1) <span class="hljs-string">&quot;wx4fbxxfke0&quot;</span><br>2) <span class="hljs-string">&quot;wm5xzrybty0&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>geo底层的实现原理其实就是Zset！可以使用Zset命令来操作geo</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; ZRANGE china:city 0 -1<span class="hljs-comment"># 查看地图中全部的元素</span><br>1) <span class="hljs-string">&quot;chongqing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>3) <span class="hljs-string">&quot;hangzhou&quot;</span><br>4) <span class="hljs-string">&quot;shanghai&quot;</span><br>5) <span class="hljs-string">&quot;beijing&quot;</span><br>127.0.0.1:6379&gt; zrem china:city beijing<span class="hljs-comment"># 移除指定元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zrange china:city 0 -1<br>1) <span class="hljs-string">&quot;chongqing&quot;</span><br>2) <span class="hljs-string">&quot;xian&quot;</span><br>3) <span class="hljs-string">&quot;hangzhou&quot;</span><br>4) <span class="hljs-string">&quot;shanghai&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>Hyperloglog（HLL）是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></p><p>Redis中的HLL是基于string结构实现的，对单个HLL的内存永远小于16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于0.81%的误差。不过对于UV统计来说，这完全可以忽略。</p><h4 id="HLL的命令"><a href="#HLL的命令" class="headerlink" title="HLL的命令"></a>HLL的命令</h4><ul><li>PFADD</li><li>PFCOUNT</li><li>PFMERGE</li></ul><blockquote><p>什么是基数？</p></blockquote><p>A{1,3,5,7,8,7}</p><p>B{1,3,5,7,8}</p><p>基数（去重后元素的个数） &#x3D; 5</p><p>Redis Hyperloglog基数统计的算法。</p><p>优点：占用的内存是固定的，2^64不同的元素的技术，只需要废12KB内存。如果要从内存角度来比较的话Hyperloglog首选。</p><p><strong>网页的UV（一个人访问一个网站多次，但是还是算作一个人）</strong></p><p>传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断。</p><p>这个方式如果保存大量的用户id，就会比较麻烦，我们的目的是为了计数，而不是保存用户的id。存在0.81%错误率，但是统计UV任务，可以忽略不计。</p><blockquote><p>测试使用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; PFADD mykey a b c d e f g h i j<span class="hljs-comment"># 创建第一组元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; PFCOUNT mykey<span class="hljs-comment"># 统计 mykey 元素的基数数量</span><br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; PFADD mykey2 i j z x c v b n m<span class="hljs-comment"># 创建第二组元素</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; PFCOUNT mykey2<br>(<span class="hljs-built_in">integer</span>) 9<br>127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2<span class="hljs-comment"># 合并两组 mykey mykey2 =&gt; mykey3 并集</span><br>OK<br>127.0.0.1:6379&gt; PFCOUNT mykey3<br>(<span class="hljs-built_in">integer</span>) 15<br></code></pre></td></tr></table></figure><p>如果允许容错，那么一定可以使用Hyperloglog</p><p>如果不允许容错，就使用set或者自己的数据类型即可</p><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是2^32个bit。</p><blockquote><p>位存储</p></blockquote><p>Bitmaps位图，操作二进制位来进行记录，只有0和1两个状态。</p><h4 id="BitMaps的操作命令"><a href="#BitMaps的操作命令" class="headerlink" title="BitMaps的操作命令"></a>BitMaps的操作命令</h4><ul><li><p>SETBIT：向指定位置（offset）存入一个0或1</p></li><li><p>GETBIT：获取指定位置（offset）的bit值</p></li><li><p>BITCOUNT：统计BItMaps中值为1的bit位的数量</p></li><li><p>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</p></li><li><p>BITFIELD_RO：获取BItMap中bit数组，并以十进制形式返回</p></li><li><p>BITOP：将多个BitMap的结果做位运算（与、或、异或）</p></li><li><p>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; SETBIT sign 0 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 1 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 2 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 3 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 4 1<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 5 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; setbit sign 6 0<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; getbit sign 3<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; getbit sign 6<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; BITCOUNT sign<br>(<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis单条命令是保存原子性的，但是事务不保证原子性</p><p>所有的命令在事务中并没有直接被执行，只有发起执行命令的时候才会执行。</p><p>redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（…）</li><li>执行事务（exec）</li></ul><blockquote><p>正常执行事务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<span class="hljs-comment"># 开启事务</span><br>OK<br><span class="hljs-comment"># 命令入队</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><span class="hljs-comment"># 执行事务</span><br>1) OK<br>2) OK<br>3) <span class="hljs-string">&quot;v2&quot;</span><br>4) OK<br></code></pre></td></tr></table></figure><blockquote><p>放弃事务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<span class="hljs-comment">#开启事务</span><br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; discard<span class="hljs-comment">#取消事务</span><br>OK<br>127.0.0.1:6379&gt; get k4<br>(nil)<br></code></pre></td></tr></table></figure><blockquote><p>编译型异常（代码有问题，命令有错），事务中所有的命令都不会被执行</p></blockquote><blockquote><p>运行时异常（1&#x2F;0），如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的</p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据。</li><li>获取version</li><li>更新的时候比较version</li></ul><blockquote><p>Redis监视测试</p></blockquote><p>正常执行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money 100<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> out 0<br>OK<br>127.0.0.1:6379&gt; watch money<span class="hljs-comment"># 监视money对象</span><br>OK<br>127.0.0.1:6379&gt; multi<span class="hljs-comment"># 事务正常结束，数据期间没有发生变动</span><br>OK<br>127.0.0.1:6379&gt; DECRBY money 20<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 20<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) (<span class="hljs-built_in">integer</span>) 80<br>2) (<span class="hljs-built_in">integer</span>) 20<br></code></pre></td></tr></table></figure><p>执行事务时若watch到money发生改变，则此事务会执行失败。</p><p>使用watch可以当作redis的乐观锁操作。</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>使用Java操作Redis</p><p>1.导入对应的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.76<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.编码测试：</p><ul><li><p>连接数据库</p></li><li><p>操作命令</p></li><li><p>断开连接</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPing</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.new jedis对象</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//jedis所有的命令就是redis的所有命令</span><br>        System.out.println(jedis.ping());<span class="hljs-comment">//输出PONG</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis。</p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化。</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><table><thead><tr><th>API</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>redisTemplate.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td>redisTemplate.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td>redisTemplate.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td>redisTemplate.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td>redisTemplate.opsForZSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td>redisTemplate</td><td></td><td>通用命令</td></tr></tbody></table><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><h3 id="RedisTemplate的两种序列化方案："><a href="#RedisTemplate的两种序列化方案：" class="headerlink" title="RedisTemplate的两种序列化方案："></a>RedisTemplate的两种序列化方案：</h3><p>方案一：</p><ol><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ol><p>方案二：</p><ol><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>SpringBoot2.x之后，原来使用的jedis被替换为了lettuce</p><p>jedis：采用的直连，多个线程操作的话是不安全的，如果想要避免不安全的，使用JedisPool连接池。</p><p>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p><blockquote><p>整合</p></blockquote><p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.配置连接</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>3.测试</p><h2 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h2><blockquote><p>包含</p></blockquote><p><img src="/2021/08/09/Redis/image-20210720180203714.png" alt="Redis.conf"></p><blockquote><p>网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1<span class="hljs-comment">#绑定的ip</span><br>protected-mode <span class="hljs-built_in">yes</span><span class="hljs-comment">#保护模式</span><br>port 6379<span class="hljs-comment">#端口设置</span><br></code></pre></td></tr></table></figure><blockquote><p>通用 GENERAL</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">daemonize <span class="hljs-built_in">yes</span><span class="hljs-comment"># 以守护进程的方式运行，默认是no，我们需要自己开启为yes</span><br><br>pidfile /var/run/redis.pid<span class="hljs-comment"># 如果以后台的方式运行，就需要指定一个pid文件</span><br><br><span class="hljs-comment">#日志</span><br><span class="hljs-comment"># Specify the server verbosity level.</span><br><span class="hljs-comment"># This can be one of:</span><br><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)</span><br><span class="hljs-comment"># warning (only very important / critical messages are logged)</span><br>loglevel notice<br>logfile <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">#日志的文件位置名</span><br>databases 16 <span class="hljs-comment">#数据库的数量，默认是 16 个数据库</span><br>always-show-logo <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 是否总是显示LOGO</span><br></code></pre></td></tr></table></figure><blockquote><p>快照 SNAPSHOTTING</p></blockquote><p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件<code>.rdb</code> <code>.aof</code></p><p>redis是内存数据库，如果没有持久化，那么数据断电即失！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#如果900秒内，如果至少有一个key进行了修改，就进行持久化操作</span><br>save 900 1<br><span class="hljs-comment">#如果300s内，如果至少10 key进行了修改，就进行持久化操作</span><br>save 300 10<br><span class="hljs-comment">#如果60s内，如果至少10000 key进行了修改，就进行持久化操作</span><br>save 60 10000<br><br>stop-writes-on-bgsave-error <span class="hljs-built_in">yes</span> <span class="hljs-comment">#持久化如果出错，是否还需要继续工作</span><br><br>rdbcompression <span class="hljs-built_in">yes</span> <span class="hljs-comment">#默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。建议不开启，压缩也会消耗cpu，磁盘不值钱</span><br><br>rdbchecksum <span class="hljs-built_in">yes</span> <span class="hljs-comment">#默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</span><br><br><span class="hljs-built_in">dir</span> ./ <span class="hljs-comment"># rdb文件保存的目录</span><br></code></pre></td></tr></table></figure><blockquote><p>主从复制 REPLICATION</p></blockquote><blockquote><p>SECURITY</p></blockquote><p>可以为redis设置密码，默认没有密码</p><p><code>config get requirepass</code> 获取redis密码</p><p><code>config set requirepass &quot;123456&quot;</code> 设置redis密码</p><p><code>auth 123456</code> 使用密码进行登录</p><blockquote><p>限制 LIMITS</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">maxClients 10000 <span class="hljs-comment">#设置能连接上redis的最大客户端的数量</span><br>maxmemory &lt;bytes&gt; <span class="hljs-comment">#redis 配置最大的内存容量</span><br><br>maxmemory-policy noeviction <span class="hljs-comment">#内存达到上限之后的处理策略</span><br>    1.volatile-lru -&gt; remove the key with an expire <span class="hljs-built_in">set</span> using an LRU algorithm<br>    只对设置了过期时间的key进行LRU<br>    2.allkeys-lru -&gt; remove any key according to the LRU algorithm<br>    删除LRU算法的key<br>    3.volatile-random -&gt; remove a random key with an expire <span class="hljs-built_in">set</span><br>    在设置了过期时间的key中进行随机删除<br>    4.allkeys-random -&gt; remove a random key, any key<br>    随机删除key<br>    5.volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)<br>    删除即将过期的key<br>    6.noeviction -&gt; don<span class="hljs-string">&#x27;t expire at all, just return an error on write operations</span><br><span class="hljs-string">    永不过期，返回错误</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><blockquote><p>AOF配置 APPEND ONLY MODE</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly no <span class="hljs-comment">#默认不开启aof模式，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span><br><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span> <span class="hljs-comment"># 持久化的文件的名字</span><br><br><span class="hljs-comment"># appendfsync always #每次修改都会 sync，消耗性能</span><br>appendfsync everysec <span class="hljs-comment">#每秒执行一次 sync</span><br><span class="hljs-comment"># appendfsync no #不执行 sync(同步)，操作系统自己同步数据，速度最快</span><br></code></pre></td></tr></table></figure><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis是内存数据库，如果不将内存中的数据库保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。</p><h3 id="RDB-Redis-Database"><a href="#RDB-Redis-Database" class="headerlink" title="RDB(Redis Database)"></a>RDB(Redis Database)</h3><p>在指定的时间间隔内将内存中的数据集快照(SnapShot)写入磁盘，它恢复时将快照文件直接读到内存中。</p><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>rdb保存的文件是dump.rdb，在配置文件中<code>SNAPSHOTTING</code>部分进行了配置。<code>dbfilename dump.rdb</code></p><h4 id="1-RDB生成快照保存的三种触发方式"><a href="#1-RDB生成快照保存的三种触发方式" class="headerlink" title="1.RDB生成快照保存的三种触发方式"></a>1.RDB生成快照保存的三种触发方式</h4><ol><li><p><strong>save触发方式</strong></p><p>该命令会阻塞当前的Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。执行完成的时候如果存在老的RDB文件，就把新的替代掉旧的。如果客户端多达几万或几十万，那么这种方式显然不可取。</p></li><li><p><strong>bgsave触发方式</strong>（bg即backgroud，后台）</p><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p><p>具体操作为Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上Redis内部所有的RDB操作都是采用bgsave命令。</p></li><li><p><strong>自动触发</strong></p><p>自动触发是由我们的配置文件来完成的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 900秒内，如果至少有1个key被修改，则执行bgsave，如果save &quot;&quot; 则表示禁用rdb</span><br>save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-save与bgsave对比"><a href="#2-save与bgsave对比" class="headerlink" title="2.save与bgsave对比"></a>2.save与bgsave对比</h4><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞</td><td>是</td><td>是（发生在fork）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork，消耗内存</td></tr></tbody></table><h4 id="3-RDB的优点和缺点"><a href="#3-RDB的优点和缺点" class="headerlink" title="3.RDB的优点和缺点"></a>3.RDB的优点和缺点</h4><p>优点：</p><ol><li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li><li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ol><p>缺点：</p><p>​RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><p>全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。</p><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加记录不可以修改记录，redis启动之初会读取该文件重新构建数据。</p><p>aof保存的是appendonly.aof文件。</p><p>如果aof文件有错误，此时redis是无法启动的，需要修复aof文件</p><p>redis提供了一个工具<code>redis-check-aof</code></p><h4 id="1-文件重写原理"><a href="#1-文件重写原理" class="headerlink" title="1.文件重写原理"></a>1.文件重写原理</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</p><p><img src="/2021/08/09/Redis/%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86.jpeg" alt="文件重写原理"></p><p>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p><h4 id="2-AOF三种触发机制"><a href="#2-AOF三种触发机制" class="headerlink" title="2.AOF三种触发机制"></a>2.AOF三种触发机制</h4><table><thead><tr><th>配置项</th><th>刷盘时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>always</td><td>同步刷盘</td><td>可靠性高，几乎不丢失数据</td><td>性能影响大</td></tr><tr><td>everysec</td><td>每秒刷盘</td><td>性能适中</td><td>最多丢失1秒数据</td></tr><tr><td>no</td><td>操作系统控制</td><td>性能最好</td><td>可靠性较差，可能丢失大量数据</td></tr></tbody></table><p>因为是记录命令，AOF文件会比RDB文件大得多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同的效果。</p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br>auto-aof-rewrite-percentage 100<br><span class="hljs-comment"># AOF文件体积最小多大以上才触发重写</span><br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure><p>两个需同时配置</p><h4 id="3-AOF的优点和缺点"><a href="#3-AOF的优点和缺点" class="headerlink" title="3.AOF的优点和缺点"></a>3.AOF的优点和缺点</h4><p>优点：</p><ol><li>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</li><li>AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</li><li>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</li><li>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</li></ol><p>缺点：</p><ol><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</li><li>AOF运行效率比RDB慢。</li></ol><h4 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h4><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会***<u>结合</u>***两者来使用</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量CPU和内存消耗</td><td>低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高常见</td></tr></tbody></table><h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><p>Redis发布订阅(pub&#x2F;sub)是一种<font color="#FF0000">消息通信模式</font>：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="/2021/08/09/Redis/pubsub1.png" alt="pubsub1"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/2021/08/09/Redis/pubsub2.png" alt="pubsub2"></p><p><img src="/2021/08/09/Redis/image-20210721134621524.png" alt="pubsub相关命令"></p><p><strong>使用场景：</strong></p><ol><li>实时消息系统</li><li>实时聊天</li><li>订阅</li></ol><p>稍微复杂的场景会使用消息中间件MQ</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>概念</p><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master&#x2F;leader），后者称为从节点（slave&#x2F;follower）；数据的复制是单向的，只能从主节点到从节点。Master以写为主，Slave以读为主。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p><p>主从复制的作用主要包括：</p><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基础：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：</p><ol><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大。</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存应该不超过20G。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:master <span class="hljs-comment"># 角色 master</span><br>connected_slaves:0 <span class="hljs-comment"># 没有从机</span><br>master_repl_offset:0<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><p>设置从机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置从机</span><br>SLAVEOF ip port <span class="hljs-comment">#设置哪个redis作为主机</span><br></code></pre></td></tr></table></figure><p>使用命令设置主从机只是暂时的，在配置文件中配置是永久的。</p><p><img src="/2021/08/09/Redis/image-20210721144531883.png" alt="Redis.conf"></p><p>主机可以写，从机不能写只能读。主机中的所有信息和数据，都会自动被从机保存。</p><blockquote><p>复制原理</p></blockquote><p>Slave启动成功连接到master后会发送一个sync同步命令</p><p>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p>全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p><p>增量复制：master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p><p>只要是重新连接master，一次完全同步（全量复制）将被自动执行。</p><p>**如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>**让自己变成主机，其他节点就可以手动连接到最新的这个主节点。</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>自动选择主节点</p><blockquote><p>概述</p></blockquote><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，需要优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p><p><img src="/2021/08/09/Redis/11320039-57a77ca2757d0924.png" alt="哨兵模式"></p><p><img src="/2021/08/09/Redis/11320039-3f40b17c0412116c.png" alt="哨兵模式"></p><p><strong>故障切换（failover）</strong>的过程：假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><blockquote><p>哨兵模式配置项</p></blockquote><table><thead><tr><th>配置项</th><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>port</td><td>整数</td><td>启动哨兵进程端口</td></tr><tr><td>dir</td><td>文件夹目录</td><td>哨兵进程服务临时文件夹，默认为&#x2F;tmp，要保证有可写入的权限</td></tr><tr><td>sentinel down-after-milliseconds</td><td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td></tr><tr><td>sentinel parallel-syncs</td><td>&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td>指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td></tr><tr><td>sentinel failover-timeout</td><td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td></tr><tr><td>sentinel notification-script</td><td>&lt;服务名称&gt;&lt;脚本路径&gt;</td><td>指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td></tr></tbody></table><h2 id="Redis缓存穿透和雪崩（常用）"><a href="#Redis缓存穿透和雪崩（常用）" class="headerlink" title="Redis缓存穿透和雪崩（常用）"></a>Redis缓存穿透和雪崩（常用）</h2><p>Redis缓存的使用，极大地提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透和缓存击穿。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote><p>概念</p></blockquote><p>缓存穿透是指查询一个根本不存在的数据，缓存层和持久层都不会命中。在日常工作中出于容错的考虑，如果从持久层查不到数据则不写入缓存层，缓存穿透将导致不存在的数据每次请求都要到持久层去查询，失去了缓存保护后端持久的意义。</p><p><img src="/2021/08/09/Redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="缓存穿透"></p><blockquote><p>解决方案</p></blockquote><p>1.<strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><p>2.<strong>缓存空对象</strong></p><p>缓存空对象：是指在持久层没有命中的情况下，对key进行set （key,null）</p><p>这样做会存在两个问题：</p><ol><li><p>value为null 不代表不占用内存空间，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p></li><li><p>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote><p>概念</p></blockquote><ul><li>当前key是一个热点key（例如一个秒杀活动），并发量非常大。</li><li>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等。</li></ul><p>在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p><blockquote><p>解决方案</p></blockquote><p>1.<strong>永不过期</strong></p><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li><li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去更新缓存</li></ul><p>2.<strong>加互斥锁</strong></p><p>只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。set(key,value,timeout)</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不可用（宕机）或者大量缓存由于超时时间相同在同一时间段失效（大批key失效&#x2F;热点数据失效），大量请求直接到达存储层，存储层压力过大导致系统雪崩。</p><blockquote><p>解决方案</p></blockquote><ul><li>可以把缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务。利用sentinel或cluster实现。</li><li>采用多级缓存，本地进程作为一级缓存，redis作为二级缓存，不同级别的缓存设置的超时时间不同，即使某级缓存过期了，也有其他级别缓存兜底</li><li>缓存的过期时间用随机值，尽量让不同的key的过期时间不同（例如：定时任务新建大批量key，设置的过期时间相同）</li></ul><h2 id="Redis内存淘汰策略（常用）"><a href="#Redis内存淘汰策略（常用）" class="headerlink" title="Redis内存淘汰策略（常用）"></a>Redis内存淘汰策略（常用）</h2><p>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。<br>allkeys-lru：在主键空间中，优先移除最近未使用的key。(推荐)<br>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。<br>allkeys-random：在主键空间中，随机移除某个key。<br>volatile-random：在设置了过期时间的键空间中，随机移除某个key。<br>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。</p><h2 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h2><p>Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此可以利用：LPUSH结合RPOP、或者RPUSH结合LPOP来实现。</p><p>不过需要注意的是，当队列中没有消息时RPOP或LPOP操作返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。</p><p>因此应该使用<code>BRPOP</code>或者<code>BLPOP</code>来实现阻塞效果。</p><p>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><ul><li>SUBSCRIBE channel [channel]：订阅一个或多个频道</li><li>PUBLIC channel msg：向一个频道发送消息</li><li>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li></ul><p>基于PubSub的消息队列有哪些优缺点？</p><p>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h2 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h2><p>Stream是Redis5.0引入的一种***<u>新数据类型</u>***（意味着可以被持久化），可以实现一个功能非常完善的消息队列。</p><p>发送消息命令：XADD</p><p>读取消息的方式一：XREAD</p><p>XREAD阻塞方式，读取最新的消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">XREAD COUNT 1 BLOCK STREAMS <span class="hljs-built_in">users</span> $<br></code></pre></td></tr></table></figure><p>注意：当我们指定启示ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现<code>漏读消息</code>的问题。</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><p>基于Stream的消息队列-消费者组</p><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><ul><li><p>消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度。</p></li><li><p>消息标示：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费。</p></li><li><p>消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。</p></li></ul><p>创建消费者组：</p><p>XGROUP CREATE key groupName ID [MKSTREAM]</p><ul><li>key：队列名称</li><li>groupName：消费者组名称</li><li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息。</li><li>MKSTREAM：队列不存在时自动创建队列。</li></ul><p>其他常见命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#删除指定的消费者组</span><br>XGROUP DESTORY key groupName<br><br><span class="hljs-comment">#给指定的消费者组添加消费者</span><br>XGROUP CREATECONSUMER key groupname consumername<br><br><span class="hljs-comment">#删除消费者组中的指定消费者</span><br>XGROUP DELCONSUMER key groupname consumername<br></code></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure><ul><li><p>group：消费组名称</p></li><li><p>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</p></li><li><p>count：本次查询的最大数量</p></li><li><p>BLOCK milliseconds：当没有消息时最长等待时间</p></li><li><p>NOACK：无需手动ACK，获取到消息后自动确认</p></li><li><p>STREAMS key：指定队列名称</p></li><li><p>ID：获取消息的起始ID：</p><ul><li>“&gt;”：从下一个未消费的消息开始</li><li>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始。</li></ul></li></ul><p>Redis消息队列</p><table><thead><tr><th></th><th>List</th><th>PubSub</th><th>Stream</th></tr></thead><tbody><tr><td>消息持久化</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>阻塞读取</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>消息堆积处理</td><td>受限于内存空间，可以利用多消费者加快处理</td><td>受限于消费者缓冲区</td><td>受限于队列长度，可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td>消息确认机制</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>消息回溯</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nosql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2021/08/06/MyBatis/"/>
    <url>/2021/08/06/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p><a href="https://mybatis.org/mybatis-3/zh/">mybatis – MyBatis 3 | 简介</a></p><blockquote><p>XML映射文件</p></blockquote><h2 id="SQL映射文件的顶级元素"><a href="#SQL映射文件的顶级元素" class="headerlink" title="SQL映射文件的顶级元素"></a>SQL映射文件的顶级元素</h2><table><thead><tr><th>元素</th><th>作用</th></tr></thead><tbody><tr><td>cache</td><td>该命名空间的缓存配置</td></tr><tr><td>cache-ref</td><td>引用其他命名空间的缓存配置</td></tr><tr><td>resultMap</td><td>描述如何从数据库结果集中加载对象</td></tr><tr><td>sql</td><td>可被其他语句引用的可重用语句块</td></tr><tr><td>insert</td><td>映射插入语句</td></tr><tr><td>update</td><td>映射更新语句</td></tr><tr><td>delete</td><td>映射删除语句</td></tr><tr><td>select</td><td>映射查询语句</td></tr></tbody></table><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="1-namespace"><a href="#1-namespace" class="headerlink" title="1.namespace"></a>1.namespace</h3><p>namespace中的包名要和Dao&#x2F;Mapper接口的包名一致。</p><h3 id="2-select"><a href="#2-select" class="headerlink" title="2.select"></a>2.select</h3><p>选择，查询语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPerson&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span>&gt;</span><br>  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>id：语句名(selectPerson)，对应namespace中的方法名</p></li><li><p>parameterType：接受参数的类型（int）</p></li><li><p>resultType：返回对象的类型</p></li></ul><h3 id="3-insert"><a href="#3-insert" class="headerlink" title="3.insert"></a>3.insert</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span>&gt;</span><br>  insert into Author (id,username,password,email,bio)<br>  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="4-update"><a href="#4-update" class="headerlink" title="4.update"></a>4.update</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span>&gt;</span><br>  update Author set<br>    username = #&#123;username&#125;,<br>    password = #&#123;password&#125;,<br>    email = #&#123;email&#125;,<br>    bio = #&#123;bio&#125;<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-delete"><a href="#5-delete" class="headerlink" title="5.delete"></a>5.delete</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span>&gt;</span><br>  delete from Author where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><blockquote><p>解决属性名和字段名不一致的问题</p></blockquote><p>结果集映射<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps">mybatis – MyBatis 3 | XML 映射器</a></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>limit</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html">mybatis – MyBatis 3 | 动态 SQL</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `blog`(<br>`id` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT 博客id,<br>`title` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT 博客标题,<br>`author` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT 博客作者,<br>`create_time` DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT 创建时间,<br>`views` <span class="hljs-type">INT</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT 浏览量<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><h3 id="lt-if-gt"><a href="#lt-if-gt" class="headerlink" title="&lt;if&gt;"></a>&lt;if&gt;</h3><h3 id="lt-choose-gt-when-otherwise"><a href="#lt-choose-gt-when-otherwise" class="headerlink" title="&lt;choose&gt;(when, otherwise)"></a>&lt;choose&gt;(when, otherwise)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>  <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>      AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>      AND author_name like #&#123;author.name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>      AND featured = 1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>类似 Java 中的 switch 语句。</p><h3 id="lt-where-gt"><a href="#lt-where-gt" class="headerlink" title="&lt;where&gt;"></a>&lt;where&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG<br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>         state = #&#123;state&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>        AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>        AND author_name like #&#123;author.name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>*<em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where</em> 元素也会将它们去除。**</p><h3 id="lt-set-gt"><a href="#lt-set-gt" class="headerlink" title="&lt;set&gt;"></a>&lt;set&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br>  update Author<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>  where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</strong></p><h3 id="lt-trim-gt-where-set"><a href="#lt-trim-gt-where-set" class="headerlink" title="&lt;trim&gt;(where, set)"></a>&lt;trim&gt;(where, set)</h3><p>通过自定义 trim 元素来定制 <em>where</em> 元素和<em>set</em>元素的功能。</p><p>和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND |OR &quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p>与 <em>set</em> 元素等价的自定义 <em>trim</em> 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="lt-foreach-gt"><a href="#lt-foreach-gt" class="headerlink" title="&lt;foreach&gt;"></a>&lt;foreach&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPostIn&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>&gt;</span><br>  SELECT *<br>  FROM POST P<br>  WHERE ID in<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;item&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h2><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache">mybatis – MyBatis 3 | XML 映射器</a></p><ul><li>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大地提升查询效率。</li><li>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul><li>默认情况下，只有一级缓存开启。（sqlSession级别的缓存，也称为本地缓存）</li><li>二级缓存需要手动开启和配置，是基于namespace级别的缓存。</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache。可以通过实现Cache接口来自定义二级缓存。</li></ul></li></ul><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><ul><li>一级缓存也叫本地缓存：<ul><li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li><li>以后如果需要获取相同的数据，直接从缓存中拿，不必再去查数据库。</li></ul></li></ul><p>小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段。一级缓存就是一个Map。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><ul><li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存。</li><li>基于namespace级别的缓存，一个命名空间对应一个二级缓存。</li><li>工作机制<ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li><li>新的会话查询信息，就可以从二级缓存中获取内容；</li><li>不同的mapper查出的数据会放在自己对应的缓存中。</li></ul></li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>映射语句文件中的所有 select 语句的结果将会被缓存。<br><span class="hljs-bullet">- </span>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。<br><span class="hljs-bullet">- </span>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。<br><span class="hljs-bullet">- </span>缓存不会定时进行刷新（也就是说，没有刷新间隔）。<br><span class="hljs-bullet">- </span>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。<br><span class="hljs-bullet">- </span>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。<br></code></pre></td></tr></table></figure><p>小结：</p><ul><li>只要开启了二级缓存，在同一个Mapper下就有效</li><li>所有的数据都会先放在一级缓存中</li><li>只有当会话提交，或者关闭的时候，才会提交到二级缓存中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ORM框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/2021/08/06/MySQL%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/08/06/MySQL%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>MySQL基础</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p; <span class="hljs-comment">-- 连接数据库</span><br><br>flush privileges; <span class="hljs-comment">-- 刷新权限</span><br><br><span class="hljs-keyword">show</span> databases; <span class="hljs-comment">-- 查看所有的数据库</span><br><br>use 数据库名; <span class="hljs-comment">-- 切换数据库</span><br><br><span class="hljs-keyword">show</span> tables; <span class="hljs-comment">-- 查看所有的表</span><br><br><span class="hljs-keyword">describe</span><span class="hljs-operator">/</span><span class="hljs-keyword">desc</span> 数据表; <span class="hljs-comment">-- 显示表信息</span><br><br><span class="hljs-keyword">create</span> database 数据库名; <span class="hljs-comment">-- 创建数据库</span><br><br>exit; <span class="hljs-comment">-- 退出连接</span><br></code></pre></td></tr></table></figure><p>数据库XXX语言</p><p>DDL定义</p><p>DML操作</p><p>DQL查询</p><p>DCL控制</p><h2 id="1-操作数据库"><a href="#1-操作数据库" class="headerlink" title="1.操作数据库"></a>1.操作数据库</h2><p>操作数据库&gt;操作数据库中的表&gt;操作数据库中表的数据</p><p><font color="FF0000">mysql关键字不区分大小写</font></p><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>1.创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名;<br></code></pre></td></tr></table></figure><p>2.删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE [IF <span class="hljs-keyword">EXISTS</span>] 数据库名;<br></code></pre></td></tr></table></figure><p>3.使用数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- tab键上面，如果表名或字段名是一个特殊字符，就需要带``</span><br>USE `school`<br></code></pre></td></tr></table></figure><p>4.查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES <span class="hljs-comment">-- 查看所有的数据库</span><br></code></pre></td></tr></table></figure><h3 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h3><blockquote><p>数值</p></blockquote><ul><li>tinyint       十分小的数据     1个字节</li><li>smallint        较小的数据            2个字节</li><li>mediumint   中等大小的数据    3个字节</li><li>int                 标准的整数            4个字节（常用）</li><li>bigint             较大的数据           8个字节</li><li>float               浮点数                   4个字节</li><li>double           浮点数                   8个字节</li><li>decimal          字符串形式的浮点数     金融计算的时候一般使用decimal</li></ul><blockquote><p>字符串</p></blockquote><ul><li>char              字符串固定大小     0-255<strong>字符</strong></li><li>varchar         可变字符串             0-65535字节（常用）</li><li>tinytext          微型文本                2^8 - 1（255字节）</li><li>text                 文本串                   2^16 - 1（65535字节）</li></ul><blockquote><p>时间日期</p></blockquote><p>java.util.Date</p><ul><li>date          YYYY-MM-DD，日期格式</li><li>time          HH:mm:ss，时间格式</li><li>datetime   YYYY-MM-DD  HH:mm:ss，最常用的时间格式</li><li>timestamp   时间戳，1970.1.1到现在的毫秒数，也较为常用</li><li>year            年份</li></ul><blockquote><p>null</p></blockquote><ul><li>没有值，未知</li><li><font color="FF0000">不要使用NULL进行运算，结果为NULL</font></li></ul><h3 id="数据库的字段属性（重点）"><a href="#数据库的字段属性（重点）" class="headerlink" title="数据库的字段属性（重点）"></a>数据库的字段属性（重点）</h3><p><strong>Unsigned：</strong></p><ul><li>无符号的整数</li><li>声明了该列不能声明为负数</li></ul><p><strong>zerofill：</strong></p><ul><li>0填充的</li><li>不足的位数，使用0来填充，int(3)，5 -&gt; 005</li></ul><p><strong>自增：</strong></p><ul><li>通常理解为自增，自动在上一条记录的基础上+1</li><li>通常用来设计唯一的主键 index，必须是整数类型</li><li>可以自定义设计主键自增的起始值和步长</li></ul><p><strong>非空 not null：</strong></p><ul><li>设置为not null，如果不给它赋值，就会报错</li><li>NULL，如果不填写值，默认就是null</li></ul><p><strong>默认：</strong></p><ul><li>设置默认的值</li></ul><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] `表名`(<br>`字段名` 列类型 [属性] [索引] [注释],<br>    `字段名` 列类型 [属性] [索引] [注释],<br>    ...<br>    `字段名` 列类型 [属性] [索引] [注释],<br>)[表类型][字符集设置][注释]<br></code></pre></td></tr></table></figure><h3 id="数据表类型"><a href="#数据表类型" class="headerlink" title="数据表类型"></a>数据表类型</h3><p>数据库引擎</p><p>INNODB</p><p>MYISAM 早些年使用</p><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间的大小</td><td>较小</td><td>较大，约为2倍</td></tr></tbody></table><p>常规使用操作：</p><ul><li>MYISAM节约空间，速度较快</li><li>INNODB   安全性高，事务的处理，多表用户操作</li></ul><blockquote><p>在物理空间存在的位置（了解）</p></blockquote><p>所有的数据库文件都存在data目录下</p><p>本质还是文件的存储</p><p>MySQL引擎在物理文件上的区别</p><ul><li>InnoDB在数据表中只有一个*.frm文件，以及上级目录下的ibdata1文件</li><li>MYISAM对应的文件<ul><li>*.frm - 表结构的定义文件</li><li>*.MYD 数据文件(data)</li><li>*.MYI   索引文件(index)</li></ul></li></ul><blockquote><p>修改表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改表名 ALTER TABLE 旧表名RENAME AS 新表名</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> teacher RENAME <span class="hljs-keyword">AS</span> teacher1<br><span class="hljs-comment">-- 增加表的字段 ALTER TABLE 表名 ADD 字段名 列属性</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> teacher1 <span class="hljs-keyword">ADD</span> age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)<br><span class="hljs-comment">-- 修改表的字段（重命名，修改约束）</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> teacher1 MODIFY age <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-comment">-- 修改约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> teacher1 CHANGE age age1 <span class="hljs-type">INT</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">-- 字段重命名</span><br><br><span class="hljs-comment">-- 删除表的字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> teacher1 <span class="hljs-keyword">DROP</span> age1<br><br><br></code></pre></td></tr></table></figure><blockquote><p>删除</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] teacher1<br></code></pre></td></tr></table></figure><p>所有的创建和删除操作尽量加上判断，以免报错。</p><h2 id="2-MySQL数据管理"><a href="#2-MySQL数据管理" class="headerlink" title="2.MySQL数据管理"></a>2.MySQL数据管理</h2><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><h3 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h3><p>数据库意义：数据存储，数据管理</p><p>DML语言：数据操作语言</p><ul><li>insert</li><li>update</li><li>delete</li></ul><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入语句（添加）</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名([字段名<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>,字段<span class="hljs-number">3</span>]) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;值1&#x27;</span>,<span class="hljs-string">&#x27;值2&#x27;</span>,<span class="hljs-string">&#x27;值3&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意事项：</p><ol><li>字段和字段之间使用英文逗号隔开</li><li>字段可以省略，但是后面的值必须要一一对应，不能少</li><li>可以同时插入多条数据，values后面的值，需要使用,隔开</li></ol><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">set</span> colnum_name <span class="hljs-operator">=</span> <span class="hljs-keyword">value</span>,[colnum_name <span class="hljs-operator">=</span> <span class="hljs-keyword">value</span>,...] <span class="hljs-keyword">where</span> 条件<br></code></pre></td></tr></table></figure><ul><li>colnum_name是数据库的列，尽量带上&#96;&#96;</li><li>筛选的条件，如果没有指定，则会修改所有的列</li><li>value，是一个具体的值，也可以是一个变量</li><li>多个设置的属性之间，使用英文逗号隔开</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>delete命令</p></blockquote><p>语法：<code>delete from 表名 [where 条件]</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除数据（避免这样写，会全部删除）</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `student`;<br><br><span class="hljs-comment">-- 删除指定数据</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `student` <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><blockquote><p>TRUNCATE命令</p></blockquote><p>作用：完全清空一个数据表，表的结构和索引约束不会变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 清空 student 表</span><br><span class="hljs-keyword">TRUNCATE</span> `student`<br></code></pre></td></tr></table></figure><blockquote><p>delete与TRUNCATE区别</p></blockquote><ul><li>相同点：都能删除数据，都不会删除表结构</li><li>不同点：<ul><li>TRUNCATE 重新设置自增列，计数器会归零</li><li>TRUNCATE 不会影响事务</li></ul></li></ul><h2 id="3-DQL查询数据（重点）"><a href="#3-DQL查询数据（重点）" class="headerlink" title="3.DQL查询数据（重点）"></a>3.DQL查询数据（重点）</h2><p>（Data Query Language）数据查询语言</p><p>SELECT完整语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span>]<br>&#123;<span class="hljs-operator">*</span> <span class="hljs-operator">|</span> table.<span class="hljs-operator">*</span> <span class="hljs-operator">|</span> [table.field[<span class="hljs-keyword">as</span> alias1][,table.field2[<span class="hljs-keyword">as</span> alias2]][,...]]&#125;<br><span class="hljs-keyword">FROM</span> table_name [<span class="hljs-keyword">as</span> table_allias]<br>[<span class="hljs-keyword">left</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">right</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table_name2] <span class="hljs-comment">-- 联合查询</span><br>[<span class="hljs-keyword">WHERE</span> ...]<span class="hljs-comment">-- 指定结果需要满足的条件</span><br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...] <span class="hljs-comment">-- 指定结果按照哪个字段来分组</span><br>[<span class="hljs-keyword">HAVING</span>] <span class="hljs-comment">-- 过滤分组的记录必须满足的次要条件</span><br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>] <span class="hljs-comment">-- 指定查询记录按一个或多个条件排序</span><br>[limit &#123;[<span class="hljs-keyword">offset</span>,]row_count&#125; <span class="hljs-operator">|</span> row_countOFFSET <span class="hljs-keyword">offset</span>()&#125;;<br>     <span class="hljs-comment">-- 查询记录的记录从哪至哪条</span><br></code></pre></td></tr></table></figure><h3 id="指定查询字段"><a href="#指定查询字段" class="headerlink" title="指定查询字段"></a>指定查询字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询全部的学生</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student<br><br><span class="hljs-comment">-- 查询指定字段</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`StudentName` <span class="hljs-keyword">FROM</span> student<br><br><span class="hljs-comment">-- 别名，给结果起一个名字 AS 可以给字段起别名，也可以给表起别名</span><br><span class="hljs-comment">-- 字段名 AS 别名</span><br><span class="hljs-keyword">SELECT</span> `StudentNo` <span class="hljs-keyword">AS</span> 学号,`StudentName` <span class="hljs-keyword">AS</span> 学生姓名 <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s<br><br><span class="hljs-comment">-- 函数 Concat(a,b)</span><br><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;姓名：&#x27;</span>,StudentNmae) <span class="hljs-keyword">AS</span> 新名字 <span class="hljs-keyword">FROM</span> Student<br><br></code></pre></td></tr></table></figure><blockquote><p>去重 distinct</p></blockquote><p>作用：去除SELECT查询出来的结果中重复的数据，重复的数据只显示一条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询全部的考试成绩</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-comment">-- 查询哪些同学参加了考试</span><br><span class="hljs-keyword">SELECT</span> `StudentNo` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-comment">-- 发现重复数据，去重</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> `StudentNo` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br></code></pre></td></tr></table></figure><p>数据库中的表达式：文本值，列，Null，函数，计算表达式，系统变量…</p><h3 id="where条件子句"><a href="#where条件子句" class="headerlink" title="where条件子句"></a>where条件子句</h3><p>作用：检索数据中符合条件的值</p><blockquote><p>逻辑运算符</p></blockquote><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>and    &amp;&amp;</td><td>a and b          a&amp;&amp;b</td><td>逻辑与，两个都为真，结果为真</td></tr><tr><td>or  ||</td><td>a or b            a || b</td><td>逻辑或，其中一个为真，则结果为真</td></tr><tr><td>Not    !</td><td>not a               !a</td><td>逻辑非，真为假，假为真</td></tr></tbody></table><blockquote><p>模糊查询</p></blockquote><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>IS NULL</td><td>a is null</td><td>如果操作符为NULL，结果为真</td></tr><tr><td>IS NOT NULL</td><td>a is not null</td><td>如果操作符不为null，结果为真</td></tr><tr><td>BETWEEN</td><td>a between b and c</td><td>若a在b和c之间，则结果为真</td></tr><tr><td><strong>Like</strong></td><td>a like b</td><td>SQL匹配，如果a匹配b，则结果为真</td></tr><tr><td><strong>In</strong></td><td>a in (a1,a2,a3)</td><td>假设a在a1，或者a2…其中的某一个值中，结果为真</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询姓刘的同学</span><br><span class="hljs-comment">-- like结合%(代表0到任意个字符)_(代表一个字符)</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`StudentName` <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> StudentName <span class="hljs-keyword">LIKE</span> `刘<span class="hljs-operator">%</span>`;<br><br><span class="hljs-comment">-- 查询姓刘的同学，名字后面只有一个字的</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`StudentName` <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> StudentName <span class="hljs-keyword">LIKE</span> `刘_`;<br><br><span class="hljs-comment">-- 查询名字中间有嘉字的同学 %嘉%</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`StudentName` <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> StudentName <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%嘉%&#x27;</span>;<br><br><span class="hljs-comment">-- in</span><br><span class="hljs-comment">-- 查询1001，1002，1003号学员</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`, `StudentName` <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> StudentNo <span class="hljs-keyword">IN</span> (<span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>,<span class="hljs-number">1003</span>);<br><br><span class="hljs-comment">-- 查询在北京的学生</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`StudentName` <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> `Address` <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;安徽&#x27;</span>,<span class="hljs-string">&#x27;河南洛阳&#x27;</span>);<br><br><span class="hljs-comment">-- 查询地址为空的学生</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`StudentName` <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> address<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">OR</span> address <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><br><span class="hljs-comment">-- 查询有出生日期的同学</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`StudentName` <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> `BornDate` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><blockquote><p>Join</p></blockquote><p><img src="/2021/08/06/MySQL%E5%9F%BA%E7%A1%80/20181103160140252.png" alt="联表查询"></p><p>MySQL不支持full outer join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.studentNO,studentName,SubjectNo,StudentResult<br><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s <span class="hljs-comment">-- AS 可以省略</span><br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">AS</span> r<br><span class="hljs-keyword">WHERE</span> s.studentNO <span class="hljs-operator">=</span> r.studentNO;<br><br><span class="hljs-comment">-- Right Join</span><br><span class="hljs-keyword">SELECT</span> s.studentNO,studentName,SubjectNo,StudentResult<br><span class="hljs-keyword">FROM</span> student s<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">result</span> r<br><span class="hljs-keyword">ON</span> s.studentNO <span class="hljs-operator">=</span> r.studentNO; <span class="hljs-comment">-- 可以用on</span><br></code></pre></td></tr></table></figure><blockquote><p>自连接</p></blockquote><p>自己的表和自己的表连接</p><h3 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h3><blockquote><p>排序</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 排序：升序asc, 降序desc</span><br><span class="hljs-comment">-- ORDER BY 通过哪个字段排序，怎么排</span><br><span class="hljs-comment">-- 查询的结果根据 成绩降序 排序</span><br><span class="hljs-keyword">SELECT</span> s.`StudentNo`, `StudentName`, `SubjectName`, `SubjectResult`<br><span class="hljs-keyword">FROM</span> student s<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `<span class="hljs-keyword">result</span>` r<br><span class="hljs-keyword">ON</span> s.StudentNo <span class="hljs-operator">=</span> r.StudentNo<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `subject` sub<br><span class="hljs-keyword">ON</span> r.`SubjectNo` <span class="hljs-operator">=</span> sub.`SubjectNo`<br><span class="hljs-keyword">WHERE</span> subjectName <span class="hljs-operator">=</span> `数据结构<span class="hljs-number">-1</span>`<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> StudentResult <span class="hljs-keyword">ASC</span><br></code></pre></td></tr></table></figure><blockquote><p>分页</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 分页</span><br><span class="hljs-comment">-- 语法：limit 起始值/偏移量，页面的大小</span><br><span class="hljs-keyword">SELECT</span> s.`StudentNo`, `StudentName`, `SubjectName`, `SubjectResult`<br><span class="hljs-keyword">FROM</span> student s<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `<span class="hljs-keyword">result</span>` r<br><span class="hljs-keyword">ON</span> s.StudentNo <span class="hljs-operator">=</span> r.StudentNo<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `subject` sub<br><span class="hljs-keyword">ON</span> r.`SubjectNo` <span class="hljs-operator">=</span> sub.`SubjectNo`<br><span class="hljs-keyword">WHERE</span> subjectName <span class="hljs-operator">=</span> `数据结构<span class="hljs-number">-1</span>`<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> StudentResult <span class="hljs-keyword">ASC</span><br>LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">5</span><br><br><span class="hljs-comment">-- 第一页 limit 0,5    (1-1)*5</span><br><span class="hljs-comment">-- 第二页 limit 5,5    (2-1)*5</span><br><span class="hljs-comment">-- 第三页 limit 10,5(3-1)*5</span><br><span class="hljs-comment">-- 第N页  limit        (n-1)*pageSize,pageSize</span><br><span class="hljs-comment">-- 【pageSize：页面大小】</span><br><span class="hljs-comment">-- 【(n-1)*pageSize：起始值】</span><br><span class="hljs-comment">-- 【n：当前页】</span><br><span class="hljs-comment">-- 【数据总数/页面大小 = 总页数】</span><br></code></pre></td></tr></table></figure><p>语法：<code>limit(查询起始下标，pageSize)</code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>本质：在where语句中嵌套一个子查询语句</p><p>where (select * from …)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询 数据库结构-1 的所有考试结果（学号，科目编号，成绩），降序排列</span><br><span class="hljs-comment">-- 方式一：使用连接查询</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,r.`SubjectNo`,`StudentResult`<br><span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">result</span>` r<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `subject` sub<br><span class="hljs-keyword">ON</span> r.SubjectNo <span class="hljs-operator">=</span> sub.SubjectNo<br><span class="hljs-keyword">WHERE</span> SubjectName <span class="hljs-operator">=</span> `数据库结构<span class="hljs-number">-1</span>`<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> StudentResult <span class="hljs-keyword">DESC</span><br><br><span class="hljs-comment">-- 方式二：使用子查询</span><br><span class="hljs-keyword">SELECT</span> `StudentNo`,`SubjectNo`,`StudentResult`<br><span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">result</span>`<br><span class="hljs-keyword">WHERE</span> SubjectNo <span class="hljs-operator">=</span> (<br><span class="hljs-keyword">SELECT</span> SubjectNo <span class="hljs-keyword">FROM</span> `subject`<br>    <span class="hljs-keyword">WHERE</span> SubjectName <span class="hljs-operator">=</span> `数据库结构<span class="hljs-number">-1</span>`<br>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> StudentResult <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><h2 id="4-MySQL函数"><a href="#4-MySQL函数" class="headerlink" title="4.MySQL函数"></a>4.MySQL函数</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 数学运算</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ABS</span>(<span class="hljs-number">-8</span>) <span class="hljs-comment">-- 绝对值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CEILING</span>(<span class="hljs-number">9.4</span>) <span class="hljs-comment">-- 向上取整</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">9.4</span>) <span class="hljs-comment">-- 向下取整</span><br><span class="hljs-keyword">SELECT</span> RAND() <span class="hljs-comment">-- 返回一个0~1之间的随机数</span><br><span class="hljs-keyword">SELECT</span> SIGN(<span class="hljs-number">-10</span>) <span class="hljs-comment">-- 判断一个数的符号 0-0 负数返回-1，正数返回1</span><br><br><span class="hljs-comment">-- 字符串函数</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CHAR_LENGTH</span>(<span class="hljs-string">&#x27;即使再小的帆也能远航&#x27;</span>) <span class="hljs-comment">-- 字符串长度</span><br><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;我&#x27;</span>,<span class="hljs-string">&#x27;爱&#x27;</span>,<span class="hljs-string">&#x27;coding&#x27;</span>) <span class="hljs-comment">-- 拼接字符串</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">INSERT</span>(<span class="hljs-string">&#x27;我爱coding&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&quot;热爱&quot;) <span class="hljs-comment">-- 查询，替换</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(<span class="hljs-string">&#x27;CZh&#x27;</span>) <span class="hljs-comment">-- 小写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;CZh&#x27;</span>) <span class="hljs-comment">-- 大写</span><br><span class="hljs-keyword">SELECT</span> INSTR(<span class="hljs-string">&#x27;CZh&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>) <span class="hljs-comment">-- 返回第一次出现的子串的索引</span><br><span class="hljs-keyword">SELECT</span> REPLACE(<span class="hljs-string">&#x27;坚持就能成功&#x27;</span>,<span class="hljs-string">&#x27;坚持&#x27;</span>,<span class="hljs-string">&#x27;努力&#x27;</span>) <span class="hljs-comment">-- 替换出现的指定字符串</span><br><span class="hljs-keyword">SELECT</span> SUBSTR(<span class="hljs-string">&#x27;坚持就能成功&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">-- 返回指定的子字符串(源字符串，截取的位置，截取的长度)</span><br><span class="hljs-keyword">SELECT</span> REVERSE(<span class="hljs-string">&#x27;坚持就能成功&#x27;</span>) <span class="hljs-comment">-- 反转</span><br><br><span class="hljs-comment">-- 时间和日期函数（记住）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_DATE</span>() <span class="hljs-comment">-- 获取当前日期</span><br><span class="hljs-keyword">SELECT</span> CURDATE() <span class="hljs-comment">-- 获取当前日期</span><br><span class="hljs-keyword">SELECT</span> NOW() <span class="hljs-comment">-- 获取当前时间</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOCALTIME</span>() <span class="hljs-comment">-- 本地时间</span><br><span class="hljs-keyword">SELECT</span> SYSDATE() <span class="hljs-comment">-- 系统时间</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(NOW())<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MONTH</span>(NOW())<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DAY</span>(NOW())<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">HOUR</span>(NOW())<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MINUTE</span>(NOW())<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SECOND</span>(NOW())<br><br><span class="hljs-comment">-- 系统</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SYSTEM_USER</span>()<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">USER</span>()<br><span class="hljs-keyword">SELECT</span> VERSION()<br></code></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td>计数</td></tr><tr><td>SUM()</td><td>求和</td></tr><tr><td>AVG()</td><td>平均值</td></tr><tr><td>MAX()</td><td>最大值</td></tr><tr><td>MIN()</td><td>最小值</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(studentname) <span class="hljs-keyword">FROM</span> student; <span class="hljs-comment">-- Count(指定列)，会忽略所有的null值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student; <span class="hljs-comment">-- Count(*)，不会忽略null值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span>;  <span class="hljs-comment">-- Count(1)，不会忽略所有的null值，本质：计算行数</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(`StudentResult`) <span class="hljs-keyword">AS</span> 总和 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(`StudentResult`) <span class="hljs-keyword">AS</span> 平均分 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(`StudentResult`) <span class="hljs-keyword">AS</span> 最高分 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(`StudentResult`) <span class="hljs-keyword">AS</span> 最低分 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><br><span class="hljs-comment">-- 查询不同课程的平均分，最高分，最低分，平均分大于80</span><br><span class="hljs-comment">-- 核心：根据不同的课程分组</span><br><span class="hljs-keyword">SELECT</span> SubjectName,<span class="hljs-built_in">AVG</span>(StudentResult) <span class="hljs-keyword">AS</span> 平均分,<span class="hljs-built_in">MAX</span>(StudentResult) <span class="hljs-keyword">AS</span> 最高分,<span class="hljs-built_in">MIN</span>(StudentResult) <span class="hljs-keyword">AS</span> 最低分<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span> r<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `suject` sub<br><span class="hljs-keyword">ON</span> r.`SubjectNo` <span class="hljs-operator">=</span> sub.`SubjectNo`<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> r.SubjectNo <span class="hljs-comment">-- 通过什么字段来分组</span><br><span class="hljs-keyword">HAVING</span> 平均分<span class="hljs-operator">&gt;</span><span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="数据库级别的MD5加密"><a href="#数据库级别的MD5加密" class="headerlink" title="数据库级别的MD5加密"></a>数据库级别的MD5加密</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 加密</span><br><span class="hljs-keyword">UPDATE</span> testmd5 <span class="hljs-keyword">SET</span> pwd<span class="hljs-operator">=</span>MD5(pwd) <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> testmd5 <span class="hljs-keyword">SET</span> pwd<span class="hljs-operator">=</span>MD5(pwd) <span class="hljs-comment">-- 加密全部的密码</span><br><br><span class="hljs-comment">-- 插入的时候加密</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> testmd5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;xiaoming&#x27;</span>, MD5(<span class="hljs-string">&#x27;123456&#x27;</span>))<br><br><span class="hljs-comment">-- 如何校验：将用户传递进来的密码，进行md5加密，然后对比加密后的值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> testmd5 <span class="hljs-keyword">WHERE</span> `name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xiaoming&#x27;</span> <span class="hljs-keyword">AND</span> pwd<span class="hljs-operator">=</span>MD5(<span class="hljs-string">&#x27;123456&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h2><blockquote><p>事务原则：ACID原则 原子性、一致性、隔离性、持久性</p></blockquote><p><strong>原子性（Atomicity）</strong></p><p>要么都成功，要么都失败</p><p><strong>一致性（Consistency）</strong></p><p>事务前后的数据完整性要保持一致</p><p><strong>隔离性（Isolation）</strong></p><p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰</p><p><strong>持久性（Durability）</strong></p><p>事务一旦提交则不可逆，被持久化到数据库中</p><blockquote><p>隔离所导致的一些问题</p></blockquote><p><strong>脏读：</strong></p><p>指一个事务读取了另一个事务未提交的数据。</p><p><strong>不可重复读：</strong></p><p>在一个事务内读取表中的某一行数据，多次读取结果不同。</p><p><strong>虚读（幻读）：</strong></p><p>是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL默认开启事务自动提交</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">/* 关闭 */</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">/* 开启（默认的）*/</span><br><br><span class="hljs-comment">-- 手动处理事务</span><br><br><span class="hljs-comment">-- 事务开启</span><br><span class="hljs-keyword">START</span> TRANSACTION <span class="hljs-comment">-- 标记一个事务的开始，从这个之后的sql都在同一个事务内</span><br><br><span class="hljs-comment">-- 提交：持久化，数据已提交就不能回滚了</span><br><span class="hljs-keyword">COMMIT</span><br><span class="hljs-comment">-- 回滚：回到原来的样子</span><br><span class="hljs-keyword">ROLLBACK</span><br><br><span class="hljs-comment">-- 事务结束</span><br><br><br><span class="hljs-keyword">SAVEPOINT</span> 保存点名  <span class="hljs-comment">-- 设置一个事务的保存点</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> 保存点名 <span class="hljs-comment">-- 回滚到保存点</span><br><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> 保存点名 <span class="hljs-comment">-- 释放保存点</span><br></code></pre></td></tr></table></figure><h2 id="6-索引"><a href="#6-索引" class="headerlink" title="6.索引"></a>6.索引</h2><blockquote><p>MySQL官方对索引的定义为：<strong>索引（index）是帮助MySQL高效获取数据的数据结构。</strong></p><p>提取句子主干，就可以得到索引的本质：<strong>索引是数据结构</strong></p></blockquote><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>主键索引（PRIMARY KEY）<ul><li>唯一的标识，主键不可重复，只能有一个列作为主键</li></ul></li><li>唯一索引（UNIQUE KEY）<ul><li>索引列的值必须唯一，唯一索引可以重复，多个列都可以标识为唯一索引</li></ul></li><li>普通索引（KEY&#x2F;INDEX）<ul><li>默认的，index，key关键字来设置</li></ul></li><li>全文索引（FullText）<ul><li>在特定的数据库引擎下才有，如MyISAM</li><li>快速定位数据</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 索引的使用</span><br><span class="hljs-comment">-- 1.在创建表的时候给字段增加索引</span><br><span class="hljs-comment">-- 2.创建完毕后，增加索引</span><br><br><span class="hljs-comment">-- 显示所有的索引信息</span><br><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> student<br><br><span class="hljs-comment">-- 增加一个全文索引（索引名）列名</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> school.student <span class="hljs-keyword">ADD</span> FULLTEXT INDEX `studentName`(`studentName`);<br><br><span class="hljs-comment">-- EXPLAIN分析sql执行的状况</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student; <span class="hljs-comment">-- 非全文索引</span><br><br></code></pre></td></tr></table></figure><blockquote><p>测试索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入100万条数据</span><br>DELIMITER $$ <span class="hljs-comment">-- 写函数前必须要写</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> mock_data()<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> num <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1000000</span>;<br><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">WHERE</span> i<span class="hljs-operator">&lt;</span>num DO<br><span class="hljs-comment">-- 插入语句</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>...<br><span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span> WHILE<br><span class="hljs-keyword">END</span>;<br><span class="hljs-keyword">SELECT</span> mock_data()<br></code></pre></td></tr></table></figure><h3 id="索引原则"><a href="#索引原则" class="headerlink" title="索引原则"></a>索引原则</h3><ul><li>索引不是越多越好</li><li>不要对经常变动的数据加索引</li><li>小数据量的表不需要加索引</li><li>索引一般加在常用来查询的字段上</li></ul><blockquote><p>索引的数据结构</p></blockquote><p>Btree：InnoDB的默认数据结构</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">CodingLabs - MySQL索引背后的数据结构及算法原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/113917726">深入理解 Mysql 索引底层原理 - 知乎 (zhihu.com)</a></p><p>索引最终选择B+树的原因:</p><ol><li><p>hash很快，但每次IO只能取一个数</p></li><li><p>AVL和红黑树，在大量数据的情况下，IO操作还是太多</p></li><li><p>B树每个节点内存储的是数据，因此每个节点存储的分支太少</p></li><li><p>B+节点存储的是索引+指针(引用指向下一个节点)，可以存储大量索引，同时最终数据存储在叶子节点，并且有引用横向链接，可以在2-3次的IO操作内完成千万级别的表操作。</p></li><li><p>建议索引是是自增长数字，这样适合范围查找</p></li></ol><p><a href="https://www.jianshu.com/p/fa8192853184">聚簇索引与非聚簇索引（也叫二级索引） - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/mffandxx/article/details/111916252">索引知识系列二：联合索引、索引覆盖和索引下推详解_程序编织梦想的博客-CSDN博客_索引覆盖和索引下推</a></p><h2 id="权限管理和备份"><a href="#权限管理和备份" class="headerlink" title="权限管理和备份"></a>权限管理和备份</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建用户</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 用户名 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>;<br><br><span class="hljs-comment">-- 修改密码（修改当前用户密码）</span><br><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-operator">=</span> PASSWORD(<span class="hljs-string">&#x27;123456&#x27;</span>);<br><br><span class="hljs-comment">-- 修改密码（修改指定用户密码）</span><br><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-keyword">FOR</span> 用户名 <span class="hljs-operator">=</span> PASSWORD(<span class="hljs-string">&#x27;123456&#x27;</span>)<br><br><span class="hljs-comment">-- 重命名</span><br>RENAME <span class="hljs-keyword">USER</span> 原名 <span class="hljs-keyword">TO</span> 新名字<br><br><span class="hljs-comment">-- 用户授权</span><br><span class="hljs-comment">-- ALL PRIVILEGES除了给别人授权，其他都能干</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> 用户名<br><br><span class="hljs-comment">-- 查询权限</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> 用户名 <span class="hljs-comment">-- 查看指定用户的权限</span><br><br><span class="hljs-comment">-- 撤销权限</span><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 用户名<br><br></code></pre></td></tr></table></figure><h3 id="MySQL备份"><a href="#MySQL备份" class="headerlink" title="MySQL备份"></a>MySQL备份</h3><p>命令行导出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># mysqldump <span class="hljs-operator">-</span>h 主机 <span class="hljs-operator">-</span>u 用户名 <span class="hljs-operator">-</span>p 密码 数据库 表名 <span class="hljs-operator">&gt;</span> 物理磁盘位置<br>mysqldump <span class="hljs-operator">-</span>hlocalhost <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p123456 school student <span class="hljs-operator">&gt;</span>D:<span class="hljs-operator">/</span>a.sql<br><br># 导入<br># 登录的情况下，切换到指定的数据库<br>source d:<span class="hljs-operator">/</span>a.sql<br><br></code></pre></td></tr></table></figure><h2 id="数据库的归约，三大范式"><a href="#数据库的归约，三大范式" class="headerlink" title="数据库的归约，三大范式"></a>数据库的归约，三大范式</h2><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">MySQL ：： MySQL 5.7 参考手册 ：： 8.8.2 EXPLAIN 输出格式</a></p><blockquote><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或表结构的性能瓶颈。</p></blockquote><p>用法：explain + sql语句</p><p>能够知道：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以被使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p>表包含的字段如下：</p><p><img src="/2021/08/06/MySQL%E5%9F%BA%E7%A1%80/image-20210715114955960.png" alt="explain输出字段"></p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><blockquote><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p></blockquote><p>三种情况：</p><ul><li>id相同，执行顺序由上至下</li><li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。</li><li>id相同与不同同时存在，id相同的从上往下循序执行，id越大，优先级越高，越先执行。</li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><ul><li><strong>SIMPLE</strong>：简单的select查询，查询中不包含子查询或者UNION。</li><li><strong>PRIMARY</strong>：查询中若包含任何复杂的子查询，最外层查询则标记为PRIMARY。</li><li><strong>SUBQUERY</strong>：在select或where列表中包含的子查询。</li><li><strong>DERIVED</strong>：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表里。</li><li><strong>UNION</strong>：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。</li><li><strong>UNION RESULT</strong>：从UNION表获取结果的SELECT。</li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>显示这一行的数据是关于哪张表的</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>访问类型排列</p><p>显示查询使用了何种类型</p><p><font color='FF0000'>从最好到最差依次是：</font></p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>简化如下：</p><p>system-&gt;const-&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><ul><li><p><strong>system</strong>：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可忽略不计</p></li><li><p><strong>const</strong>：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</p></li><li><p><strong>eq_ref</strong>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</p></li><li></li></ul><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>提示使用哪个索引会在该表中找到行，不太重要</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>MYSQL使用的索引，简单且重要</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>MYSQL使用的索引长度</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref列显示使用哪个列或常数与key一起从表中选择行。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>显示MYSQL执行查询的行数，简单且重要，数值越大越不好，说明没有用好索引</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>按表条件筛选的行的百分比</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>该列包含MySQL解决查询的详细信息。</p><h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html">MySQL ：： MySQL 8.0 参考手册 ：： 15.3 InnoDB 多版本控制</a>（官方文档，推荐）</p><p><a href="https://www.jianshu.com/p/654773e14c38">Mysql中的MVCC - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/Tomwildboar/article/details/121064240">MySQL，MVCC详解，快照读在RC、RR下的区别_小道仙97的博客-CSDN博客_mysql rc 快照读</a></p><p><a href="https://mp.weixin.qq.com/s/JFjFs_7xduCmHOegbJ-Gbg">招银面试官，听说你精通 MySQL，我们来大战 66 回合 (qq.com)</a>（有某些错误）</p><h2 id="char与varchar的区别"><a href="#char与varchar的区别" class="headerlink" title="char与varchar的区别"></a>char与varchar的区别</h2><p><a href="https://blog.csdn.net/bigwood99/article/details/114981705">闲谈MySQL的char和varchar</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/char.html">MySQL :: MySQL 8.0 Reference Manual :: 11.3.2 The CHAR and VARCHAR Types</a></p><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><ul><li>char 表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比 varchar 快很多，甚至能快 50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li><li>对于 char 来说，最多能存放的字符个数为 255，和编码无关</li></ul><h3 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h3><ul><li>varchar 表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于 varchar 来说，最多能存放的字符个数为 65535 ，但这个值是理论值，实际比这个少，因为字符开头会使用1-2个字节记录字符串长度</li></ul><h3 id="重要"><a href="#重要" class="headerlink" title="重要"></a><strong>重要</strong></h3><p>一般认为，char是定长字符，varchar是可变长度字符。</p><p>在MySQL版本4.12以后，这种说法就不完全正确了。在4.12版之后，char(n)中的n代表的不再是字节长度，而是字符长度。在这个改变下，如果字符集选择的是多字节字符集，比如utf-8，那么char(n)则存储的数据就不是固定长度了。</p><p>例如，char(3)可以存储“abc”、“一二三”。显然，前面两个字符串的字节长度是不一样的。</p><p>所以只有当字符集选择了单字节字符集，比如latin1，char是固定长度。在使用多字节字符集时，char则被当作vachar类型。</p><p>这一问题是很多程序员容易忽略的。</p><p>另一个容易忽略的问题是varchar最大能存储多长字节。官方资料显示是65536，但是如果你定义一个varchar长度65535是会报错的。</p><p>实际测试，最大值是65532。这里又隐藏了一个问题，如果字符集是utf-8，定义varchar(65532)还是会报错的。因为varchar(n)中的n指的是字符长度。</p><p>日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更合适一些。</p><h2 id="blob-和-text-有什么区别"><a href="#blob-和-text-有什么区别" class="headerlink" title="blob 和 text 有什么区别"></a>blob 和 text 有什么区别</h2><ul><li>blob 用于存储二进制数据，而 text 用于存储大字符串。</li><li>blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较</li></ul><h2 id="DATETIME-和-TIMESTAMP-的异同"><a href="#DATETIME-和-TIMESTAMP-的异同" class="headerlink" title="DATETIME 和 TIMESTAMP 的异同"></a>DATETIME 和 TIMESTAMP 的异同</h2><p><strong>相同点</strong>：</p><ol><li>两个数据类型存储时间的表现格式一致。均为 <code>YYYY-MM-DD HH:MM:SS</code></li><li>两个数据类型都包含「日期」和「时间」部分。</li><li>两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）</li></ol><p><strong>区别</strong>：</p><ol><li><p><strong>日期范围</strong>：DATETIME 的日期范围是 <code>1000-01-01 00:00:00.000000</code> 到 <code>9999-12-31 23:59:59.999999</code>；TIMESTAMP 的时间范围是<code>1970-01-01 00:00:01.000000</code> UTC <code>到 ``2038-01-09 03:14:07.999999</code> UTC</p></li><li><p><strong>存储空间</strong>：在5.6.4之前，datetime存储占用8个字节，而timestamp是占用4字节；但是在5.6.4之后，由于这两个类型允许有小数部分，所以占用的存储空间和以前不同；MySQL规范规定，datetime的非小数部分需要5个字节，而不是8个字节，而timestamp的非小数部分是需要4个字节，并且这两个部分的小数部分都需要0到3个字节，具体取决于存储值的小数秒精度。</p></li><li><p><strong>时区相关</strong>：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区</p></li><li><p><strong>默认值</strong>：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)</p></li></ol><h2 id="MySQL-中-in-和-exists-的区别"><a href="#MySQL-中-in-和-exists-的区别" class="headerlink" title="MySQL 中 in 和 exists 的区别"></a>MySQL 中 in 和 exists 的区别</h2><p>MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实是不准确的，要区分情景：</p><ol><li>如果查询的两个表大小相当，那么用 in 和 exists 差别不大。</li><li>如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。</li><li>not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。</li></ol><h2 id="drop、truncate和delete的区别"><a href="#drop、truncate和delete的区别" class="headerlink" title="drop、truncate和delete的区别"></a>drop、truncate和delete的区别</h2><table><thead><tr><th>区别点</th><th>drop</th><th>truncate</th><th>delete</th></tr></thead><tbody><tr><td>执行速度</td><td>快</td><td>较快</td><td>慢</td></tr><tr><td>命令分类</td><td>DDL（数据定义语言）</td><td>DDL（数据定义语言）</td><td>DML（数据操作语言）</td></tr><tr><td>删除对象</td><td><strong>删除整张表和表结构</strong>，以及表的索引、约束和触发器。</td><td><strong>只删除表数据</strong>，表的结构、索引、约束等会被保留。</td><td><strong>只删除表的全部或部分数据</strong>，表结构、索引、约束等会被保留。</td></tr><tr><td>删除条件（where）</td><td>不能用</td><td>不能用</td><td>可使用</td></tr><tr><td>回滚</td><td>不可回滚</td><td>不可回滚</td><td>可回滚</td></tr><tr><td>自增初始值</td><td>-</td><td>重置</td><td>不重置</td></tr></tbody></table><h2 id="count-1-、count-与-count-列名-的区别"><a href="#count-1-、count-与-count-列名-的区别" class="headerlink" title="count(1)、count(*) 与 count(列名) 的区别"></a>count(1)、count(*) 与 count(列名) 的区别</h2><p><strong>执行效果</strong>：</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL</li><li>count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。</li></ul><p><strong>执行速度</strong>：</p><ul><li>列名为主键，count(列名)会比 count(1)快</li><li>列名不为主键，count(1)会比 count(列名)快</li><li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count（*）最优。</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/2021/08/06/MySQL%E5%9F%BA%E7%A1%80/image-20220902113957460.png" alt="B+树"></p><p><a href="https://www.cnblogs.com/juniorMa/p/13589501.html">InnoDb页结构 - MaXianZhe - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/MAYHENG/article/details/106575604">Mysql数据读取方式以及InnoDb页存储</a></p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><a href="https://blog.csdn.net/weixin_41814871/article/details/124996364">一文详解脏读、不可重复读、幻读</a></p><p><img src="/2021/08/06/MySQL%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="事务隔离级别"></p><p>在RR级别下面不会产生 不可重复读，之所以不会产生 不可重复读，是快照读在RC和RR下的生成的策略不一样。</p><p>RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p><h2 id="MySQL模糊查询再也用不着-like-了！"><a href="#MySQL模糊查询再也用不着-like-了！" class="headerlink" title="MySQL模糊查询再也用不着 like+% 了！"></a><a href="https://mp.weixin.qq.com/s/ScJAgUkLHGpmTDS9KlZDBA">MySQL模糊查询再也用不着 like+% 了！</a></h2><h2 id="聚簇索引与非聚簇索引（也叫二级索引）"><a href="#聚簇索引与非聚簇索引（也叫二级索引）" class="headerlink" title="聚簇索引与非聚簇索引（也叫二级索引）"></a><a href="https://www.jianshu.com/p/fa8192853184">聚簇索引与非聚簇索引（也叫二级索引）</a></h2><h2 id="索引知识系列二：联合索引、覆盖索引（covering-index）和索引条件下推（index-condition-pushdown-icp）详解"><a href="#索引知识系列二：联合索引、覆盖索引（covering-index）和索引条件下推（index-condition-pushdown-icp）详解" class="headerlink" title="索引知识系列二：联合索引、覆盖索引（covering index）和索引条件下推（index condition pushdown, icp）详解"></a><a href="https://blog.csdn.net/mffandxx/article/details/111916252">索引知识系列二：联合索引、覆盖索引（covering index）和索引条件下推（index condition pushdown, icp）详解</a></h2><h2 id="Innodb是如何实现事务的"><a href="#Innodb是如何实现事务的" class="headerlink" title="Innodb是如何实现事务的"></a>Innodb是如何实现事务的</h2><p>Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以一个update语句为例</p><ol><li>Innodb在收到一个update语句后，会先根据条件查找到数据所在的页，并将该页缓存在Buffer Pool中</li><li>执行update语句，修改Buffer Pool中的数据，也就是内存中的数据</li><li>针对update语句生成一个RedoLog对象并存入LogBuffer中</li><li>针对update语句生成UndoLog日志，用于事务回滚</li><li>如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中</li><li>如果事务回滚，则利用undolog日志进行回滚</li></ol><h2 id="mysql-插入加锁-MySQL锁-山东石头的博客-CSDN博客"><a href="#mysql-插入加锁-MySQL锁-山东石头的博客-CSDN博客" class="headerlink" title="mysql 插入加锁_MySQL锁_山东石头的博客-CSDN博客"></a><a href="https://blog.csdn.net/weixin_34553861/article/details/112380759">mysql 插入加锁_MySQL锁_山东石头的博客-CSDN博客</a></h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2021/08/06/JVM/"/>
    <url>/2021/08/06/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><ul><li>请你谈谈对JVM的理解？java8虚拟机和之前的变化更新？</li><li>什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？</li><li>JVM的常用调优参数有哪些？</li><li>内存快照如何抓取，怎么分析Dump文件？</li><li>谈谈JVM中，类加载器的认识？</li></ul><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification (oracle.com)</a>（官方文档）</p><p><a href="https://blog.csdn.net/zcl_love_wx/article/details/124511124">【JVM系列】JVM内存区域（JVM运行时数据区域)_bug师姐的博客-CSDN博客_jvm内存区域</a></p><p><a href="https://blog.csdn.net/y_eatmeat/article/details/122915625?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-122915625-blog-124511124.wap_blog_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=1">JVM内存区域详解_ITenderL的博客-CSDN博客_jvm内存区域</a></p><h2 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h2><p><img src="/2021/08/06/JVM/2019040912492050.png" alt="JVM体系结构"></p><p><img src="/2021/08/06/JVM/20170610165140237.png" alt="JVM架构图"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>作用：加载Class文件</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><img src="/2021/08/06/JVM/7634245-7b7882e1f4ea5d7d.png" alt="双亲委派机制"></p><ol><li>类加载器收到类加载的请求。</li><li>将这个请求向上委托给父加载器去完成，一直向上委托，直到启动类加载器。</li><li>启动类加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则抛出异常，通知子加载器进行加载。</li><li>重复。</li></ol><p><strong>作用</strong></p><ol><li>防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</li><li>保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.clas</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>​Java安全模型的核心是Java沙箱（sandbox），沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱<strong>主要限制系统资源访问</strong>，系统资源包括CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>​所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><p>​在Java中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（sandbox）机制。</p><p>JDK1.0安全模型如下：</p><p><img src="/2021/08/06/JVM/20201122130153848.png" alt="JDK1.0安全模型"></p><p>​严格的安全机制给程序的扩展带来了障碍，如用户希望远程代码访问本地系统文件时，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<code>安全策略</code>，允许用户指定代码对本地资源的访问权限。</p><p>JDK1.1安全模型如下：</p><p><img src="/2021/08/06/JVM/20201122130059715.png" alt="JDK1.1安全模型"></p><p>​在Java1.2版本中，再次改进了安全机制，增加了<code>代码签名</code>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化代码执行权限控制。</p><p>JDK1.2安全模型如下：</p><p><img src="/2021/08/06/JVM/20201122125952373.png" alt="JDK1.2安全模型"></p><p>​当前最新的安全机制实现引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就有了当前域的全部权限。</p><p>最新安全模型（jdk1.6）</p><p><img src="/2021/08/06/JVM/20201122125459801.png" alt="JDK1.6安全模型"></p><h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><p>​使用native关键字说明这个方法是原生函数，也就是这个方法是用C&#x2F;C++语言实现的，并且被编译成了DLL，由java去调用。<br>​这些函数的实现体在DLL中，JDK的源代码中并不包含。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p><h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><p>程序计数器：Program Counter Register</p><p>​每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条指令的地址），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>Method Area方法区</p><p>​方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊的方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，<strong>此区域属于共享空间</strong>；</p><p>​<strong>静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。</strong></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出、后进先出</p><h2 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h2><ul><li>Sun公司 <code>HotSpot</code></li><li>BEA <code>JRockit</code></li><li>IBM <code>J9 VM</code></li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</p><p>类加载器读取了类文件后，把类、方法、常量、变量放到堆中，保存我们所有引用类型的真实对象。</p><p>堆内存中细分为三个区域：</p><ul><li>年轻代</li><li>老年代</li><li>永久代（jdk1.8后为 元空间(Metaspace)，元空间不在堆中）</li></ul><pre><code class=" mermaid">graph LRa[堆内存] --&gt; b[年轻代]a --&gt; c[老年代]b --&gt; d[伊甸园区Eden]b --&gt; e[幸存区Srvivor]e --&gt; f[From Survivor空间/幸存0区]e --&gt; g[To Survivor空间/幸存1区]</code></pre><h3 id="年轻代（YoungGen）"><a href="#年轻代（YoungGen）" class="headerlink" title="年轻代（YoungGen）"></a>年轻代（YoungGen）</h3><ul><li>类：诞生和成长的地方，甚至死亡</li><li>伊甸园区，所有对象都是在 伊甸园 区new出来的</li><li>幸存者区（0区，1区）</li></ul><h3 id="老年代-OldGen"><a href="#老年代-OldGen" class="headerlink" title="老年代(OldGen)"></a>老年代(OldGen)</h3><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>这个区域常驻内存，用来存放JDK自身携带的Class对象，存储的是java运行时的一些环境或类信息，这个区域不存在垃圾回收，关闭VM就会释放这个区域的内存。</p><ul><li>jdk1.6之前：永久代，常量池在方法区</li><li>jdk1.7：永久代，常量池在堆中</li><li>jdk1.8之后：无永久代，常量池在元空间</li></ul><h2 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h2><p>Jprofiler</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>垃圾回收</p><p>常用算法</p><ul><li>标记清除法</li><li>标记压缩法</li><li>复制算法</li><li>引用计数法</li></ul><h2 id="阅读官方文档"><a href="#阅读官方文档" class="headerlink" title="阅读官方文档"></a>阅读官方文档</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p><p><img src="/2021/08/06/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="运行时数据区"></p><h3 id="2-5运行时数据区"><a href="#2-5运行时数据区" class="headerlink" title="2.5运行时数据区"></a>2.5运行时数据区</h3><p>Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。这些数据区域中的一些是在Java虚拟机启动时创建的，并且只有当Java虚拟机退出时才会被销毁。其他数据区域为每个线程。每线程数据区域在创建线程时创建，在线程退出时销毁。</p><h4 id="2-5-1-pc寄存器（The-pc-Register）"><a href="#2-5-1-pc寄存器（The-pc-Register）" class="headerlink" title="2.5.1.pc寄存器（The pc Register）"></a>2.5.1.pc寄存器（The pc Register）</h4><p>Java虚拟机可以同时支持多个执行线程（JLS§17）。每个Java虚拟机线程都有自己的pc（程序计数器）寄存器。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法（§2.6）。如果该方法不是本机的，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前正在执行的方法是本地的，则Java虚拟机的pc寄存器的值是未定义的。Java虚拟机的pc寄存器足够宽，可以在特定平台上保存返回地址或本地指针。</p><h4 id="2-5-2-java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#2-5-2-java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="2.5.2.java虚拟机栈（Java Virtual Machine Stacks）"></a>2.5.2.java虚拟机栈（Java Virtual Machine Stacks）</h4><p>每个Java虚拟机线程都有一个与线程同时创建的私有Java虚拟机栈。Java虚拟机栈存储帧（§2.6）。Java虚拟机栈类似于传统语言（如C）的栈：它保存局部变量和部分结果，并在方法调用和返回中发挥作用。因为除了推送和弹出帧之外，Java虚拟机栈从未被直接操作，所以可以对帧进行堆分配。Java虚拟机栈的内存不需要是连续的。<br>在Java®虚拟机规范的第一版中，Java虚拟机栈称为Java栈。<br>该规范允许Java虚拟机栈具有固定大小，或者根据计算需要动态扩展和收缩。如果Java虚拟机栈具有固定大小，则可以在创建该栈时独立地选择每个Java虚拟机栈的大小。<br>Java虚拟机实现可以为程序员或用户提供对Java虚拟机栈初始大小的控制，以及在动态扩展或收缩Java虚拟机栈的情况下，对最大和最小大小的控制。<br>以下例外情况与Java虚拟机堆栈相关：<br>如果线程中的计算需要比允许的更大的Java虚拟机栈，则Java虚拟机将抛出StackOverflowerError。<br>如果可以动态扩展Java虚拟机堆栈，并且尝试了扩展，但没有足够的内存来实现扩展，或者如果没有足够的可用内存来为新线程创建初始Java虚拟机栈，则Java虚拟机将抛出OutOfMemoryError。</p><h4 id="2-5-3-堆（Heap）"><a href="#2-5-3-堆（Heap）" class="headerlink" title="2.5.3.堆（Heap）"></a>2.5.3.堆（Heap）</h4><p>Java虚拟机具有在所有Java虚拟机线程之间共享的堆。堆是运行时数据区域，从中为所有类实例和数组分配内存。<br>堆是在虚拟机启动时创建的。对象的堆存储由自动存储管理系统（称为垃圾收集器）回收；对象从不显式解除分配。Java虚拟机假设没有特定类型的自动存储管理系统，并且可以根据实现者的系统需求来选择存储管理技术。堆可以具有固定大小，或者可以根据计算需要进行扩展，并且如果不需要更大的堆，则可以收缩。堆的内存不需要是连续的。<br>Java虚拟机实现可以为程序员或用户提供对堆的初始大小的控制，以及如果堆可以动态扩展或收缩，则提供对最大和最小堆大小的控制。<br>以下异常情况与堆关联：<br>如果计算需要的堆超过自动存储管理系统的可用堆，Java虚拟机将抛出OutOfMemoryError。</p><h4 id="2-5-4-方法区（Method-Area）"><a href="#2-5-4-方法区（Method-Area）" class="headerlink" title="2.5.4.方法区（Method Area）"></a>2.5.4.方法区（Method Area）</h4><p>Java虚拟机具有在所有Java虚拟机线程之间共享的方法区域。方法区域类似于常规语言编译代码的存储区域，或类似于操作系统进程中的“文本”段。它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法（§2.9）。<br>方法区域在虚拟机启动时创建。虽然方法区域在逻辑上是堆的一部分，但简单的实现可能选择不进行垃圾收集或压缩。本规范不规定方法区域的位置或用于管理编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，可以进行收缩。方法区域的内存不需要是连续的。<br>Java虚拟机实现可以向程序员或用户提供对方法区域的初始大小的控制，以及在大小变化的方法区域的情况下，对最大和最小方法区域大小的控制。<br>以下异常情况与方法区域相关：<br>如果方法区域中的内存无法满足分配请求，Java虚拟机将抛出OutOfMemoryError。</p><h4 id="2-5-5-运行时常量池（Run-Time-Constant-Pool）"><a href="#2-5-5-运行时常量池（Run-Time-Constant-Pool）" class="headerlink" title="2.5.5.运行时常量池（Run-Time Constant Pool）"></a>2.5.5.运行时常量池（Run-Time Constant Pool）</h4><p>运行时常量池是类文件中常量池表的每类或每界面的运行时表示（§4.4）。它包含几种常量，从编译时已知的数字字面到必须在运行时解决的方法和字段引用。运行时常量池的功能类似于传统编程语言的符号表，尽管它包含的数据范围比典型的符号表要广。</p><p>每个运行时常量池都是从 Java 虚拟机的方法区分配的（§2.5.4）。一个类或接口的运行时常量池是在Java虚拟机创建该类或接口时构建的（§5.3）。</p><p>以下是与类或接口的运行时常量池的构建相关的特殊条件。</p><p>在创建类或接口时，如果构建运行时常量池所需的内存超过了 Java 虚拟机的方法区所能提供的内存，Java 虚拟机会抛出 OutOfMemoryError。</p><p>关于运行时常量池的构建信息，请参见第5节（加载、链接和初始化）。</p><h4 id="2-5-6-本地方法栈（Native-Method-Stacks）"><a href="#2-5-6-本地方法栈（Native-Method-Stacks）" class="headerlink" title="2.5.6.本地方法栈（Native Method Stacks）"></a>2.5.6.本地方法栈（Native Method Stacks）</h4><p>Java虚拟机的实现可以使用常规堆栈，俗称 “C堆栈”，以支持本地方法（用Java编程语言以外的语言编写的方法）。本机方法栈也可以由Java虚拟机指令集的解释器实现使用，如C语言。Java虚拟机实现不能加载本机方法，而且本身不依赖传统的栈，不需要提供本机方法栈。如果提供，本地方法栈通常在每个线程创建时分配。</p><p>本规范允许本地方法堆栈具有固定的大小，或者根据计算的需要动态地扩展和收缩。如果本地方法栈是固定大小的，每个本地方法栈的大小可以在创建该栈时独立选择。</p><p>Java虚拟机实现可以为程序员或用户提供对本地方法栈初始大小的控制，以及在不同大小的本地方法栈的情况下，对最大和最小方法栈大小的控制。</p><p>以下是与本地方法栈相关的特殊情况。</p><p>如果一个线程中的计算需要比允许的更大的本地方法栈，Java虚拟机会抛出一个StackOverflowError。</p><p>如果本地方法堆栈可以动态扩展，并且试图进行本地方法堆栈扩展，但可以提供的内存不足，或者可以提供的内存不足以为一个新线程创建初始本地方法堆栈，则Java虚拟机会抛出OutOfMemoryError。</p><h3 id="2-6-帧（Frames）"><a href="#2-6-帧（Frames）" class="headerlink" title="2.6.帧（Frames）"></a>2.6.帧（Frames）</h3><p><em>帧</em>用于存储数据和部分结果，以及执行动态链接、返回方法值和调度异常。</p><p>每次调用方法时都会创建一个新帧。当帧的方法调用完成时，无论该完成是正常还是突然（它会引发未捕获的异常），帧都会被销毁。帧是从创建帧的线程的 Java 虚拟机堆栈 （<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2">§2.5.2</a>） 中分配的。每个帧都有自己的局部变量数组 （<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.1">§2.6.1</a>）、自己的操作数堆栈 （<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6.2">§2.6.2</a>） 以及对当前方法类的运行时常量池 （<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5">§2.5.5</a>） 的引用。</p><p>可以使用其他特定于实现的信息（如调试信息）扩展帧。</p><p>局部变量数组和操作数堆栈的大小在编译时确定，并与与帧关联的方法的代码一起提供 （<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">§4.7.3</a>）。因此，帧数据结构的大小仅取决于 Java 虚拟机的实现，并且这些结构的内存可以在方法调用时同时分配。</p><p>在给定的控制线程中的任何点，只有一个帧（执行方法的帧）处于活动状态。此帧称为<em>当前帧</em>，其方法称为<em>当前方法</em>。在其中定义当前方法的类是<em>当前类</em>。对局部变量和操作数堆栈的操作通常参考当前帧。</p><p>如果帧的方法调用另一个方法或其方法完成，则该帧将不再是最新的。调用方法时，将创建一个新帧，并在控件转移到新方法时变为当前帧。在方法返回时，当前帧将其方法调用的结果（如果有）传递回上一帧。然后，当前一帧变为当前帧时，将丢弃当前帧。</p><p>请注意，由线程创建的帧是该线程的本地帧，不能被任何其他线程引用。</p><h4 id="2-6-1局部变量（Local-Variables）"><a href="#2-6-1局部变量（Local-Variables）" class="headerlink" title="2.6.1局部变量（Local Variables）"></a>2.6.1局部变量（Local Variables）</h4><p>每个帧（§2.6）包含一个称为局部变量的变量数组。帧的局部变量数组的长度在编译时确定，并以类或接口的二进制表示形式提供，以及与帧相关的方法的代码（§4.7.3）。<br>单个局部变量可以保存boolean、byte、char、short、int、float、reference或returnAddress类型的值。一对局部变量可以保存long或double类型的值。<br>局部变量通过索引处理。第一个局部变量的索引为零。当且仅当整数小于局部变量数组的大小介于0和1之间时，整数才被视为局部变量数组中的索引。<br>long或double类型的值占用两个连续的局部变量。这样的值只能使用较小的索引来寻址。例如，存储在索引n处的局部变量数组中的double类型的值实际上占据了索引n和n+1的局部变量；但是，无法从中加载索引n+1处的局部变量。它可以存储到。但是，这样做会使局部变量n的内容无效。<br>Java虚拟机不要求n为偶数。根据直觉，long和double类型的值不需要在局部变量数组中对齐64位。实现者可以自由决定使用为值保留的两个局部变量来表示这些值的适当方式。<br>Java虚拟机使用局部变量在方法调用时传递参数。在类方法调用中，任何参数都从局部变量0开始以连续的局部变量传递。在实例方法调用时，局部变量0始终用于传递对调用实例方法的对象的引用（这在Java编程语言中）。任何参数随后在从局部变量1开始的连续局部变量中传递。</p><h4 id="2-6-2-操作数栈（Operand-Stacks）"><a href="#2-6-2-操作数栈（Operand-Stacks）" class="headerlink" title="2.6.2.操作数栈（Operand Stacks）"></a>2.6.2.操作数栈（Operand Stacks）</h4><p>每个帧（§2.6）包含一个后进先出（LIFO）堆栈，称为其操作数堆栈。帧的操作数堆栈的最大深度在编译时确定，并与帧相关方法的代码一起提供（§4.7.3）。</p><p>在上下文清楚的情况下，我们有时将当前帧的操作数堆栈称为操作数堆栈。</p><p>创建包含操作数堆栈的帧时，操作数堆栈为空。Java虚拟机提供指令将常量或值从局部变量或字段加载到操作数堆栈。其他Java虚拟机指令从操作数堆栈中获取操作数，对其进行操作，并将结果推回操作数堆栈。操作数堆栈还用于准备要传递给方法的参数并接收方法结果。</p><p>例如，iadd指令（§iadd）将两个整数值相加。它要求要添加的int值是操作数堆栈的前两个值，由之前的指令推送到那里。两个int值都从操作数堆栈中弹出。它们被相加，其和被推回操作数堆栈。子计算可以嵌套在操作数堆栈上，从而产生可由包含计算使用的值。</p><p>操作数堆栈上的每个条目都可以保存任何Java虚拟机类型的值，包括long或double类型的值。</p><p>必须以适合其类型的方式对操作数堆栈中的值进行操作。例如，不可能推送两个int值并随后将其视为long，也不可能推两个float值并随后使用iadd指令将其相加。少量Java虚拟机指令（dup指令（§dup）和swap（§swap））作为原始值在运行时数据区域上运行，而不考虑其特定类型；这些指令的定义方式不能用于修改或分解单个值。操作数堆栈操作的这些限制是通过类文件验证来实施的（§4.10）。</p><p>在任何时间点，操作数堆栈都具有关联的深度，其中long或double类型的值对深度贡献两个单位，而任何其他类型的值贡献一个单位。</p><h4 id="2-6-3-动态链接（Dynamic-Linking）"><a href="#2-6-3-动态链接（Dynamic-Linking）" class="headerlink" title="2.6.3.动态链接（Dynamic Linking）"></a>2.6.3.动态链接（Dynamic Linking）</h4><p>每个帧（§2.6）包含对当前方法类型的运行时常量池（§2.5.5）的引用，以支持方法代码的动态链接。一个方法的类文件代码指的是要被调用的方法和要通过符号引用访问的变量。动态链接将这些符号化的方法引用转化为具体的方法引用，必要时加载类以解决尚未定义的符号，并将变量访问转化为与这些变量的运行时位置相关的存储结构中的适当偏移量。</p><p>这种方法和变量的后期绑定使得方法所使用的其他类的变化不太可能破坏这段代码。</p><h4 id="2-6-4-正常方法调用完成（Normal-Method-Invocation-Completion）"><a href="#2-6-4-正常方法调用完成（Normal-Method-Invocation-Completion）" class="headerlink" title="2.6.4.正常方法调用完成（Normal Method Invocation Completion）"></a>2.6.4.正常方法调用完成（Normal Method Invocation Completion）</h4><p>如果一个方法的调用没有导致异常（§2.10）被抛出，无论是直接从Java虚拟机还是执行显式抛出语句的结果，该方法的调用就正常完成。如果当前方法的调用正常完成，那么就可以向调用方法返回一个值。这发生在被调用的方法执行返回指令之一的时候（§2.11.8），选择的指令必须适合被返回的值的类型（如果有）。</p><p>在这种情况下，当前帧（§2.6）被用来恢复调用者的状态，包括它的局部变量和操作数栈，调用者的程序计数器被适当增加，以跳过方法调用指令。然后在调用方法的框架中继续正常执行，并将返回值（如果有的话）推到该框架的操作数栈中。</p><h4 id="2-6-5-突然的方法调用完成（Abrupt-Method-Invocation-Completion）"><a href="#2-6-5-突然的方法调用完成（Abrupt-Method-Invocation-Completion）" class="headerlink" title="2.6.5.突然的方法调用完成（Abrupt Method Invocation Completion）"></a>2.6.5.突然的方法调用完成（Abrupt Method Invocation Completion）</h4><p>如果在方法中执行一个 Java 虚拟机指令导致 Java 虚拟机抛出一个异常（§2.10），并且该异常没有在方法中被处理，那么方法调用就会突然完成。执行 athrow 指令（§athrow）也会导致明确抛出一个异常，如果该异常没有被当前方法捕获，则会导致方法调用突然完成。一个突然完成的方法调用不会向其调用者返回一个值。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/08/06/Git/"/>
    <url>/2021/08/06/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git（分布式版本控制系统）"><a href="#Git（分布式版本控制系统）" class="headerlink" title="Git（分布式版本控制系统）"></a>Git（分布式版本控制系统）</h1><blockquote><p>版本控制</p></blockquote><ul><li>实现多人协同开发</li><li>追踪和记载一个或多个文件的历史纪录</li><li>组织和保护源代码和文档</li><li>统计工作量</li><li>并行开发，提高工作效率</li><li>跟踪记录整个软件的开发过程</li></ul><blockquote><p>启动Git</p></blockquote><p><strong>Git Bash</strong>：Unix与Linux风格的命令行</p><p><strong>Git CMD</strong>：Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git</p><blockquote><p>Git配置</p></blockquote><p>查看配置<code>git config -l</code></p><p><img src="/2021/08/06/Git/image-20210629101204736.png" alt="gitbash"></p><p>查看不同级别的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看系统config</span><br>git config --system --list<br><br><span class="hljs-comment">#查看当前用户（global）配置</span><br>git config --global --list<br></code></pre></td></tr></table></figure><blockquote><p>设置用户名与邮箱（用户标识）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置全局名称</span><br>git config --global user.name <span class="hljs-string">&quot;CZH&quot;</span><br><span class="hljs-comment">#设置全局邮箱</span><br>git config --global user.email 519110882@qq.com<br></code></pre></td></tr></table></figure><h1 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h1><blockquote><p>工作区域</p></blockquote><p>Git本地有三个工作目录：工作目录（Working Directory）、暂存区（Stage&#x2F;Index）、资源库（Repository或Git Directory）。如果加上远程的git仓库（Remote Directory）就可以分为四个工作区域。文件在这四个区域的转换关系如下：</p><p><img src="/2021/08/06/Git/3e35ec8c825a6a1c04609de7cd5700d9.png" alt="git四个区域的转换关系"></p><ul><li>Workspace：工作区，存放项目代码的地方</li><li>Index&#x2F;Stage：暂存区，用于临时存放你的改动，它只是一个文件</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里有提交的所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器</li></ul><blockquote><p>工作流程</p></blockquote><p>git的一般工作流程：</p><ol><li>在工作目录中添加、修改文件。</li><li>将需要进行版本管理的文件放入暂存区域。（<code>git add .</code>）</li><li>将暂存区域的文件提交到git仓库。(<code>git commit</code>)</li></ol><p>因此，git管理的文件有三种状态：已修改（modified），已暂存（staged），已提交（committed）</p><p><img src="/2021/08/06/Git/3985563-6b745d5fac15906c.png" alt="git工作流程"></p><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><blockquote><p>创建工作目录与常用指令</p></blockquote><p><img src="/2021/08/06/Git/6bf8a06e60bc5d25fc2e9c94fc9280e1.png" alt="git常用指令和流程"></p><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库的两种方法：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1.创建全新的仓库，需要使用GIT管理的项目的根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在当前目录新建一个Git代码库</span><br>$ git init<br></code></pre></td></tr></table></figure><p>2.执行后可以看到仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><blockquote><p>克隆远程仓库</p></blockquote><p>克隆远程目录，将远程服务器上的仓库完全镜像一份到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> [url]<br></code></pre></td></tr></table></figure><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><blockquote><p>文件4种状态</p></blockquote><ul><li><strong>Untracked</strong>:未跟踪，此文件在文件夹中，但并没有加入到git库中，不参与版本控制。通过<code>git add </code>将状态变为<code>Staged</code>。</li><li><strong>Unmodify</strong>:文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，则变为<code>Modified</code>。如果使用<code>git rm</code>移出版本库，则成为<code>Untracked</code>文件。</li><li><strong>Modified</strong>:文件已修改，仅仅是修改，并没有进行其他的操作。这个文件有两个去处，通过<code>git add</code>可进入暂存<code>staged</code>状态，使用<code>git checkout</code>则丢弃修改，返回到<code>Unmodify</code>状态，这个<code>git checkout</code>即从库中取出文件，覆盖当前修改。</li><li><strong>Staged</strong>:暂存状态，执行<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为<code>Unmodify</code>状态。执行<code>git reset HEAD filename</code>取消暂存，文件状态为<code>Modified</code>。</li></ul><blockquote><p>查看文件状态</p></blockquote><p>通过如下命令查看文件状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看指定文件状态</span><br>git status [filename]<br><br><span class="hljs-comment">#查看所有文件状态</span><br>git status<br><br><span class="hljs-comment">#添加所有文件到暂存器</span><br>git add .<br><br><span class="hljs-comment">#提交暂存区中的内容到本地仓库 -m 提交信息</span><br>git commit -m “消息内容”<br></code></pre></td></tr></table></figure><blockquote><p>忽略文件</p></blockquote><p>有时不需要把某些文件纳入版本控制，比如前端node_modules、数据库文件、临时文件、设计文件等。</p><p>在主目录下建立“.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1，string2，…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（！），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.txt     <span class="hljs-comment">#忽略所有.txt结尾的文件</span><br>!lib.txt  <span class="hljs-comment">#但lib.txt除外</span><br>/temp        <span class="hljs-comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br>build/       <span class="hljs-comment">#忽略build/目录下的所有文件</span><br>doc/*.txt    <span class="hljs-comment">#会忽略 doc/notes.txt 但不包括doc/server/arch.txt</span><br></code></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p><img src="/2021/08/06/Git/1c8d9b661018ac17dfb6522d774360d7.png" alt="git分支"></p><p>git分支中的常用指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#列出所有本地分支</span><br>git branch<br><br><span class="hljs-comment">#列出所有远程分支</span><br>git branch -r<br><br><span class="hljs-comment">#新建一个分支，但依然停留在当前分支</span><br>git branch [branch-name]<br><br><span class="hljs-comment">#切换分支</span><br>git checkout [branch-name]<br><br><span class="hljs-comment">#新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><br><span class="hljs-comment">#合并指定分支到当前分支</span><br>git merge [branch]<br><br><span class="hljs-comment">#使用^向上移动1个提交记录</span><br>git checkout master^  <span class="hljs-comment">#git checkout HEAD^</span><br><br><span class="hljs-comment">#使用~&lt;num&gt;向上移动多个提交记录</span><br>git checkout HEAD~4<br><br><span class="hljs-comment">#强制修改分支位置</span><br>git branch -f master HEAD~3  <span class="hljs-comment">#将master分支强制指向HEAD的第3级父提交</span><br><br><span class="hljs-comment">#把分支记录回退几个提交记录实现撤销改动(仅对本地分支有效)</span><br><span class="hljs-comment">#reset(撤回到某个记录)</span><br>git reset HEAD~1<br><br><span class="hljs-comment">#远程分支撤销</span><br><span class="hljs-comment">#revert(撤回某个记录)</span><br>git revert HEAD<br><br><span class="hljs-comment">#复制提交记录到当前分支</span><br>git cherry-pick c2 c4 <span class="hljs-comment">#将c2和c4复制到当前分支</span><br><br><span class="hljs-comment">#删除分支</span><br>git branch -d [branch-name]<br><br><span class="hljs-comment">#删除远程分支</span><br>git push origin --delete [branch-name]<br>git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解和反射</title>
    <link href="/2021/08/05/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/08/05/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h2><h3 id="1-注解的定义"><a href="#1-注解的定义" class="headerlink" title="1.注解的定义"></a>1.注解的定义</h3><blockquote><p>注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。</p></blockquote><ol><li>注解是一种元数据形式。即注解是属于java的一种数据类型，和类、接口、数组、枚举类似。</li><li>注解用来修饰类、方法、变量、参数、包。</li><li>注解不会对所修饰的代码产生直接的影响。</li></ol><h3 id="2-注解的使用范围"><a href="#2-注解的使用范围" class="headerlink" title="2.注解的使用范围"></a>2.注解的使用范围</h3><p><strong>为编译器提供信息</strong> - 注解能被编译器检测到错误或抑制警告。</p><p><strong>编译时和部署时的处理</strong>- 软件工具能处理注解信息从而生成代码，XML文件等等。</p><p><strong>运行时的处理</strong> - 有些注解在运行时能被检测到</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>自定义注解使用的基本流程：</p><ul><li>第一步，定义注解，相当于定义标记；</li><li>第二步，配置注解，把标记打在需要用到的程序代码中；</li><li>第三步，解析注解，在编译器期或运行时检测到标记，并进行特殊操作。</li></ul><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><p>使用<code>@interface</code>关键字声明。<strong>在底层实现上，所有定义的注解都会自动继承<code>java.lang.annotation.Annotation</code>接口。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CherryAnnotation &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>;<br><span class="hljs-type">int</span>[] array();<br>&#125;<br></code></pre></td></tr></table></figure><p>定义注解类型需要注意以下几点：</p><ol><li>访问修饰符必须为public，不写默认为public；</li><li>该元素的类型只能是基本数据类型：String、Class、枚举类型、注解类型（体现了注解的嵌套效果）以及上述类型的一维数组；</li><li>该元素的名称一般定义为名词，如果注解中只有一个元素，建议把名字起为value（使用时会带来便利）</li><li>()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法；</li><li><code>default</code>代表默认值，值必须和第2点定义的类型一致；</li><li>如果没有默认值，那么后续使用注解时必须给该类型元素赋值。</li></ol><h3 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h3><p>元注解：专门修饰注解的注解。</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><blockquote><p>专门用来限定某个自定义注解能够被应用在哪些java元素上面的，使用一个枚举类型定义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ElementType</span> &#123;<br>    <span class="hljs-comment">/** 类，接口（包括注解类型）或枚举的声明 */</span><br>    TYPE,<br><br>    <span class="hljs-comment">/** 属性的声明 */</span><br>    FIELD,<br><br>    <span class="hljs-comment">/** 方法的声明 */</span><br>    METHOD,<br><br>    <span class="hljs-comment">/** 方法形式参数声明 */</span><br>    PARAMETER,<br><br>    <span class="hljs-comment">/** 构造方法的声明 */</span><br>    CONSTRUCTOR,<br><br>    <span class="hljs-comment">/** 局部变量声明 */</span><br>    LOCAL_VARIABLE,<br><br>    <span class="hljs-comment">/** 注解类型声明 */</span><br>    ANNOTATION_TYPE,<br><br>    <span class="hljs-comment">/** 包的声明 */</span><br>    PACKAGE<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@MyAnnotation被限定只能使用在类、接口或方法上面</span><br><span class="hljs-meta">@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>;<br>    <span class="hljs-type">int</span>[] array();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><blockquote><p>翻译为持久力、保持力，即用来修饰自定义注解的生命力。</p></blockquote><p>注解的声明周期有三个阶段：</p><ol><li>Java源文件阶段；</li><li>编译到class文件阶段；</li><li>运行期阶段。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RetentionPolicy</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Annotations are to be discarded by the compiler.</span><br><span class="hljs-comment">     * （注解将被编译器忽略掉）</span><br><span class="hljs-comment">     */</span><br>    SOURCE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Annotations are to be recorded in the class file by the compiler</span><br><span class="hljs-comment">     * but need not be retained by the VM at run time.  This is the default</span><br><span class="hljs-comment">     * behavior.</span><br><span class="hljs-comment">     * （注解将被编译器记录在class文件中，但在运行时不会被虚拟机保留，这是一个默认的行为）</span><br><span class="hljs-comment">     */</span><br>    CLASS,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Annotations are to be recorded in the class file by the compiler and</span><br><span class="hljs-comment">     * retained by the VM at run time, so they may be read reflectively.</span><br><span class="hljs-comment">     * （注解将被编译器记录在class文件中，而且在运行时会被虚拟机保留，因此它们能通过反射被读取到）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> java.lang.reflect.AnnotatedElement</span><br><span class="hljs-comment">     */</span><br>    RUNTIME<br>&#125;<br></code></pre></td></tr></table></figure><p>详解：</p><ol><li>如果一个注解被定义为RetentionPolicy.SOURCE，则它将被限定在Java源文件中，那么这个注解即不会参与编译也不会在运行期起任何作用，这个注解就和一个注释是一样的效果，只能被阅读Java文件的人看到；</li><li>如果一个注解被定义为RetentionPolicy.CLASS，则它将被编译到Class文件中，那么编译器可以在编译时根据注解做一些处理动作，但是运行时JVM（Java虚拟机）会忽略它，我们在运行期也不能读取到；</li><li>如果一个注解被定义为RetentionPolicy.RUNTIME，那么这个注解可以在运行期的加载阶段被加载到Class对象中。那么在程序运行阶段，我们可以通过反射得到这个注解，并通过判断是否有这个注解或这个注解中属性的值，从而执行不同的程序代码段。我们实际开发中的自定义注解几乎都是使用的RetentionPolicy.RUNTIME；</li><li>在默认的情况下，自定义注解是使用的RetentionPolicy.CLASS。</li></ol><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><blockquote><p>@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。</p></blockquote><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>@Inherited注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。</p><h3 id="3-特殊语法"><a href="#3-特殊语法" class="headerlink" title="3.特殊语法"></a>3.特殊语法</h3><ol><li>如果注解本身没有注解类型元素，那么在使用注解的时候可以省略()，直接写为：@注解名，它和标准语法@注解名()等效！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value = &#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FirstAnnotation &#123;<br>&#125;<br><br><span class="hljs-comment">//---------------------------------------</span><br><br><span class="hljs-comment">//等效于@FirstAnnotation()</span><br><span class="hljs-meta">@FirstAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span>&#123;<br><span class="hljs-comment">//省略实现部分</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>如果注解本本身只有一个注解类型元素，而且命名为value，那么在使用注解的时候可以直接使用：@注解名(注解值)，其等效于：@注解名(value &#x3D; 注解值)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value = &#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SecondAnnotation &#123;<br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------</span><br><br><span class="hljs-comment">//等效于@ SecondAnnotation(value = &quot;this is second annotation&quot;)</span><br><span class="hljs-meta">@SecondAnnotation(&quot;this is annotation&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span>&#123;<br><span class="hljs-comment">//省略实现部分</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>如果注解中的某个注解类型元素是一个数组类型，在使用时又出现只需要填入一个值的情况，那么在使用注解时可以直接写为：@注解名(类型名 &#x3D; 类型值)，它和标准写法：@注解名(类型名 &#x3D; {类型值})等效！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value = &#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ThirdAnnotation &#123;<br>String[] name();<br>&#125;<br><br><span class="hljs-comment">//--------------------------------------------</span><br><br><span class="hljs-comment">//等效于@ThirdAnnotation(name = &#123;&quot;this is third annotation&quot;&#125;)</span><br>@ ThirdAnnotation(name = <span class="hljs-string">&quot;this is third annotation&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span>&#123;<br><span class="hljs-comment">//省略实现部分</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>如果一个注解的@Target是定义为Element.PACKAGE，那么这个注解是配置在package-info.java中的，而不能直接在某个类的package代码上面配置。</li></ol><h3 id="4-反射操作获取注解"><a href="#4-反射操作获取注解" class="headerlink" title="4.反射操作获取注解"></a>4.反射操作获取注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnnotation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取Student的Class对象</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">stuClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;czh.Student&quot;</span>);<br><br>            <span class="hljs-comment">//说明一下，这里形参不能写成Integer.class，应写为int.class</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">stuMethod</span> <span class="hljs-operator">=</span> stuClass.getMethod(<span class="hljs-string">&quot;study&quot;</span>,<span class="hljs-type">int</span>.class);<br><br>            <span class="hljs-keyword">if</span>(stuMethod.isAnnotationPresent(MyAnnotation.class))&#123;<br>                System.out.println(<span class="hljs-string">&quot;Student类上配置了MyAnnotation注解！&quot;</span>);<br>                <span class="hljs-comment">//获取该元素上指定类型的注解</span><br>                <span class="hljs-type">MyAnnotation</span> <span class="hljs-variable">myAnnotation</span> <span class="hljs-operator">=</span> (MyAnnotation) stuMethod.getAnnotation(MyAnnotation.class);<br>                System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + myAnnotation.name() + <span class="hljs-string">&quot;, age: &quot;</span> + myAnnotation.age()<br>                    + <span class="hljs-string">&quot;, score: &quot;</span> + myAnnotation.score()[<span class="hljs-number">0</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Student类上没有配置MyAnnotation注解！&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详解：</p><ol><li>如果我们要获得的注解是配置在方法上的，那么我们要从Method对象上获取；如果是配置在属性上，就需要从该属性对应的Field对象上去获取，如果是配置在类型上，需要从Class对象上去获取。总之在谁身上，就从谁身上去获取！</li><li><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>方法是专门判断该元素上是否配置有某个指定的注解；</li><li><code>getAnnotation(Class&lt;A&gt; annotationClass)</code>方法是获取该元素上指定的注解。之后再调用该注解的注解类型元素方法就可以获得配置时的值数据；</li><li>反射对象上还有一个方法<code>getAnnotations()</code>，该方法可以获得该对象身上配置的所有的注解。它会返回给我们一个注解数组，需要注意的是该数组的类型是Annotation类型，这个Annotation是一个来自于java.lang.annotation包的接口。</li></ol><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>此注解可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</p><p><font color="FF0000">(已被淘汰)</font></p><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>此注解只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>用来抑制编译时的警告信息，可以修饰类、方法、方法参数、属性、局部变量，需要添加一个参数才能正确使用。</p><ul><li>deprecation:使用了过时的类或方法的警告</li><li>unchecked：执行了未检查时的转换时的警告，集合就是未指定泛型</li><li>fall through:当在switch语句使用时发生case穿透</li><li>path:在类路径、源文件路径等中有不存在路径的警告</li><li>serial:可序列化类上缺少serialVerisonUID定义时的警告</li><li>finally:任何finally不能完成时的警告</li><li>all:以上所有情况的警告。</li></ul><h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p>表示指定接口必须为函数式接口</p><h3 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h3><p>此注解用来抑制堆污染警告</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>定时任务使用</p><p>来源：spring</p><p>属性说明</p><table><thead><tr><th>属性</th><th>类型</th><th>属性描述</th><th>示例</th></tr></thead><tbody><tr><td>cron</td><td>String</td><td>任务执行的cron表达式</td><td>0&#x2F;1 * * * * ?</td></tr><tr><td>zone</td><td>String</td><td>cron表达式解析时使用的时区，默认为服务器的本地时区，使用java.util.TimeZone#getTimeZone(String)方法解析</td><td>GMT-8:00</td></tr><tr><td>fixedDelay</td><td>long</td><td>上一次任务执行结束到下一次执行开始的间隔时间,单位为ms</td><td>1000</td></tr><tr><td>fixedDelayString</td><td>String</td><td>上一次任务执行结束到下一次执行开始的间隔时间,使用java.time.Duration#parse解析</td><td>PT15M</td></tr><tr><td>fixedRate</td><td>long</td><td>以固定间隔执行任务，即上一次任务执行开始到下一次执行开始的间隔时间,单位为ms,若在调度任务执行时,上一次任务还未执行完毕,会加入worker队列,等待上一次执行完成后立即执行下一次任务</td><td>2000</td></tr><tr><td>fixedRateString</td><td>String</td><td>与fixedRate逻辑一致,只是使用java.time.Duration#parse解析</td><td>PT15M</td></tr><tr><td>initialDelay</td><td>long</td><td>首次任务执行的延迟时间</td><td>1000</td></tr><tr><td>initialDelayString</td><td>String</td><td>首次任务执行的延迟时间,使用java.time.Duration#parse解析</td><td>PT15M</td></tr></tbody></table><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>需要在类上添加<code>@EnableScheduling</code>注解，以启用Spring的计划任务执行功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskTest</span> &#123;<br><br>    <span class="hljs-meta">@Scheduled(fixedDelay = 1000)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//        log.info(&quot;定时任务：task test&quot;);</span><br>        System.out.println(<span class="hljs-string">&quot;定时任务：task test,时间戳：&quot;</span> + System.currentTimeMillis());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定时任务执行默认为单线程模式，会创建一个本地线程池，线程池大小为1。当项目中有多个定时任务时，任务之间会相互等待，同步执行。</p><p>可通过实现SchedulingConfigurer接口手动创建线程池，配置期望线程数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//示例代码</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SchedulingConfigurer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务执行线程池大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TASK_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TASK_THREAD_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test-task-&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar scheduledTaskRegistrar)</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskScheduler</span> <span class="hljs-variable">taskPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskScheduler</span>();<br>        taskPool.setPoolSize(TASK_POOL_SIZE);<br>        taskPool.setThreadNamePrefix(TASK_THREAD_PREFIX);<br>        taskPool.initialize();<br>        scheduledTaskRegistrar.setTaskScheduler(taskPool);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>事务</p><p>来源：spring</p><p>属性说明</p><table><thead><tr><th>属性</th><th>类型</th><th>属性描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>可选的限定描述符，指定使用的事务管理器</td></tr><tr><td>propagation</td><td>enum:Propagation</td><td>可选的事务传播行为设置</td></tr><tr><td>isolation</td><td>enum:Isolation</td><td>可选的事务隔离级别设置</td></tr><tr><td>readOnly</td><td>boolean</td><td>读写或只读事务，默认读写</td></tr><tr><td>timeout</td><td>int</td><td>事务超时时间设置</td></tr><tr><td>rollbackFor</td><td>Class&lt;? extends Throwable&gt;[]</td><td>导致事务回滚的异常类数组</td></tr><tr><td>rollbackForClassName</td><td>String[]</td><td>导致事务回滚的异常类名字数组</td></tr><tr><td>noRollbackFor</td><td>Class&lt;? extends Throwable&gt;[]</td><td>不会导致事务回滚的异常类数组</td></tr><tr><td>noRollbackForClassName</td><td>String[]</td><td>不会导致事务回滚的异常类名字数组</td></tr></tbody></table><p>propagation属性</p><p>事务传播行为</p><ul><li><p><code>Propagation.REQUIRED</code></p><p>如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。</p></li><li><p><code>Propagation.SUPPORTS</code></p><p>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</p></li><li><p><code>Propagation.MANDATORY</code></p><p>如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</p></li><li><p><code>Propagation.REQUIRES_NEW</code></p><p>重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</p></li><li><p><code>Propagation.NOT_SUPPORTED</code></p><p>以非事务的方式运行，如果当前存在事务，暂停当前的事务。</p></li><li><p><code>Propagation.NEVER</code></p><p>以非事务的方式运行，如果当前存在事务，则抛出异常。</p></li><li><p><code>Propagation.NESTED</code></p><p>和 Propagation.REQUIRED 效果一样。</p></li></ul><p>isolation属性</p><p>事务隔离级别</p><ul><li><p><code>Isolation.DEFAULT</code></p><p>使用底层数据库默认的隔离级别</p></li><li><p><code>Isolation.READ_UNCOMMITTED</code></p><p>未授权读取级别</p><p>读取未提交数据(会出现脏读，不可重复读) 基本不使用</p></li><li><p><code>Isolation.READ_COMMITTED</code></p><p>授权读取级别</p><p>读取已提交数据(会出现不可重复读和幻读)</p></li><li><p><code>Isolation.REPEATABLE_READ</code></p><p>可重复读取级别</p><p>可重复读(会出现幻读)</p></li><li><p><code>Isolation.SERIALIZABLE</code></p><p>序列化级别</p></li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>在接口、接口方法、类、类方法上添加注解<code>@Transactional</code>即可。</p><h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><h2 id="静态与动态语言"><a href="#静态与动态语言" class="headerlink" title="静态与动态语言"></a>静态与动态语言</h2><p><strong>动态语言</strong></p><p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗来说就是在运行时代码可以根据某些条件改变自身的结构。</p><p>主要动态语言：C#、JavaScript、PHP、Python等。</p><p><strong>静态语言</strong></p><p>与动态语言相对应，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p><p>Java不是动态语言，但Java可以称之为“准动态语言”，即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活。</p><h2 id="Java-Reflection"><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助与Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>)<br></code></pre></td></tr></table></figure><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象地称之为：<strong>反射</strong>。</p><p>正常方式：引入需要的“包类”名称→通过new实例化→取得实例化对象</p><p>反射方式：实例化对象→getClass()方法→得到完整的“包类”名称</p><h2 id="Java反射机制的应用"><a href="#Java反射机制的应用" class="headerlink" title="Java反射机制的应用"></a>Java反射机制的应用</h2><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><h2 id="Java反射优点和缺点"><a href="#Java反射优点和缺点" class="headerlink" title="Java反射优点和缺点"></a>Java反射优点和缺点</h2><p>优点</p><p>可以实现动态创建对象和编译，体现出很大的灵活性</p><p>缺点</p><p>对性能有影响。使用反射基本上是一种解释操作：告诉JVM我们希望做什么并且它能满足我们的要求。这类操作总慢于直接执行相同的操作。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><ul><li>Class本身也是一个类</li><li>Class对象只能由系统建立对象</li><li>一个加载的类在JVM中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reflection的根源，针对任何想动态加载、运行的类，唯有先获得相应的Class对象。</li></ul><h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><table><thead><tr><th>方法名</th><th>功能说明</th></tr></thead><tbody><tr><td>static ClassforName(String name)</td><td>返回指定类名name的Class对象</td></tr><tr><td>Object newInstance()</td><td>调用缺省构造函数，返回Class对象的一个实例</td></tr><tr><td>getName()</td><td>返回此Class对象所表示的实体（类，接口，数组类或void）的名称</td></tr><tr><td>Class getSuperClass()</td><td>返回当前Class对象的父类的Class对象</td></tr><tr><td>Class[] getInterfaces()</td><td>获取当前Class对象的接口</td></tr><tr><td>ClassLoader getClassLoader()</td><td>返回该类的类加载器</td></tr><tr><td>Constructor[] getConstructors()</td><td>返回一个包含某些Constructor对象的数组</td></tr><tr><td>Method getMethod(String naem, Class..T)</td><td>返回一个Method对象，此对象的形参类型为paramType</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回Field对象的一个数组</td></tr></tbody></table><h3 id="获取Class类的实例"><a href="#获取Class类的实例" class="headerlink" title="获取Class类的实例"></a>获取Class类的实例</h3><p>a) 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br></code></pre></td></tr></table></figure><p>b)已知某个类的实例，调用该实例的getClass()方法获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> person.getClass();<br></code></pre></td></tr></table></figure><p>c)已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNoFoundException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;demo.Person&quot;</span>)<br></code></pre></td></tr></table></figure><p>d)内置基本数据类型可以直接用类名.Type</p><p>e)还可以利用ClassLoader</p><h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象"></a>哪些类型可以有Class对象</h3><ul><li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</li><li>interface：接口</li><li>[]：数组</li><li>enum：枚举</li><li>annotation：注解@interface</li><li>primitive type：基本数据类型</li><li>void</li></ul><h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><pre><code class=" mermaid">graph LRa(源程序.java文件) --&gt; b[Java编译器]b --&gt; c[字节码.class文件]c --&gt; d[类装载器]d --&gt; e[字节码校验器]e --&gt; f[解释器]f --&gt; g(操作系统平台)</code></pre><p><strong>类加载器的作用</strong>：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p><p><strong>类缓存</strong>：标准的JavaSE类加载器可以按照要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p><p><strong>类加载器的种类</strong></p><ul><li>启动类加载器&#x2F;引导类加载器</li></ul><p>用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。<font color="FF0000">该加载器无法直接获取。</font></p><ul><li>扩展类加载器</li></ul><p>负责<code>jre/lib/ext</code>目录下的jar包或<code>-D java.ext.dirs</code>指定目录下的jar包装入工作库。</p><ul><li>系统类加载器&#x2F;应用类加载器</li></ul><p>负责<code>java -classpath</code>或<code>-D java.class.path</code>所指的目录下的类与jar包装入工作，是最常用的加载器。</p><p><img src="/2021/08/05/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/7634245-7b7882e1f4ea5d7d.png" alt="双亲委派机制"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取系统类加载器</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> CLassLoader.getSystemClassLoader();<br>System.out.println(systemClassLoader);<br><br><span class="hljs-comment">//获取系统类加载器的父类加载器--&gt;扩展类加载器</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>System.out.println(parent);<br><br><span class="hljs-comment">//获取扩展类加载器的父类加载器--&gt;启动类加载器(C/C++)</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent1</span> <span class="hljs-operator">=</span> parent.getParent();<br>System.out.println(parent1);<span class="hljs-comment">//输出为null</span><br></code></pre></td></tr></table></figure><h3 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h3><p>通过反射获取运行时类的完整结构</p><p>Field、Method、Constructor、Superclass、Interface、Annotation</p><h3 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得Class对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.czh.common.User&quot;</span>)<br><br><span class="hljs-comment">//构造一个对象</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) c1.newInstance();<span class="hljs-comment">//本质是调用了类的无参构造器</span><br><br><span class="hljs-comment">//通过构造器创建对象</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class,<span class="hljs-type">int</span>.class,<span class="hljs-type">int</span>.class);<br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> (User)constructor.newInstance(<span class="hljs-string">&quot;czh&quot;</span>, <span class="hljs-number">001</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">//通过反射调用普通方法</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user3</span> <span class="hljs-operator">=</span> (User)c1.newInstance();<br><span class="hljs-comment">//通过反射获取一个方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>setName.invoke(user3, <span class="hljs-string">&quot;czh&quot;</span>);<br>System.out.println(user3.getName());<br><br><span class="hljs-comment">//通过反射操作属性</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user4</span> <span class="hljs-operator">=</span> (User)c1.newInstance();<br><span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">//不能直接操作私有属性，需要关闭程序的安全检测</span><br><span class="hljs-comment">//setAccessible()设为true</span><br>name.setAccessible(<span class="hljs-literal">true</span>);<br>name.set(user4, <span class="hljs-string">&quot;czh&quot;</span>);<br>System.out.println(user4.getName());<br></code></pre></td></tr></table></figure><h3 id="setAccessible"><a href="#setAccessible" class="headerlink" title="setAccessible"></a>setAccessible</h3><ul><li>Method、Field和Constructor对象都有setAccessible()方法。</li><li>setAccessible作用是启动和禁用访问安全检查的开关。</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁地被调用，那么请设置为true。</li><li>使得原本无法访问的私有成员也可以访问。</li></ul></li><li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li></ul><h2 id="反射获取泛型信息"><a href="#反射获取泛型信息" class="headerlink" title="反射获取泛型信息"></a>反射获取泛型信息</h2><ul><li>ParameterizedType：表示一种参数化类型，比如Collection&lt;String&gt;。</li><li>GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型。</li><li>TypeVariable：是各种类型变量的公共父接口。</li><li>WildcardType：代表一种通配符类型表达式。</li></ul><h2 id="反射获取注解信息"><a href="#反射获取注解信息" class="headerlink" title="反射获取注解信息"></a>反射获取注解信息</h2><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>1.连接点</p><p>类里面哪些方法可以被增强，这些方法称为连接点。</p><p>2.切入点</p><p>实际被真正增强的方法，称为切入点</p><p>3.通知（增强）</p><p>（1）实际增强的逻辑部分称为通知（增强）</p><p>（2）通知类型</p><ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常通知</li><li>最终通知</li></ul><p>4.切面</p><p>把通知应用到切入点的过程</p><h2 id="aop操作"><a href="#aop操作" class="headerlink" title="aop操作"></a>aop操作</h2><p>切入点表达式：</p><p>（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强。</p><p>（2）语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) )</p><p>举例1：对<code>com.czh.controller.TestController</code>类内的<code>add</code>方法进行增强。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* com.czh.controller.TestController.add(..)</span></span>)<br></code></pre></td></tr></table></figure><p>举例2：对<code>com.czh.controller.TestController</code>类内的所有方法进行增强。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* com.czh.controller.TestController.*(..)</span></span>)<br></code></pre></td></tr></table></figure><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ol><li>开启注解扫描</li><li>在增强类上添加注解<code>@Aspect</code></li><li>配置不同类型的通知</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">//生成代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> &#123;<br> <span class="hljs-comment">//前置通知</span><br> <span class="hljs-comment">//@Before 注解表示作为前置通知</span><br> <span class="hljs-meta">@Before(value = &quot;execution(* com.czh.controller.TestController.add(..))&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;before.........&quot;</span>);<br> &#125;<br> <span class="hljs-comment">//后置通知（返回通知）</span><br> <span class="hljs-meta">@AfterReturning(value = &quot;execution(* com.czh.controller.TestController.add(..))&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;afterReturning.........&quot;</span>);<br> &#125;<br> <span class="hljs-comment">//最终通知</span><br> <span class="hljs-meta">@After(value = &quot;execution(* com.czh.controller.TestController.add(..))&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;after.........&quot;</span>);<br> &#125;<br> <span class="hljs-comment">//异常通知</span><br> <span class="hljs-meta">@AfterThrowing(value = &quot;execution(* com.czh.controller.TestController.add(..))&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;afterThrowing.........&quot;</span>);<br> &#125;<br> <span class="hljs-comment">//环绕通知</span><br> <span class="hljs-meta">@Around(value = &quot;execution(* com.czh.controller.TestController.add(..))&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> <br>Throwable &#123;<br> System.out.println(<span class="hljs-string">&quot;环绕之前.........&quot;</span>);<br> <span class="hljs-comment">//被增强的方法执行</span><br> proceedingJoinPoint.proceed();<br> System.out.println(<span class="hljs-string">&quot;环绕之后.........&quot;</span>);<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>可抽取相同切入点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//相同切入点抽取</span><br><span class="hljs-meta">@Pointcut(value = &quot;execution(* com.czh.controller.TestController.add(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointdemo</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><span class="hljs-comment">//前置通知</span><br><span class="hljs-comment">//@Before 注解表示作为前置通知</span><br><span class="hljs-meta">@Before(value = &quot;pointdemo()&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;before.........&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>多个增强类对同一个方法进行增强，可设置增强类优先级</li></ol><p>在增强类上添加注解<code>@Order(数字类型值)</code>，数字类型值越小优先级越高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonProxy</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2021/08/04/Maven/"/>
    <url>/2021/08/04/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven（项目构建工具）"><a href="#Maven（项目构建工具）" class="headerlink" title="Maven（项目构建工具）"></a>Maven（项目构建工具）</h1><h2 id="1-Maven四大特性"><a href="#1-Maven四大特性" class="headerlink" title="1.Maven四大特性"></a>1.Maven四大特性</h2><h3 id="1-1-依赖管理系统"><a href="#1-1-依赖管理系统" class="headerlink" title="1.1.依赖管理系统"></a>1.1.依赖管理系统</h3><p>用groupId、artifavtId、version组成Coordination（坐标）唯一标识</p><p><strong>坐标属性的理解</strong></p><p>​Maven坐标为各种组件引入了秩序，任何一个组件都必须明确定义自己的坐标。</p><p><strong>groupId</strong></p><p>​定义当前Maven项目隶属的实际项目-公司名称。</p><p><strong>artifactId</strong></p><p>​该元素定义实际项目中的一个Maven模块-项目名，推荐使用实际项目名称作为artifactId的前缀。比如：spring-bean, spring-webmvc等。</p><p><strong>version</strong></p><p>​该元素定义Maven项目当前所处的版本。</p><h3 id="1-2-多模块构建"><a href="#1-2-多模块构建" class="headerlink" title="1.2.多模块构建"></a>1.2.多模块构建</h3><p>​在Maven中需要定义一个parent POM作为一组module的聚合POM。在该POM中可以使用<code>&lt;modules&gt;</code>标签来定义一组子模块。parent POM不会有什么实际构建产出。而parent POM中的build配置以及依赖配置都会自动继承给子module。</p><h3 id="1-3-一致的项目结构"><a href="#1-3-一致的项目结构" class="headerlink" title="1.3.一致的项目结构"></a>1.3.一致的项目结构</h3><p>​设计理念Conversion over configuration（约定大于配置），制定了一套项目目录结构作为标准的java项目结构，解决不同IDE带来的文件目录不一致问题。</p><h3 id="1-4-一致的构建模型和插件机制"><a href="#1-4-一致的构建模型和插件机制" class="headerlink" title="1.4.一致的构建模型和插件机制"></a>1.4.一致的构建模型和插件机制</h3><h2 id="2-Maven依赖的基本概念"><a href="#2-Maven依赖的基本概念" class="headerlink" title="2.Maven依赖的基本概念"></a>2.Maven依赖的基本概念</h2><p>根元素project下的dependencies可以包含多个dependence元素，以声明多个依赖。每个依赖都包含以下元素：</p><ol><li><p>groupId，artifactId，version：依赖的坐标。</p></li><li><p>Type：依赖的类型，大部分情况下不需要声明，默认值为jar。</p></li><li><p>Scope：依赖范围（compile，test，provided，runtime，system）</p><ul><li><p>compile：编译依赖范围</p><p>如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。</p></li><li><p>test：测试依赖范围</p><p>使用此依赖范围Maven依赖，只对于测试classpath有效，但在运行时无效。</p></li><li><p>provided：已提供依赖范围</p><p>使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。</p></li><li><p>runtime：运行时依赖范围</p><p>使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。</p></li><li><p>system：系统依赖范围</p><p>该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应谨慎使用。一般不使用。</p></li></ul></li><li><p>Optional：标记依赖是否可选。</p></li><li><p>Exclusions：用来排除传递性依赖。</p></li></ol><p>##3.Maven的生命周期</p><p>maven构建项目的过程，清理，编译，测试，报告，打包，安装，部署。</p><h2 id="4-Maven仓库"><a href="#4-Maven仓库" class="headerlink" title="4.Maven仓库"></a>4.Maven仓库</h2><p>仓库分为两类：本地仓库和远程仓库。</p><p>远程仓库分为三种：中央仓库、私服、其他公共库。</p><h3 id="4-1-中央仓库"><a href="#4-1-中央仓库" class="headerlink" title="4.1.中央仓库"></a>4.1.中央仓库</h3><p>由于原始本地仓库是空的，maven必须知道至少一个可用的远程仓库，才能执行maven命令的时候下载需要的构件。</p><h3 id="4-2-私服"><a href="#4-2-私服" class="headerlink" title="4.2.私服"></a>4.2.私服</h3><p>私服是一种特殊的远程仓库，是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的maven用户使用。当maven需要下载构件时，它去私服当中找，如果私服没有，则从外部远程仓库下载，并缓存在私服上，再提供给maven。</p><p>###4.3.其他公共库</p><p>常用阿里云仓库</p><h3 id="4-4-conf配置文件"><a href="#4-4-conf配置文件" class="headerlink" title="4.4.conf配置文件"></a>4.4.conf配置文件</h3><p>settings.xml的顶级元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">interactiveMode</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">usePluginRegistry</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">offline</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">proxies</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>LocalRepository</strong></p><p>作用：该值表示构建系统本地仓库的路径。</p><p>其默认值：~&#x2F;.m2&#x2F;repository</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>$&#123;user.home&#125;/.m2/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>InteractiveMode</strong></p><p>作用：表示maven是否需要和用户交互以获得输入。</p><p>如果maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">interactiveMode</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">interactiveMode</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>UsePluginRegistry</strong></p><p>作用：maven是否需要使用plugin-registry.xml文件来管理插件版本。</p><p>如果需要让maven使用文件~&#x2F;.m2&#x2F;plugin-registry.xml来管理插件版本，则设为true。默认为false。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">usePluginRegistry</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">usePluginRegistry</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Offline</strong></p><p>作用：表示maven是否需要在离线模式下运行。</p><p>如果构建系统需要在离线模式下运行，则为true，默认为false。 当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">offline</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">offline</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>PluginGroups</strong></p><p><strong>作用</strong>：当插件的组织id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。 </p><p>该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。 当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了<code>org.apache.maven.plugins</code>和<code>org.codehaus.mojo</code></p><p><strong>Servers</strong></p><p><strong>作用</strong>：一般，仓库的下载和部署是在pom.xml文件中的<code>repositories</code>和<code>distributionManagement</code>元素中定义的。然而，一般类似用户名、密码（<strong>有些仓库访问是需要安全认证的</strong>）等信息不应该在pom.xml文件中配置，这些信息可以配置在<code>settings.xml</code>中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-comment">&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--服务器元素包含配置服务器时需要的信息 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>server001<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>my_login<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>my_password<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是$&#123;user.home&#125;/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">privateKey</span>&gt;</span>$&#123;usr.home&#125;/.ssh/id_dsa<span class="hljs-tag">&lt;/<span class="hljs-name">privateKey</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--鉴权时使用的私钥密码。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">passphrase</span>&gt;</span>some_passphrase<span class="hljs-tag">&lt;/<span class="hljs-name">passphrase</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">filePermissions</span>&gt;</span>664<span class="hljs-tag">&lt;/<span class="hljs-name">filePermissions</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--目录被创建时的权限。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">directoryPermissions</span>&gt;</span>775<span class="hljs-tag">&lt;/<span class="hljs-name">directoryPermissions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Mirrors</strong></p><p><strong>作用</strong>：为仓库列表配置的下载镜像列表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给定仓库的下载镜像。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>planetmirror.com<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 镜像名称 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>PlanetMirror Australia<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://downloads.planetmirror.com/pub/maven2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Proxies</strong></p><p><strong>作用</strong>：用来配置不同的代理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">proxies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--代理元素包含配置代理时需要的信息 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">proxy</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>myproxy<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">active</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">active</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">protocol</span>&gt;</span>http<span class="hljs-tag">&lt;/<span class="hljs-name">protocol</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>proxy.somewhere.com<span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>proxyuser<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>somepassword<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">nonProxyHosts</span>&gt;</span>*.google.com|ibiblio.org<span class="hljs-tag">&lt;/<span class="hljs-name">nonProxyHosts</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">proxy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">proxies</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Profiles</strong></p><p><strong>作用</strong>：根据环境参数来调整构建配置的列表。 <code>settings.xml</code>中的<code>profile</code>元素是<code>pom.xml</code>中<code>profile</code>元素的<strong>裁剪版本</strong>。 它包含了<code>id</code>、<code>activation</code>、<code>repositories</code>、<code>pluginRepositories</code>和 <code>properties</code>元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个<code>settings.xml</code>中的<code>profile</code>被激活，它的值会覆盖任何其它定义在<code>pom.xml</code>中带有相同id的<code>profile</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- profile的唯一标识 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 自动触发profile的条件逻辑 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span> /&gt;</span><br>      <span class="hljs-comment">&lt;!-- 扩展属性列表 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> /&gt;</span><br>      <span class="hljs-comment">&lt;!-- 远程仓库列表 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span> /&gt;</span><br>      <span class="hljs-comment">&lt;!-- 插件仓库列表 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Activation</strong></p><p><strong>作用</strong>：自动触发<code>profile</code>的条件逻辑。 如<code>pom.xml</code>中的<code>profile</code>一样，<code>profile</code>的作用在于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过<code>activation</code>元素指定。 <code>activation</code>元素并不是激活<code>profile</code>的唯一方式。<code>settings.xml</code>文件中的<code>activeProfile</code>元素可以包含<code>profile</code>的<code>id</code>。<code>profile</code>也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--profile默认是否激活的标识 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">os</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--激活profile的操作系统的名字 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Windows XP<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Windows<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">arch</span>&gt;</span>x86<span class="hljs-tag">&lt;/<span class="hljs-name">arch</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--激活profile的操作系统版本 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.2600<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">os</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;name&#125;引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--激活profile的属性的名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mavenVersion<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--激活profile的属性的值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exists</span>&gt;</span>$&#123;basedir&#125;/file2.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exists</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">missing</span>&gt;</span>$&#123;basedir&#125;/file1.properties<span class="hljs-tag">&lt;/<span class="hljs-name">missing</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注：在maven工程的pom.xml所在目录下执行<code>mvn help:active-profiles</code>命令可以查看中央仓储的profile是否在工程中生效。</strong></p><p><strong>properties</strong></p><p><strong>作用</strong>：对应<code>profile</code>的扩展属性列表。 maven属性和ant中的属性一样，可以用来存放一些值。这些值可以在<code>pom.xml</code>中的任何地方使用标记<code>$&#123;X&#125;</code>来使用，这里X是指属性的名称。属性有五种不同的形式，并且都能在settings.xml文件中访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">  1. env.X: 在一个变量前加上&quot;env.&quot;的前缀，会返回一个shell环境变量。例如,&quot;env.PATH&quot;指代了$path环境变量（在Windows上是%PATH%）。 </span><br><span class="hljs-comment">  2. project.x：指代了POM中对应的元素值。例如: &lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;通过$&#123;project.version&#125;获得version的值。 </span><br><span class="hljs-comment">  3. settings.x: 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;通过 $&#123;settings.offline&#125;获得offline的值。 </span><br><span class="hljs-comment">  4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 $&#123;java.home&#125;。 </span><br><span class="hljs-comment">  5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">user.install</span>&gt;</span>$&#123;user.home&#125;/our-project<span class="hljs-tag">&lt;/<span class="hljs-name">user.install</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注：如果该profile被激活，则可以在<code>pom.xml</code>中使用${user.install}。</strong></p><p><strong>Repositories</strong></p><p><strong>作用</strong>：远程仓库列表，它是maven用来填充构建系统本地仓库所使用的一组远程仓库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--远程仓库唯一标识 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>codehausSnapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--远程仓库名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Codehaus Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span>always<span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>pluginRepositories</strong></p><p><strong>作用</strong>：发现插件的远程仓库列表。 和<code>repository</code>类似，只是<code>repository</code>是管理jar包依赖的仓库，<code>pluginRepositories</code>则是管理插件的仓库。 maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。<code>pluginRepositories</code>元素的结构和<code>repositories</code>元素的结构类似。每个<code>pluginRepository</code>元素指定一个Maven可以用来寻找新插件的远程地址。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>ActiveProfiles</strong></p><p><strong>作用</strong>：手动激活profiles的列表，按照<code>profile</code>被应用的顺序定义<code>activeProfile</code>。 该元素包含了一组<code>activeProfile</code>元素，每个<code>activeProfile</code>都含有一个profile id。任何在<code>activeProfile</code>中定义的profile id，不论环境设置如何，其对应的 <code>profile</code>都会被激活。如果没有匹配的<code>profile</code>，则什么都不会发生。 例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">                      https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 要激活的profile id --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>env-test<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Maven工程约定目录结构"><a href="#5-Maven工程约定目录结构" class="headerlink" title="5.Maven工程约定目录结构"></a>5.Maven工程约定目录结构</h2><table><thead><tr><th>目录</th><th>目的</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放pom.xml和所有的子目录</td></tr><tr><td>${basedir}&#x2F;src&#x2F;main&#x2F;java</td><td>项目的java源代码</td></tr><tr><td>${basedir}&#x2F;src&#x2F;main&#x2F;resources</td><td>项目的资源</td></tr><tr><td>${basedir}&#x2F;src&#x2F;test&#x2F;java</td><td>项目的测试类，例如Junit代码</td></tr><tr><td>${basedir}&#x2F;src&#x2F;test&#x2F;resources</td><td>测试使用的资源</td></tr></tbody></table><p><img src="/2021/08/04/Maven/image-20210630112712583.png" alt="工程目录结构"></p><h2 id="6-Maven命令"><a href="#6-Maven命令" class="headerlink" title="6.Maven命令"></a>6.Maven命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn -version</td><td>显示版本信息</td></tr><tr><td>mvn clean</td><td>清理项目生产的临时文件，一般是模块下的target目录</td></tr><tr><td>mvn compile</td><td>编译主程序，一般编译模块下的src&#x2F;main&#x2F;java目录，生成target目录，存放编译主程序之后生成的字节码文件。</td></tr><tr><td>mvn test-compile</td><td>编译测试程序，生成target目录，存放编译测试程序之后生成的字节码文件。</td></tr><tr><td>mvn test</td><td>测试命令（会生成一个目录surefire-reports，保存测试结果）</td></tr><tr><td>mvn package</td><td>打包主程序，把主程序打包成jar包或war包</td></tr><tr><td>mvn install</td><td>将打包的jar&#x2F;war文件复制到本地仓库中，供其他模块使用</td></tr><tr><td>mvn deploy</td><td>部署主程序（把本工程打包，按照本工程的坐标保存到本地库中）</td></tr></tbody></table><p>运行maven命令的时候需要定位到maven项目的目录，也就是项目的pom.xml所在目录，否则，必须通过参数来指定项目目录。</p><h2 id="7-POM依赖"><a href="#7-POM依赖" class="headerlink" title="7.POM依赖**"></a>7.POM依赖**</h2><h2 id="8-插件"><a href="#8-插件" class="headerlink" title="8.插件**"></a>8.插件**</h2><h2 id="9-依赖冲突"><a href="#9-依赖冲突" class="headerlink" title="9.依赖冲突**"></a>9.依赖冲突**</h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目构建工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
